- 앞서 살펴본 사용자 식별 및 인증을 돕는 HTTP 기능들은 중요한 트랜잭션을 보호하기에는 부족
- 이번 장에서는 디지털 암호화를 이용해서 HTTP 트랜잭션을 안전하게 보호하는 기술을 배워볼 것

<br>

## 1. HTTP를 안전하게 만들기

- 사람들이 웹 트랜잭션 상에서 수행하는 일들은 무척 중요한 일들
  - 온라인 쇼핑이나 인터넷뱅킹을 위한 강력한 보안 필요
  - 회사의 중요한 문서를 웹 서버에 올려놓기 위해 접근 제어 기능 필요
- 안전성이 보다 중요한 트랜잭션을 위해서, HTTP와 디지털 암호화 기술을 결합해야 함
- 효율적이고, 이식이 잘 되고, 관리가 쉽고, 변화에 대한 적응력이 좋은 HTTP 보안 기술이 필요
  - 서버 인증: 클라이언트는 위조된 서버가 아닌 진짜 서버와 이야기하고 있음을 알 수 있어야 함
  - 클라이언트 인증: 서버 또한 진짜 사용자와 이야기하고 있음을 알 수 있어야 함
  - 무결성: 클라이언트와 서버는 데이터 위조로부터 안전해야 함
  - 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 함
  - 효율: 저렴한 클라이언트나 서버를 위해 알고리듬은 충분히 빨라야 함
  - 편재성(Ubiquity): 프로토콜은 거의 모든 클라이언트 및 서버에서 지원되어야 함
  - 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 함
  - 적응성: 현재 알려진 최선의 보안 방법을 지원해야 함
  - 사회적 생존성: 사회의 문화적, 정치적 요구를 만족시켜야 함

### 1.1 HTTPS

- HTTPS는 HTTP를 안전하게 만드는 방식 중 가장 인기가 높음
- Netscape Communications Corporation에서 개쳑했으며, 모든 주류 브라우저 및 서버 지원
- HTTPS를 사용시, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화됨
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작
  - 이 보안 계층은 SSL(Secure Sockets Layer) 혹은 TLS(Transport Layer Security)를 이용해서 구현됨
  - SSL과 TLS는 매우 비슷하기 때문에 보통 'SSL'이란 단어로 양쪽을 혼용해서 사용하곤 함

![HTTP   HTTPS](https://user-images.githubusercontent.com/75058239/206882243-46eeed00-1988-4d5f-acfa-36443ab7f8bd.png)

- 암호화를 위한 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 진행
  - 따라서 클라이언트 및 서버는 보안 HTTP 사용을 위해 프로토콜 처리 로직을 크게 변경시킬 필요가 없음
  - 대부분의 경우, TCP IO 호출을 SSL 호출로 대체하고, 보안 정보 설정 및 관리를 위한 몇 가지 호출을 추가하면 됨

<br>

## 2. 디지털 암호학

- 본격적으로 HTTPS를 살펴보기에 앞서, SSL과 HTTPS에 사용되는 암호 인코딩 기법에 대한 배경 지식 필요
- 배경 지식을 쌓기 위해 다뤄볼 것들
  - **암호** : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리듬
  - **키** : 암호의 동작을 변경하는 숫자로 된 매개변수
  - **대칭키 암호 체계** : 인코딩 및 디코딩에 같은 키를 사용하는 알고리듬
  - **비대칭키 암호 체계** : 인코딩 및 디코딩에 다른 키를 사용하는 알고리듬
  - **공개키 암호법** : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 위한 시스템
  - **디지털 서명** : 메시지가 위조 혹은 변조되지 않았는지 입증하는 체크섬
  - **디지털 인증서** : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 2.1 비밀 코드의 기술과 과학

- 암호법(cryptography)은 메시지 인코딩 및 디코딩에 대한 과학이자 기술
- 암호법은 단순히 참견쟁이들이 볼 수 없도록 하는 것 뿐만 아니라, 누가 어떤 메시지나 트랜잭션의 저자임을 증명하기도 함

### 2.2 암호(cipher)

- 암호법은 암호라 불리는 비밀 코드에 기반
- 암호: 메시지를 인코딩하는 특정한 방법과 해당 비밀 메시지를 디코딩하는 방법
- 인코딩 되기 전 원본 메시지를 흔히 텍스트 혹은 평문이라 부르고, 암호가 적용된 메시지를 보통 암호문이라고 부름

### 2.3 암호 기계

- 기술이 진보하면서, 사람들은 보다 복잡하게 암호를 인코딩하고 디코딩하는 기계를 만들게 되었음
- 암호 기계는 단순한 회전 대신, 글자들을 대체하고, 순서를 바꾸고, 메시지를 자르고 토막내었음

### 2.4 키가 있는 암호

- 코드 알고리듬 및 기계가 탈취될 수 있기 때문에, 대부분의 기계들에는 암호 동작방식을 변경하는 다이얼이 달려있음
  - 올바른 다이얼 설정(키 값) 없이는 디코더는 동작하지 않음
- 이러한 암호 매개변수를 키라고 부름
- 디코딩 과정을 올바르게 동작시키려면 올바른 키를 암호 기계에 입력해야 함
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어줌
  - 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작
- 오늘날 거의 대부분의 암호 알고리듬은 키를 사용하고 있음

### 2.5 디지털 암호

디지털 계산의 도래와 함께 찾아온 2가지 발전

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어나, 더욱 복잡한 인코딩 및 디코딩 알고리듬이 가능해졌음
- 매우 큰 키를 지원하는 것이 가능해졌음
  - 단일 암호 알고리듬으로 키의 값마다 수조 개의 가상 암호 알고리듬을 만들어낼 수 있게 되었음
  - 키가 길수록 인코딩의 많은 조합이 가능해지고, 키를 무작위로 추측해서 크래킹하기 어려워짐

<br>

- 기계 장치의 물리적인 금속 키나 다이얼 설정과는 달리, 디지털 키는 그냥 숫자에 불과
  - 인코딩 및 디코딩 알고리듬에 대한 입력값
- 코딩 알고리듬은 데이터 덩어리를 받아서 알고리듬과 키의 값에 근거하여 인코딩하거나 디코딩하는 함수

<img width="770" alt="C=E(P,e)" src="https://user-images.githubusercontent.com/75058239/206930916-29107bcd-b3f4-43e6-84e1-a622b4dc0877.png">

- 평문 메시지 P, 인코딩 함수 E, 디지털 인코딩 키 e가 주어지면 부호화된 암호문 C 생성
  - 암호문 C는 디코더 함수 D와 디코딩 키 d를 사용해서 다시 평문 P로 디코딩할 수 있음

<br>

## 3. 대칭키 암호법

- 많은 디지털 암호 알고리듬을 대칭키 암호라고 부름
  - 인코딩할 때 사용하는 키가 디코딩할 때와 같기 때문 (e = d)
- 대칭키 암호에서는 발송자와 수신자 모두 통신을 위해 똑같은 비밀 키 k를 공유해야 함
  - 발송자는 k를 활용해서 메시지를 암호화하고 암호문을 수신자에게 발송
  - 수신자는 k를 활용해서 평문을 복원하기 위한 해독 함수 적용
- 잘 알려진 대칭키 암호 알고리듬으로 DES, Triple-DES, RC2, RC4 등이 있음

![대칭키 암호법](https://user-images.githubusercontent.com/75058239/207164626-08e498d2-71dd-4ea2-9677-edae49dfcb35.jpg)

### 3.1 키 길이와 열거 공격(Enumeration Attack)

- 비밀 키가 누설을 방지하는 일은 매우 중요
- 대부분의 경우 인코딩 및 디코딩 알고리듬은 공개적이므로, 키만이 유일한 비밀!
- 좋은 암호 알고리듬은 공격자가 우주에 존재하는 모든 가능한 키 값을 시도해보는 것 외에 다른 방법이 없게 함
- 무차별로 모든 가능한 키 값을 대입해보는 공격을 **열거 공격**이라고 함
- 가능한 키 값의 개수는 키가 몇 bit이며, 얼마나 많은 키가 유효한지에 달려있음
- 대칭키 암호에서는 보통 모든 키 값이 유효
  - 8 bit 키라면 256가지 값이 가능
  - 40 bit 키라면 2⁴⁰(약 1조)가지가 가능
- 평범한 대칭키 암호에서 40 bit 키는 작고 중요하지 않은 업무에서는 충분
  - 그러나 초당 수십억 번의 계산이 가능한 오늘날의 워크스테이션에게는 쉽게 깨질 수 있음
- 반면에 128 bit 키를 사용한 대칭키 암호는 매우 강력

### 3.2 공유키 발급하기

- 대칭키 암호의 단점: 발송자와 수신자가 서로 대화하기 위해 둘 다 공유키를 가져야 함
- 대화 참여자의 각 쌍은 그들만의 개인 키를 가져야 함
  - N개의 노드가 있고, 각 노드가 상대 N-1과 은밀하게 대화를 나눠야 한다면, 대략 N²개의 비밀 키가 필요
  - 관리해야 하는 사람 입장에서 이것은 지옥
