- 웹 상의 모든 정보나 업무가 공용은 아니기 때문에, 허가된 사람만이 데이터에 접근하고 업무를 처리할 수 있어야 함
  - 개인이나 기업의 민감한 문서는 권한이 있을 때 볼 수 있어야 함
  - 또한 웹은 가족이나 연인과 개인적인 대화를 마음 편히 나눌 수 있는 공간이어야 함
- 그러기 위해 서버는 사용자를 식별할 수 있어야 함
  - 사용자 식별을 통해 특정 작업 및 리소스에 접근 가능한지 여부를 결정할 수 있음
  - HTTP는 자체적인 인증 관련 기능을 제공
    - (역자 주) 요즘 웹 사이트들 대부분은 각각의 인증 모듈을 '직접' 구현함

<br>

## 1. 인증

사용자가 누구인지 증명하는 것

- 완벽한 인증이란 없음
  - 비밀번호는 추측될 수 있고 엿볼 수도 있으며, 신분증은 도둑 맞거나 위조될 수 있음
- 하지만 사용자 데이터는 사용자 식별에 도움이 됨

### 1.1 HTTP의 인증요구/응답 프레임워크

- HTTP는 자체적인 인증요구/응답 프레임워크를 제공
- 서버는 요청을 처리하는 대신 개인 정보를 요구하는 '인증 요구'로 응답할 수 있음
  - 그러면 사용자는 인증 정보를 첨부해서 다시 요청을 보내야 함
  - 인증 정보가 맞지 않으면 서버는 인증요구를 다시 보내거나 에러를 발생시킴
  - 인증 정보가 맞으면 요청은 문제없이 처리됨

### 1.2 인증 프로토콜과 헤더

- HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해,<br>다른 인증 프로토콜에 맞춰서 확장할 수 있는 프레임워크를 제공

|   단계   |        헤더         | 설명                                                                                                                       |   메소드/상태    |
| :------: | :-----------------: | :------------------------------------------------------------------------------------------------------------------------- | :--------------: |
|   요청   |                     | 첫 요청에는 인증 정보가 없음                                                                                               |       GET        |
| 인증요구 |  WWW-Authenticate   | 서버에서 인증 정보를 요구하는 401 상태 코드를 반환<br>서버는 WWW-Authenticate 헤더에 필요한 정보들을 기술함                | 401 Unauthorized |
|   인증   |    Authorization    | 클라이언트가 요청을 다시 보낼 때, 인증 정보가 담긴 Authorization 헤더를 함게 보냄                                          |       GET        |
|   성공   | Authentication-Info | 인증 정보가 확실한 경우 서버는 문서와 함께 응답<br>Authentication-Info 헤더는 optional이며, 세션에 관한 추가 정보를 기술함 |      200 OK      |

### 1.3 보안 영역

HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는가?

- 사용자가 미인증 상태여서 401 Unauthorized 응답을 보낼 때, 서버는 `realm` 지시자가 기술된 WWW-Authenticate 헤더를 전송

```http
HTTP/1.0 401 Authorization Required
WWW-Authenticate: Basic realm="Corporate Financials"
```

- 웹 서버는 기밀문서를 보안 영역 `realm` 그룹으로 나눔
- 예를 들어 웹 서버가 회사 재정 정보 영역과 개인 가족 문서 영역을 가질 때, 각 사용자는 서로 다른 영역으로 접근해야 함
- `realm`에 "executive-committee@bigcompany.com" 같은 서버 호스트명을 넣는 것이 유용할 수 있음

<br>

## 2. 기본 인증

- 거의 모든 주요 클라이언트 및 서버에 기본 인증이 구현되어 있음
- 원래 HTTP/1.0에 기술되어 있었지만, HTTP 인증의 상세 내용을 다루는 RFC 2617로 옮겨졌음

### 2.1 기본 인증의 예

- 사용자가 자신의 가족사진 `/family/jeff.jpg` 요청
- 서버는 WWW-Authenticate 헤더와 함께 401 Authorization Required 응답 반환
- 브라우저는 401 응답을 받고 Family 영역에 관한 사용자 이름과 비밀번호를 요구하는 대화상자를 띄움
- 사용자가 해당 정보를 입력하면, 브라우저는 그것들을 이어 붙여서<br>base-64 방식으로 인코딩해서 Authorization 헤더에 담아 서버로 보냄
- 서버는 사용자 이름과 비밀번호를 디코딩하고, 값이 정확한지 검사한 후, 문제가 없으면 200 OK와 함께 문서를 보냄

※ HTTP 기본 인증의 WWW-Authenticate 헤더와 Authorization 헤더

```http
WWW-Authenticate: Basic realm="Family"
```

```http
Authorization: Basic 7JWI64WV7ZWY7IS47JqULg==
```

### 2.2 Base-64 사용자 이름/비밀번호 인코딩

- HTTP 기본 인증은 사용자 이름과 비밀번호를 `:`으로 이어서 합치고, Base-64 인코딩 메소드를 사용해서 인코딩함
- Base-64 인코딩은 8 bit로 이루어져 있는 시퀀스를 6 bit 덩어리의 시퀀스로 변환함
  - 각 6 bit 조각은 대부분 문자와 숫자로 이루어진 특별한 64개 문자 중에서 선택됨
- Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송 가능한 알파벳으로 변환하기 위해 발명되었음
  - 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩 가능
- Base-64 인코딩은 `"` `:` CR 등 HTTP 헤더에서 사용할 수 없는 문자를 포함한 정보를 보내야 할 때 유용

### 2.3 프록시 인증

중개 프록시 서버를 통한 인증도 가능

- 프록시 서버가 접근 정책을 중앙 관리해서, 회사 리소스 전체에 대한 통합적인 접근 제어를 하도록 사용하면 좋음
- 프록시 인증은 웹 서버 인증과 헤더와 상태 코드만 다를 뿐 절차는 같음

※ 웹 서버 인증 vs 프록시 인증

|       웹 서버       |       프록시 서버        |
| :-----------------: | :----------------------: |
|         401         |           407            |
|  WWW-Authenticate   |    Proxy-Authenticate    |
|    Authorization    |   Proxy-Authorization    |
| Authentication-Info | Poxy-Authentication-Info |
