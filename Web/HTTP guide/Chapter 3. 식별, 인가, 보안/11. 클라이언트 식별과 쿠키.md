- 웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신함
- 서버들은 익명의 클라이언트 요청을 처리하는 것뿐만 아니라 클라이언트를 추적해야 할 수도 있음
- 이번 장에서 서버가 통신하는 대상을 식별하기 위해 사용하는 기술을 알아볼 것

<br>

## 1. 개별 접촉

- 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자의 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있음
- 현대 웹 사이트들은 개인화된 서비스를 제공하고자 함
  - 사용자들에 대해 더 많은 것을 알고 싶어 하며, 사용자들의 브라우징을 기록하고자 함

※ 유명한 온라인 쇼핑몰 Amazon.com 에서 제공하는 사이트 개인화 방법들

**개별 인사**

- 사용자에게 특화된 환영 메시지나 페이지 내용을 만듦

**사용자 맞춤 추천**

- 고객의 흥미를 학습해서, 좋아할 것이라고 예상되는 제품들을 추천
- 고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 함

**저장된 사용자 정보**

- 복잡한 주소와 신용카드 정보를 매번 입력하지 않도록 해줌
- 데이터베이스에 저장된 사용자 정보를 재사용

**세션 추적**

- 사용자가 사이트와 상호작용할 수 있도록 사용자의 상태를 남겨둠
- 상태를 유지하기 위해 웹 사이트는 HTTP 트랜잭션을 식별할 방법이 필요함

<br>

※ HTTP 사용자 식별 방법들

- HTTP 헤더들에 담긴 사용자 식별 관련 정보들
- 클라이언트 IP 주소 추적을 통해 사용자 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 fat URL
- 쿠키를 통해 식별 정보를 지속적으로 유지

<br>

## 2. HTTP 헤더

사용자 정보를 전달하는 가장 일반적인 7가지 HTTP 요청 헤더

|    헤더 이름    | 헤더 타입  | 설명                   |
| :-------------: | :--------: | :--------------------- |
|      From       |    요청    | 사용자 이메일 주소     |
|   User-Agent    |    요청    | 사용자 브라우저        |
|     Referer     |    요청    | 사용자가 어디서 왔는지 |
|  Authorization  |    요청    | 사용자 이름과 비밀번호 |
|    Client-ip    | 확장(요청) | 클라이언트 IP 주소     |
| X-Forwarded-For | 확장(요청) | 클라이언트 IP 주소     |
|     Cookie      | 확장(요청) | 서버가 생성한 ID 라벨  |

**From 헤더**

- 사용자 이메일 주소 포함
- 이상적으로는 각 사용자가 다른 이메일 주소를 가지므로, 사용자를 식별해낼 수 있음
- 하지만 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있기 때문에 잘 사용되지 않고 있음
- 실제로 웹 로봇이 데이터 수집 과정 중에 문제를 일으켰을 때 웹 마스터가 항의할 수 있도록 From 헤더를 추가함

**User-Agent 헤더**

- 사용자가 사용하고 있는 브라우저의 이름, 버전 정보, 어떤 경우에는 운영체제 정보까지 서버에 알려줌
- 특정 브라우저에서 제대로 동작하도록 그들의 속성에 맞추어 컨텐츠를 최적화하는 데 유용
- 하지만 특정 사용자를 식별하는 데는 큰 도움이 되지 않음

※ 크롬의 User-Agent

```http
Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36
```

**Referer**

- 사용자가 현재 페이지로 유입되기 직전 웹 페이지의 URL
- 사용자를 식별할 수 없음
- 그래도 사용자의 웹 사용 행태나 사용자의 취향을 파악할 수 있게 해줌

⇒ From, User-Agent, Referer 헤더들은 사용자 식별을 온전히 해내기에는 부족한 정보를 가짐

<br>

## 3. 클라이언트 IP 주소

- 초기 웹 선구자들은 사용자 식별에 클라이언트의 IP 주소를 사용하려 했음
  - 사용자가 확실한 IP 주소를 가지고 있으며, 좀처럼 바뀌지 않고, 웹 서버가 매 요청마다 IP 주소를 알 수 있으면 문제없이 동작
- 클라이언트의 IP 주소는 보통의 경우 헤더에 담기지 않지만, 웹 서버는 HTTP 요청을 보내온 TCP 커넥션의 IP 주소를 알 수 있음
  - 어떤 프록시는 `Client-ip` 헤더를 기술하지만, 이는 HTTP 표준이 아님
  - 유닉스 시스템의 경우, `getpeername` 함수로 요청을 보낸 클라이언트의 IP 주소를 받을 수 있음

```http
status = getpeername(tcp_connection_socket, ...);
```

**클라이언트 IP 주소 식별 방식의 약점**

- 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킴
  - 만약 여러 사람이 같은 컴퓨터를 사용한다면 그들을 식별할 수 없음
- 많은 ISP는 사용자 로그인 시 동적으로 IP 주소를 할당함
  - 로그인한 시간에 따라 사용자가 매번 다른 주소를 가지므로, 웹 서버는 사용자를 IP 주소로 식별할 수 없음
- 많은 사용자들이 NAT(Network Address Translation) 방화벽을 통해 인터넷을 사용함
  - NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고, 방화벽 IP 주소로 변환함
- 보통 HTTP 프록시 및 게이트웨이는 원 서버에 새로운 TCP 연결을 함
  - 웹 서버는 클라이언트 IP 주소가 아닌, 프록시 서버의 IP 주소를 보게 됨
  - 일부 프록시는 원본 IP 주소 보존을 위해 `Client-ip`나 `X-Forwarded-For HTTP` 같은 확장 헤더를 사용하지만,<br>모든 프록시가 이런 식으로 동작하는 것은 아님

<br>

## 4. 사용자 로그인

- 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 명시적인 식별 요청을 할 수 있음
- HTTP는 웹 사이트 로그인이 더 쉽도록 `WWW-Authenticate`와 `Authorization` 헤더를 사용할 수 있게 함
  - 웹 사이트에 사용자 이름을 전달하는 HTTP의 자체적인 체계
  - 한번 로그인하면 브라우저는 사이트로 보내는 모든 요청에서 로그인 정보를 함께 보내게 됨
  - 자세한 내용은 다음 장인 12장에서 확인할 것

※ 로그인 과정

1. 로그인이 안 된 유저가 로그인을 시도하면 서버는 `401 Login Required` 응답 코드와 `WWW-Authenticate` 헤더를 브라우저로 보내줌
2. 브라우저는 로그인 대화상자를 보여줘서 사용자에게 로그인을 요구함
3. 로그인 완료 후, 브라우저는 다음 요청부터 `Authorization` 헤더에 로그인 정보를 기술해서 보냄

**사용자 로그인의 단점**

웹 사이트 로그인은 귀찮은 일

- 사용자는 사이트를 옮겨다닐 때마다 각 사이트에 로그인해야 함
- 사용자는 각 사이트마다 서로 다른 사용자 이름과 비밀번호를 기억해야 함
- 사이트를 돌아다니다보면 사용자가 선호하는 이름이 이미 선점되었을 수 있음
- 어떤 사이트는 사용자 이름과 비밀번호 길이 및 조합 규칙이 다를 것
- 결국 사용자는 인터넷 사용을 포기하고 오프라윈프리 쇼를 보게 될 것

<br>

## 5. 뚱뚱한 URL

- 어떤 웹 사이트는 사용자 URL마다 버전을 기술해서 사용자를 식별하고 추적했음
- 사용자가 해당 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성
- 사용자의 상태 정보를 담고 있는 '뚱뚱한 URL'은 웹 상점을 돌아다니는 사용자에게 식별번호를 할당함
- 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문'으로 묶는 용도로 이 뚱뚱한 URL을 활용할 수 있음
  - 사용자 최초 방문시 유일 ID를 생성
  - ID 값은 서버가 인식할 수 있는 방식으로 URL에 추가
  - 서버는 클라이언트를 뚱뚱한 URL로 redirect
  - 서버가 뚱뚱한 URL이 포함된 요청을 받으면 사용자 아이디 및 추가 정보를 찾고, 밖으로 향하는 모든 링크를 뚱뚱한 URL로 바꿈

**뚱뚱한 URL의 심각한 문제점**

- 못생긴 URL
- 공유하지 못하는 URL
  - 누군가에게 공유하면 누적된 개인 정보를 본의 아니게 공유하게 될 수 있음
- 캐시 사용 불가
  - URL이 바뀌기 때문에 기존 캐시에 접근할 수 없음
- 서버 부하 가중
  - 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 함
- 이탈
  - 사용자는 링크를 타고 다른 사이트로 이동하거나 특정 URL을 직접 요청해서 이탈할 가능성이 있음
  - 사용자가 서비스 사용 중, 사전에 세션 정보가 추가된 링크만을 사용해야만 이 뚱뚱한 URL이 정상 작동
  - 사용자가 이탈하는 경우 사이트 이용 내역이 초기화되고 다시 처음부터 사용해야 할 것
- 세션 간 지속성 부재
  - 사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃한 경우에 모든 정보를 잃음

<br>

## 6. 쿠키

- 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식
- 넷스케이프에서 최초로 개발했고, 지금은 모든 브라우저에서 지원
- 매우 중요한 웹 기술이면서 새로운 HTTP 헤더를 정의하므로, 앞의 다른 기술들보다 자세하게 다룰 것
- 쿠키는 캐시와 충돌 가능성이 있기 때문에, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음

### 6.1 쿠키의 타입

**session cookie**

- 사용자가 사이트를 탐색할 때, 관련 설정 및 선호 사항들을 저장하는 임시 쿠키
- 사용자가 브라우저를 닫으면 삭제

**persistent cookie**

- 디스크에 저장되기 때문에, 브라우저를 닫거나 컴퓨터를 재시작해도 남아 있음
- 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하기 위해 사용

※ `Discard` 파라미터를 설정했거나, 또 `Expires` 혹은 `Max-Age` 파라미터가 없을 경우 session cookie가 됨

### 6.2 쿠키는 어떻게 동작하는가

(이미지 첨부 - 사용자에게 쿠키 할당)

- 사용자 최초 접속 시 웹 서버는 사용자에 대해 아무 것도 모름
- 그렇기 때문에 서버는 사용자가 다시 돌아올 때 식별하기 위해서 유일값을 쿠키에 할당
  - 쿠키는 임의의 `name=value` 형태의 리스트를 가지며,<br>해당 리스트는 `Set-Cookie` 혹은 `Set-Cookie2` 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달됨
  - 어떠한 정보든 포함될 수 있지만 서버가 생성한 단순 식별 번호만 포함하기도 함
  - 혹은 이름과 이메일, 전화 번호 등 더 많은 정보를 쿠키에 기록하고자 할 수도 있음
- 브라우저는 응답으로 받은 `Set-Cookie` 혹은 `Set-Cookie2` 헤더에 있는 쿠키 컨텐츠를 브라우저 쿠키 데이터베이스에 저장
- 브라우저는 다음 요청 때 저장해두었던 쿠키를 `Cookie` 요청 헤더에 기술해서 전송

### 6.3 쿠키 상자: 클라이언트 측 상태

- 쿠키의 기본 발상: 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 해당 정보를 함께 전송하게 하는 것
- 브라우저는 쿠키 정보를 저장할 책임이 있으며, 이 시스템을 '클라이언트 측 상태'라고 함
  - 공식 명칭: HTTP State Management Mechanism

**_구글 크롬의 쿠키 저장 방식_**

- 구글 크롬은 Cookies라는 SQLite 파일에 쿠키를 저장
- 총 13개의 필드가 존재
  - **creation_utc** : 쿠키 생성 시점, Jan 1, 1970 00:00:00 GMT 이후 시간을 초 단위로 기술
  - **host_key** : 쿠키의 도메인
  - **name** : 쿠키 이름
  - **value** : 쿠키 값
  - **path** : 쿠키 관련 도메인에 있는 경로
  - **expire_utc** : 쿠키 파기 시점, Jan 1, 1970 00:00:00 GMT 이후 시간을 초 단위로 기술
  - **secure** : 이 쿠키를 SSL 커넥션일 경우에만 보낼지 여부

### 6.4 사이트마다 각기 다른 쿠키들

- 브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 보통 각 사이트에 2~3개의 쿠키만을 보냄
  - 쿠키를 모두 전달하면 성능이 크게 저하되기 때문
  - 쿠키들 대부분이 특정 서버에 특화된 name/value 쌍을 포함하고 있어서, 해당되지 않는 사이트라면 무의미한 값
  - 잠재적인 개인정보 문제를 일으킬 수 있음
- 보통 브라우저는 쿠키를 생성해 주었던 서버에게만 해당 쿠키 정보를 전달
- 많은 웹 사이트는 광고를 관리하는 협력업체와 계약함
  - 광고들은 지속 쿠키를 만들어서, 사용자가 같은 광고사를 제공하는 다른 웹 사이트에 방문했을 때 지속 쿠키를 전달해줌
  - 지속 쿠키의 '도메인'이 서로 같기 때문
  - 광고사는 또한 `Referer` 헤더를 활용해서 사용자 프로필 및 웹 사이트 활용 습관에 대해 방대한 데이터를 구축할 수 있음
  - 최신 브라우저들은 개인정보 설정 기능을 통해 협력업체의 쿠키 사용 방식에 제약을 가할 수 있도록 하고 있음

**_쿠키 Domain 속성_**

```http
Set-cookie: user="Loko"; domain="airtravelbargains.com"
```

- 서버는 쿠키 생성시 `Set-Cookie` 응답 헤더에 `Domain` 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있음
- 이 응답을 받은 사용자는 해당 도메인 사이트에 방문하면 해당 Cookie 헤더가 항상 적용될 것

**_쿠키 Path 속성_**

```http
Set-cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/
```

- 특정 웹 사이트 중에서도 일부에만 쿠키를 적용할 수 있음
- 위 도메인의 해당 path로 접근했을 경우 2개의 쿠키를 받게 될 것

```http
Cookie: user="Loko"
Cookie: pref=compact
```

### 6.5 쿠키 구성요소

- Version 0 쿠키: 흔히 '넷스케이프 쿠키'라고 불림
- Version 1 쿠키: RFC 2965
  - Version 0 쿠키의 확장 버전
  - RFC 2965가 RFC 6265 "HTTP State Management Mechanism"에 의해 폐기되어 사용되지 않는 HISTORIC 상태
- 두 버전 모두 HTTP/1.1 명세로 기록되어 있지는 않음
