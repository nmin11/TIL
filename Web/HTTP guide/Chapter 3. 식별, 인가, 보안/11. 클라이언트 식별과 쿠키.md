- 웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신함
- 서버들은 익명의 클라이언트 요청을 처리하는 것뿐만 아니라 클라이언트를 추적해야 할 수도 있음
- 이번 장에서 서버가 통신하는 대상을 식별하기 위해 사용하는 기술을 알아볼 것

<br>

## 1. 개별 접촉

- 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자의 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있음
- 현대 웹 사이트들은 개인화된 서비스를 제공하고자 함
  - 사용자들에 대해 더 많은 것을 알고 싶어 하며, 사용자들의 브라우징을 기록하고자 함

※ 유명한 온라인 쇼핑몰 Amazon.com 에서 제공하는 사이트 개인화 방법들

**개별 인사**

- 사용자에게 특화된 환영 메시지나 페이지 내용을 만듦

**사용자 맞춤 추천**

- 고객의 흥미를 학습해서, 좋아할 것이라고 예상되는 제품들을 추천
- 고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 함

**저장된 사용자 정보**

- 복잡한 주소와 신용카드 정보를 매번 입력하지 않도록 해줌
- 데이터베이스에 저장된 사용자 정보를 재사용

**세션 추적**

- 사용자가 사이트와 상호작용할 수 있도록 사용자의 상태를 남겨둠
- 상태를 유지하기 위해 웹 사이트는 HTTP 트랜잭션을 식별할 방법이 필요함

<br>

※ HTTP 사용자 식별 방법들

- HTTP 헤더들에 담긴 사용자 식별 관련 정보들
- 클라이언트 IP 주소 추적을 통해 사용자 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 fat URL
- 쿠키를 통해 식별 정보를 지속적으로 유지

<br>

## 2. HTTP 헤더

사용자 정보를 전달하는 가장 일반적인 7가지 HTTP 요청 헤더

|    헤더 이름    | 헤더 타입  | 설명                   |
| :-------------: | :--------: | :--------------------- |
|      From       |    요청    | 사용자 이메일 주소     |
|   User-Agent    |    요청    | 사용자 브라우저        |
|     Referer     |    요청    | 사용자가 어디서 왔는지 |
|  Authorization  |    요청    | 사용자 이름과 비밀번호 |
|    Client-ip    | 확장(요청) | 클라이언트 IP 주소     |
| X-Forwarded-For | 확장(요청) | 클라이언트 IP 주소     |
|     Cookie      | 확장(요청) | 서버가 생성한 ID 라벨  |

**From 헤더**

- 사용자 이메일 주소 포함
- 이상적으로는 각 사용자가 다른 이메일 주소를 가지므로, 사용자를 식별해낼 수 있음
- 하지만 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있기 때문에 잘 사용되지 않고 있음
- 실제로 웹 로봇이 데이터 수집 과정 중에 문제를 일으켰을 때 웹 마스터가 항의할 수 있도록 From 헤더를 추가함

**User-Agent 헤더**

- 사용자가 사용하고 있는 브라우저의 이름, 버전 정보, 어떤 경우에는 운영체제 정보까지 서버에 알려줌
- 특정 브라우저에서 제대로 동작하도록 그들의 속성에 맞추어 컨텐츠를 최적화하는 데 유용
- 하지만 특정 사용자를 식별하는 데는 큰 도움이 되지 않음

※ 크롬의 User-Agent

```http
Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36
```

**Referer**

- 사용자가 현재 페이지로 유입되기 직전 웹 페이지의 URL
- 사용자를 식별할 수 없음
- 그래도 사용자의 웹 사용 행태나 사용자의 취향을 파악할 수 있게 해줌

⇒ From, User-Agent, Referer 헤더들은 사용자 식별을 온전히 해내기에는 부족한 정보를 가짐

<br>

## 3. 클라이언트 IP 주소

- 초기 웹 선구자들은 사용자 식별에 클라이언트의 IP 주소를 사용하려 했음
  - 사용자가 확실한 IP 주소를 가지고 있으며, 좀처럼 바뀌지 않고, 웹 서버가 매 요청마다 IP 주소를 알 수 있으면 문제없이 동작
- 클라이언트의 IP 주소는 보통의 경우 헤더에 담기지 않지만, 웹 서버는 HTTP 요청을 보내온 TCP 커넥션의 IP 주소를 알 수 있음
  - 어떤 프록시는 `Client-ip` 헤더를 기술하지만, 이는 HTTP 표준이 아님
  - 유닉스 시스템의 경우, `getpeername` 함수로 요청을 보낸 클라이언트의 IP 주소를 받을 수 있음

```http
status = getpeername(tcp_connection_socket, ...);
```

**클라이언트 IP 주소 식별 방식의 약점**

- 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킴
  - 만약 여러 사람이 같은 컴퓨터를 사용한다면 그들을 식별할 수 없음
- 많은 ISP는 사용자 로그인 시 동적으로 IP 주소를 할당함
  - 로그인한 시간에 따라 사용자가 매번 다른 주소를 가지므로, 웹 서버는 사용자를 IP 주소로 식별할 수 없음
- 많은 사용자들이 NAT(Network Address Translation) 방화벽을 통해 인터넷을 사용함
  - NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고, 방화벽 IP 주소로 변환함
- 보통 HTTP 프록시 및 게이트웨이는 원 서버에 새로운 TCP 연결을 함
  - 웹 서버는 클라이언트 IP 주소가 아닌, 프록시 서버의 IP 주소를 보게 됨
  - 일부 프록시는 원본 IP 주소 보존을 위해 `Client-ip`나 `X-Forwarded-For HTTP` 같은 확장 헤더를 사용하지만,<br>모든 프록시가 이런 식으로 동작하는 것은 아님

<br>

## 4. 사용자 로그인

- 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 명시적인 식별 요청을 할 수 있음
- HTTP는 웹 사이트 로그인이 더 쉽도록 `WWW-Authenticate`와 `Authorization` 헤더를 사용할 수 있게 함
  - 웹 사이트에 사용자 이름을 전달하는 HTTP의 자체적인 체계
  - 한번 로그인하면 브라우저는 사이트로 보내는 모든 요청에서 로그인 정보를 함께 보내게 됨
  - 자세한 내용은 다음 장인 12장에서 확인할 것

※ 로그인 과정

1. 로그인이 안 된 유저가 로그인을 시도하면 서버는 `401 Login Required` 응답 코드와 `WWW-Authenticate` 헤더를 브라우저로 보내줌
2. 브라우저는 로그인 대화상자를 보여줘서 사용자에게 로그인을 요구함
3. 로그인 완료 후, 브라우저는 다음 요청부터 `Authorization` 헤더에 로그인 정보를 기술해서 보냄

**사용자 로그인의 단점**

웹 사이트 로그인은 귀찮은 일

- 사용자는 사이트를 옮겨다닐 때마다 각 사이트에 로그인해야 함
- 사용자는 각 사이트마다 서로 다른 사용자 이름과 비밀번호를 기억해야 함
- 사이트를 돌아다니다보면 사용자가 선호하는 이름이 이미 선점되었을 수 있음
- 어떤 사이트는 사용자 이름과 비밀번호 길이 및 조합 규칙이 다를 것
- 결국 사용자는 인터넷 사용을 포기하고 오프라윈프리 쇼를 보게 될 것
