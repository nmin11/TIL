- HTTP는 매일 수십억 개의 미디어 객체를 실어 나름
- HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장함

※ HTTP가 보장하는 것들

- Content-Type과 Content-Language 헤더를 통해 객체를 올바르게 식별
- Content-Length와 Content-Encoding 헤더를 통해 객체는 올바르게 압축이 풀릴 것
- 엔티티 검사기와 캐시 만료 제어를 이용해서 객체는 항상 최신의 상태를 유지
- 내용 협상을 위한 Accept 관련 헤더들에 기반하여 사용자의 요구를 만족
- 데이터 압축을 이용해서 네트워크 사이를 빠르고 효율적으로 이동
- 전송 인코딩 헤더 및 Content-MD5 체크섬을 이용하기 때문에 조작되지 않을 것

<br>

- HTTP는 컨텐츠를 나르기 위해 잘 라벨링된 엔티티 사용
- 이 장에서는 엔티티 및 연관 헤더들이 웹상의 화물 수송을 위해 어떤 일을 하는지 논의할 것
  - HTTP가 어떻게 컨텐츠 크기, 타입, 인코딩에 대한 필수적인 값들을 제공하는지
  - HTTP 엔티티, range request, delta encoding, digest, chunked encoding 등 복잡하지만 강력한 기능들을 다룰 것

※ 이번 장에서 다룰 내용들

- HTTP 메시지를 담는 컨테이너인 HTTP 메시지 엔티티의 포맷과 작동 방식
- HTTP가 어떻게 엔티티 본문의 크기를 기술하는지
- 클라이언트가 컨텐츠를 바르게 처리할 수 있도록 제공되는 엔티티 헤더들
- 컨텐츠 인코딩
- 특정 종류의 컨텐츠 송수신 개선을 위한 전송 인코딩과 청크 인코딩
- 최신 버전을 전송할 수 있게 도와주는 태그, 라벨, 시간, 체크섬
- 버전 검사기와 최신 상태 유지를 돕는 HTTP 헤더 필드들
- 중단되었던 다운로드를 재개할 때 유용한 범위 요청
- 이미 본 페이지는 변경 부분만 재요청하게 해주는 HTTP 델타 인코딩 확장
- 프록시를 지나는 중 변경되지는 않았는지 검증하는 엔티티 본문 체크섬

<br>

## 1. 메시지는 컨테이너, 엔티티는 화물

※ HTTP/1.1의 12가지 주요 엔티티 헤더 필드

- **Content-Type** : 엔티티에 의해 전달된 객체 종류
- **Content-Length** : 전달되는 메시지의 길이나 크기
- **Content-Language** : 전달되는 객체와 가장 잘 대응되는 자연어
- **Content-Encoding** : 객체 데이터에 행해진 변형
- **Content-Location** : 요청 시점에 객체의 또 다른 위치
- **Content-Range** : 엔티티 전체에서 어느 부분에 해당하는지
- **Content-MD5** : 엔티티 본문의 컨텐츠에 대한 체크섬
- **Last-Modified** : 서버에서 컨텐츠가 생성되거나 수정된 날
- **Expires** : 엔티티 데이터의 신선도가 만료되는 날짜 및 시각
- **Allow** : 리소스에 대해 어떤 요청 메소드가 허용되는지
- **ETag** : 인스턴스에 대한 고유 검사기
- **Cache-Control** : 어떻게 문서가 캐시될 수 있는지에 대한 지시자

### 1.1 엔티티 본문

- 가공되지 않은 데이터만을 담고 있으며, 다른 정보들은 모두 헤더에 담겨 있음
  - 그렇기 때문에 엔티티 헤더는 날 데이터에 대해 설명할 필요가 있음
- 엔티티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작
  - 컨텐츠가 텍스트든, binary든, 이미지든, 압축되었든, 프랑스어든, 일본어든 상관없이 항상

<br>

## 2. Content-Length: 엔티티의 길이

- 엔티티 본문의 크기를 byte 단위로 나타냄
- 어떻게 인코딩되었든 상관없이 크기 표현 가능
- 청크 인코딩이 아닌 이상, 엔티티가 아예 없지 않은 이상, 필수적으로 있어야 함
- Content-Length는 메시지가 잘렸는지 검사할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할할 때 필요

### 2.1 잘림 검출

- Content-Length가 없으면 클라이언트는 커넥션이 정상적으로 종료된 것인지, 중간에 충돌이 있었는지 구분하지 못함
- 메시지 잘림은 캐싱 프록시 서버에서 특히 취약
  - 캐시가 잘린 메시지를 인식하지 못하면, 캐시는 결함 있는 컨텐츠를 계속해서 제공할 것
  - 이를 방지하기 위해 캐싱 프록시는 Content-Length가 명시적으로 있지 않으면 보통 본문을 캐싱하지 않음

### 2.2 잘못된 Content-Length

- 아예 없을 때보다 더 큰 피해를 유발할 수 있음
- 초창기 클라이언트 및 서버는 Content-Length 계산 관련 버그가 있으므로,<br>오늘날 몇몇 클라이언트, 서버, 프록시들은 이러한 오동작도 탐지하고 교정
- 공식적으호 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받았으며 이를 인지했을 경우, 사용자에게 알려주어야 함

### 2.3 Content-Length와 Persistent Connection

- Content-Length는 지속 커넥션을 위해 필수적
- 지속 커넥션 중에 클라이언트는 메시지 하나가 어디서 끝나고 다음 시작이 어디인지 명확히 알아야 함

### 2.4 컨텐츠 인코딩

- HTTP는 보안 강화 및 압축을 위해 엔티티 본문을 인코딩할 수 있음
- 컨텐츠가 인코딩되어 있는 경우 Content-Length는 인코딩 이후의 본문 길이를 byte 단위로 정의
- 역시 어떤 잘못된 HTTP 애플리케이션은 인코딩 전의 본문 길이를 보내기 때문에 주의해야 함

### 2.5 엔티티 본문 길이 판별을 위한 규칙

1. if (!msg.allow(body)) → Content-Length 헤더 무시
2. if (msg.contains(Transfer-Encoding))<br>커넥션이 닫혀서 트랜잭션이 끝나지 않는 이상, 엔티티는 '0 byte chunk'라 불리는 특별한 패턴으로 끝나야 함
3. if (msg.contains(Content-Length) && msg.allow(body) && !msg.contains(Transfer-Encoding))<br>Content-Length 값은 본문의 길이를 담음
4. if (msg.mediaType == 'multipart/byteranges' && !msg.contains(Content-Length))<br>멀티파트 메시지 각 부분은 각자가 스스로의 크기를 정할 수 있음<br>수신자가 이를 해석할 수 있다는 것을 알기 전에는 보내져서는 안됨
5. else → 엔티티는 커넥션이 닫힐 때 종료<br>실질적으로 서버만 메시지 종료를 알리기 위해 커넥션을 닫을 수 있음
6. HTTP/1.1 명세에서는 본문은 있지만 Content-Length가 없는 경우 400 Bad Request 혹은 411 Length Required 응답을 보내도록 조언함

<br>

## 3. 엔티티 요약

- HTTP는 TCP/IP 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 여러 이유로 전송 중 변형이 발생할 수 있음
- 변경 감지를 위해 송신자는 데이터에 대한 체크섬을 생성해서, 수신자가 엔티티의 변경을 검사할 수 있게 함
- Content-MD5 헤더: 서버가 엔티티 본문에 MD5 알고리듬을 적용한 결과를 전송
  - 오직 응답을 처음 만든 서버만이 이 헤더를 계산해서 보냄
  - 컨텐츠 인코딩이 적용되고 전송 인코딩이 적용되지 않은 엔티티 본문에 대한 MD5를 담음
  - 클라이언트는 전송 인코딩을 디코딩한 뒤에 MD5를 계산해야 함
  - 만약 gzip 알고리듬으로 압축하여 청크 인코딩으로 보낸다면, MD5 알고리듬은 압축된 본문 전체에 대해 수행
- MD5는 문서 위치를 빠르게 찾고 중복 저장을 방지하기 위한 해시 테이블의 키로도 사용 가능
- 하지만 이러한 활용 가치들에도 불구하고 그다지 자주 전송되지 않는 헤더
- HTTP 확장들은 IETF 초안으로 여러 요약 알고리듬들을 제안했음
  - 이에 따라, 클라이언트가 응답에 대해 기대하는 요약 유형을 정의할 수 있도록 새로운 헤더 Want-Digest가 제안되었음
  - Want-Digest는 quality value를 이용해서 여러 요약 알고리듬에 대한 선호도를 지정할 수 있음

<br>

## 4. 미디어 타입과 Charset

- Content-Type 헤더 필드는 엔티티 본문의 MIME 타입을 기술
- MIME 타입은 전달되는 데이터 매체의 기저 형식에 대한 표준화된 이름
  - HTML, MS Word, MPEG 등
- MIME 타입은 IANA(Internet Assigned Numbers Authority)에 등록되어 있음

※ 대표적인 MIME 타입들

|          미디어 타입          | 설명                              |
| :---------------------------: | :-------------------------------- |
|           text/html           | HTML 문서                         |
|          text/plain           | plain text 문서                   |
|           image/gif           | GIF 이미지                        |
|          image/jpeg           | JPEG 이미지                       |
|          audio/x-wav          | WAV 음향 데이터                   |
|          model/vrml           | 3차원 VRML 모델                   |
| application/vnd.ms-powerpoint | MS Powerpoint Presentation        |
|     multipart/byteranges      | 전체 문서의 특정 범위 (byte 단위) |
|         message/http          | 온전한 HTTP 메시지                |

### 4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type 헤더는 `charset`과 같이 컨텐츠 타입을 더 자세하게 지정하기 위한 선택적 매개변수 지원

```http
Content-Type: text/html; charset=iso-8859-4
```

### 4.2 멀티파트 미디어 타입

- 멀티파트 이메일 메시지의 경우 서로 붙어있는 여러 메시지를 포함
  - 하나의 복합 메시지로 전송됨
  - 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더 포함
  - 구성요소들은 문자열 하나로 서로의 경계 식별
- HTTP는 멀티파트 본문도 지원
  - 그러나 일반적으로 폼을 채워서 제출할 때나 일부분만 보내는 범위 응답을 할 때만 사용됨

### 4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출한 경우 가변 길이 텍스트 필드와 업로드될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어서 보내짐
- 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼 허용
- 이러한 요청을 Content-Type: multipart/form-data 혹은 Content-Type: multipart/mixed 헤더에 멀티파트 본문과 함께 보냄

```http
Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwxyz]
```

- `boundary`는 본문의 서로 다른 부분을 구분하기 위한 구분자

### 4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있음
- 그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

<br>

## 5. 컨텐츠 인코딩

- HTTP 애플리케이션은 때때로 컨텐츠 전송 전에 인코딩 수행
  - 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하는 경우
  - 해커가 볼 수 없도록 컨텐츠를 암호화하는 경우
- 인코딩은 발송하는 쪽에서 수행

### 5.1 컨텐츠 인코딩 과정

1. 웹 서버는 원본 Content-Type과 Content-Length 헤더를 수반한 응답 메시지 생성
2. 컨텐츠 인코딩 서버(원 서버 or 다운스트림 프록시)는 인코딩 메시지 생성<br>인코딩된 메시지는 Content-Type은 이전과 동일하지만 Content-Length가 달라짐<br>컨텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가
3. 수신 측 프로그램은 메시지를 디코딩하고 원본을 얻음

※ gzip 등으로 압축했을 때, 원본의 Content-Type을 따라야 하고, Content-Length는 또 gzip의 용량을 따라야 한다는 점에 유의!

### 5.2 컨텐츠 인코딩 유형

- HTTP는 몇 가지 표준 컨텐츠 인코딩 유형을 정의했으며, 확장 인코딩을 추가하는 것도 허용
- 인코딩은 각 컨텐츠 인코딩 알고리듬에 고유한 토큰을 할당해주는 IANA를 통해 표준화
- Content-Encoding 헤더는 표준화 토큰 값을 이용해서 인코딩에 사용된 알고리듬 기술

| 컨텐츠 인코딩 값 | 설명                                      |
| :--------------: | :---------------------------------------- |
|       gzip       | GNU zip 인코딩 적용                       |
|     compress     | 유닉스 파일 압축 프로그램 compress 실행됨 |
|     deflate      | zlib 포맷으로 압축됨                      |
|     identity     | 인코딩 없음 (default 값)                  |

- gzip, compress, deflate 인코딩은 무손실 압축 알고리듬
  - 특히 gzip이 가장 효율적이며 가장 널리 쓰임

### 5.3 Accept-Encoding 헤더

- 클라이언트가 지원하지 않는 인코딩 사용을 막기 위해, 클라이언트는 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달
  - 만약 이 헤더가 없으면 서버는 클라이언트가 어떠한 인코딩이든 다 받아들일 수 있는 것으로 간주 (Accept-Encoding: \*)

```http
Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
```

- 각 인코딩에 Q(quality) 값을 매개변수로 더해서 선호도를 나타낼 수 있음
- identity 인코딩 토큰은 오직 Accept-Encoding 헤더에만 존재할 수 있고, 클라이언트가 상대적 선호도를 나타낼 때 표현됨

<br>

## 6. 전송 인코딩과 청크 인코딩

- 컨텐츠 인코딩은 컨텐츠 포맷과 밀접한 연관이 있음
  - 예를 들어 텍스트 파일은 흔히 gzip으로 압축하지만, JPEG 파일은 gzip으로는 잘 압축되지 않음
- 전송 인코딩: 컨텐츠의 포맷과는 독립적인 인코딩 방식

### 6.1 안전한 전송

- 역사적으로 전송 인코딩은 다른 프로토콜에서도 '안전한 전송'을 위해 존재했음
- HTTP에서는 다음 2가지 문제를 위한 '안전한 전송'에 초점을 둠

**알 수 없는 크기**

- 몇몇 게이트웨이 애플리케이션과 컨텐츠 인코더는 컨텐츠 생성 전에 메시지 본문의 크기를 알 수 없음
- 그렇기 때문에 흔히들 사이즈를 알기 전에 데이터 전송을 시작하려고 함
- HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에, 몇몇 서버는 특별한 종결 꼬리말을 포함시켜서 전송 인코딩을 시도함

**보안**

- 전송 인코딩을 사용해서 메시지 내용을 알아보기 어렵게 뒤섞어버리는 방법도 있음
- 하지만 이미 SSL 같은 유명한 전송 계층 보안이 있기 때문에 전송 인코딩 보안은 흔치 않음

### 6.2 Transfer-Encoding 헤더

- 전송 인코딩을 위한 헤더는 단 2개 뿐

**Transfer-Encoding**

- 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지를 알려줌

**TE**

- 클라이언트가 어떤 확장 인코딩을 사용할 수 있는지 서버에게 알려주는 용도
- HTTP/1.1 애플리케이션이어야 함

※ 요청 헤더 예시

```http
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozila/4.61 [en] (WinNT; I)
TE: trailers, chunked
```

※ 응답 헤더 예시

```http
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
```

- HTTP 명세는 오직 하나의 전송 인코딩, 즉 chunk 인코딩만을 정의
- TE 헤더는 Accept-Encoding 헤더와 마찬가지로 어떤 형태의 전송 인코딩을 선호하는지를 표현하는 Q 값을 가질 수 있음
  - 하지만 HTTP/1.1 명세에서 chunk 인코딩에 대해 Q 값이 0.0을 갖는 것을 금지

### 6.3 청크 인코딩

- 청크 인코딩은 메시지를 일정 크기의 여러 청크로 쪼갬
- 서버는 각 청크를 순차적으로 보냄
- 청크 인코딩을 사용하면 메시지 전송 이전에 전체 크기를 알 필요가 없어짐
- 본문의 동적인 생성에 따라, 서버는 그 일부를 버퍼에 담은 뒤 한 청크를 크기와 함께 보낼 수 있음
- 청크 인코딩은 전송 인코딩의 한 형태이며, 따라서 본문이 아닌 메시지의 속성임에 유의!
  - 멀티파트 인코딩은 본문의 속성이며, 청크 인코딩과는 완전히 다름

**_청크와 지속 커넥션_**

- 지속 커넥션이 아니라면, 클라이언트는 서버가 커넥션을 닫았을 때 본문의 크기를 알 수 있음
- 반면 지속 커넥션에서는 본문 작성 전에 반드시 Content-Length 헤더를 담아서 보내줘야 함
- 청크 인코딩은 서버가 본문을 여러 청크로 쪼개서 보낼 수 있게 함으로써 이 딜레마에 대한 해법 제공
  - 서버는 청크를 하나씩 보낼 때마다 해당 청크의 크기를 함께 전송
  - 그리고 크기가 0인 청크로 본문의 끝을 알리며, 지속 커넥션을 유지할 수 있음
- 각 청크는 16진수로 표현되는 길이 값과 byte 단위로 측정되는 청크 데이터를 담고 있음
- 클라이언트가 청크 인코딩을 전송할 때는 서버에서 받아들여줄지 모르기 때문에 411 Length Required 응답에 대비해야 함

![청크 인코딩된 메시지의 구조](https://user-images.githubusercontent.com/75058239/208279095-002c42d0-ff6e-44c9-b18b-bdfcc861b9d4.png)

**_청크 인코딩된 메시지의 트레일러_**

- 청크 메시지에 트레일러를 추가할 수 있는 조건 (하나라도 만족하면 됨)
  - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타낼 경우
  - 서버에서 트레일러를 추가했고, 클라이언트가 트레일러의 컨텐츠를 이해하고 사용할 필요가 없는 선택적 메타데이터일 경우
- 트레일러에는 본문 컨텐츠를 먼저 생성해야 하는 등의 이유로 알 수 없는 추가 헤더 필드를 담을 수 있음
  - Trailer 헤더에 나중에 담을 헤더들을 담고, 마지막 청크 다음에 Trailer 헤더에 담아두었던 헤더들을 정의
  - Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 헤더라도 트레일러로 보낼 수 있음

### 6.4 컨텐츠와 전송 인코딩의 조합

- 컨텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있음
- 예를 들어 컨텐츠 인코딩으로 HTML 파일을 gzip으로 압축하고, gzip을 청크 데이터로서 전송 인코딩할 수 있는 것

### 6.5 전송 인코딩 규칙

- 전송 인코딩 집합은 반드시 'chunked'를 포함해야 함<br>유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 함
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 함<br>수신자가 메시지의 전송 길이를 알아낼 수 있도록

<br>

- 전송 인코딩읜 HTTP/1.1의 기능
  - 전송 인코딩을 구현한 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩 메시지를 보내지 않도록 주의해야 함
  - 마찬가지로 클라이언트도 이해할 수 없는 전송 인코딩 메시지를 받았다면 501 Unimplemented 상태 코드로 응답해야 함
  - HTTP/1.1 애플리케이션이라면 최소한 청크 인코딩만은 반드시 지원해야 함

<br>

## 7. 시간에 따라 바뀌는 인스턴스

- 웹 객체는 정적이지 않으며, 같은 URL이라도 시간에 따라 다른 버전의 객체를 가리킬 수 있음
  - [CNN](https://edition.cnn.com/)에 방문하면 매번 조금씩 다른 결과를 얻을 수 있음
- CNN 홈페이지를 하나의 객체라고 생각하면, 요청할 때마다 리소스의 각기 다른 인스턴스를 받게 되는 것
- HTTP 프로토콜은 **instance manipluation**이라 불리는 방법을 정의했음
  - 대표적인 2가지가 범위 요청과 델타 인코딩
  - 둘 모두 클라이언트가 자신이 갖고 있는 리소스의 사본이 서버의 것과 정확히 같은지 판단하고,<br>상황에 따라 새 인스턴스를 요청할 수 있는 능력을 가짐

<br>

## 8. 검사기와 신선도

- 클라이언트는 '조건부 요청'을 통해 사본 버전을 최신화할 수 있음
- 신선도, 검사기, 조건 이 3가지에 대해 살펴볼 것

### 8.1 신선도

- 서버는 Expires 혹은 Cache-Control 헤더를 통해 사본이 얼마나 오래 '신선'할 것인지 정보를 줄 수 있음

```http
Expires: Sun Mar 19 23:59:59 GMT 2001
```

- Expires 헤더는 문서가 신선하지 않게 되는 정확한 날짜를 명시
  - 이를 사용하는 클라이언트는 시계를 반드시 동기화시켜야 함
  - 하지만 NTP(Network Time Protocol) 같은 시계 동기화 프로토콜을 양쪽 모두 실행해야 하므로 생각보다 까다로움
- Cache-Control 헤더는 문서가 서버를 떠난 후부터 초 단위로 최대 수명을 정함
  - 수명은 시계 동기화에 의존하지 않게 됨
  - 단지 수명이나 유효기간뿐 아니라 신선도를 서술하기 위해서도 사용됨

|      지시자      | 메시지 타입 | 설명                                                                                                                                                                        |
| :--------------: | :---------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     no-cache     |    요청     | 서버와의 최초 재검사 없이 캐시된 사본을 반환할 수 없음                                                                                                                      |
|     no-store     |    요청     | 캐시된 사본을 아예 반환할 수 없음<br>서버로부터의 응답을 저장하지 말 것                                                                                                     |
|     max-age      |    요청     | 캐시 문서는 명시된 나이보다 오래되어서는 안됨                                                                                                                               |
|    max-stale     |    요청     | 문서가 신선하지 않더라도 여기서 지정한 시간보다 작다면 받아들임                                                                                                             |
|    min-fresh     |    요청     | 응답은 반드시 여기서 지정한 시간만큼은 신선할 것을 요구                                                                                                                     |
|   no-transform   |    요청     | 문서는 보내기 전에 변형될 수 없음                                                                                                                                           |
|  only-if-cached  |    요청     | 서버에 접근하지 말고, 캐시에 들어있는 경우에만 반환                                                                                                                         |
|      public      |    응답     | 응답은 어떤 캐시로든 캐시됨                                                                                                                                                 |
|     private      |    응답     | 응답은 하나의 클라이언트만 접근할 수 있도록 캐시됨                                                                                                                          |
|     no-cache     |    응답     | 여기에 헤더 필드가 포함된 경우 컨텐츠는 캐시될 수 있음<br>캐시 제공 전에 헤더 필드들은 반드시 제거되어야 함<br>헤더 필드가 없다면 캐시된 사본은 서버와의 재검사를 거쳐야 함 |
|     no-store     |    응답     | 응답은 절대로 캐시될 수 없음                                                                                                                                                |
|   no-transform   |    응답     | 응답은 제공되기 전에 수정되어서는 안됨                                                                                                                                      |
| must-revalidate  |    응답     | 응답은 제공되기 전에 서버를 통해 재검사되어야 함                                                                                                                            |
| proxy-revalidate |    응답     | 공유된 캐시는 반드시 응답을 원 서버와 재검사해야 함<br>개인 캐시에 의해 무시될 수 있음                                                                                      |
|     max-age      |    응답     | 문서가 신선하다고 여겨질 수 있는 시간의 최대 길이                                                                                                                           |
|    s-max-age     |    응답     | 공유된 캐시에 적용될 수 있는 문서 최대 수명<br>max-age 지시자를 덮어씀<br>개인 캐시에 의해 무시될 수 있음                                                                   |

### 8.2 조건부 요청과 검사기

- 캐시가 더욱 신선한 사본을 요청하고자 해도, 서버의 문서는 대개 캐시의 신선하지 못한 사본과 같을 것
- 조건부 요청을 활용하면 특정 조건이 true일 때만 요청을 수행하도록 할 수 있음

```http
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
```

- 조건부 요청은 `If-`로 시작하는 조건부 헤더에 의해 구현됨
- 조건이 false일 경우 서버는 HTTP 에러 코드를 반환
- 조건부 요청은 특정 검사기 위에서 동작
  - 검사기는 문서의 특정 속성을 테스트
  - 일련번호, 버전 번호, 최종 변경일 등
- 이번 장에서는 엔티티 검사기에 대해 자세하게 공부할 것

|      요청 유형      |    검사기     | 설명                                              |
| :-----------------: | :-----------: | :------------------------------------------------ |
|  If-Modified-Since  | Last-Modified | 마지막 수정 버전이 최신이 아니라면 사본을 줘라    |
| If-Unmodified-Since | Last-Modified | 마지막 수정 버전에서 변한 것이 없다면 사본을 줘라 |
|      If-Match       |     ETag      | 저번 엔티티 태그와 같다면 사본을 줘라             |
|    If-None-Match    |     ETag      | 저번 엔티티 태그와 다르다면 사본을 줘라           |

- HTTP는 검사기를 약한 검사기와 강한 검사기로 분류
  - 약한 검사기는 리소스 인스턴스를 uniquely identify하지 못하는 경우도 있음
  - 약한 검사기 예시 - 객체의 바이트 단위 크기
  - 강한 검사기 예시 - 리소스 컨텐츠에 대한 암호 체크섬(MD5)
- 최종 변경 시각 또한 정확도가 최대 1초에 불과하기 때문에 약한 검사기로 분류
- 반면 ETag는 매 변경마다 구분되는 값을 넣어줄 수 있으며, 버전 번호나 요약 체크섬 이외에 어떤 텍스트라도 포함할 수 있음
- 서버는 엔티티 태그 앞에 `W/`를 붙여서 '약한' 엔티티 태그임을 알릴 수도 있음
  - 크고 자주 찾는 캐시된 문서에 대해 대량 트래픽을 유발하지 않으면서도 겉모양새만 약간 고치고 싶을 때

```http
GET /announce.html HTTP/1.1
If-None-Match: W/"v4.0"
```

<br>

## 9. 범위 요청

- HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해줌
- 범위 요청을 하면 다운로드가 중단된 시점에서 다운로드를 재개할 수 있음

```http
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozila/4.61 [en] (WinNT; I)
```

- 위 예시에서 클라이언트는 처음 4,000 byte 이후 부분에 대해 요청하고 있음
  - 문서의 크기는 모르기 때문에 몇 byte까지 받을 지는 명시하지 않음
- 하나의 요청으로 여러 범위를 요청했을 때, 응답은 멀티파트 본문과<br>Content-Type: multipart/byteranges 헤더와 함께 하나의 엔티티로 반환
- 서버는 클라이언트에게 받아들일 수 있는 범위를 Accept-Range 헤더에 포함시켜서 알려줄 수 있음

```http
HTTP/1.1 200 OK
Date: Fri, 05 Nov 1999 22:35:15 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
```

- Range 헤더는 P2P로 파일 공유할 때도 많이 사용됨
- 범위 요청은 인스턴스 조작의 일종
  - 범위 요청이 오직 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있을 것

<img width="472" alt="엔티티 범위 요청" src="https://user-images.githubusercontent.com/75058239/208543971-22103189-8916-4d5c-a172-eda90028145d.png">
