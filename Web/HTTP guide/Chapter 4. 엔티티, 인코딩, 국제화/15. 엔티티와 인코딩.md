- HTTP는 매일 수십억 개의 미디어 객체를 실어 나름
- HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장함

※ HTTP가 보장하는 것들

- Content-Type과 Content-Language 헤더를 통해 객체를 올바르게 식별
- Content-Length와 Content-Encoding 헤더를 통해 객체는 올바르게 압축이 풀릴 것
- 엔티티 검사기와 캐시 만료 제어를 이용해서 객체는 항상 최신의 상태를 유지
- 내용 협상을 위한 Accept 관련 헤더들에 기반하여 사용자의 요구를 만족
- 데이터 압축을 이용해서 네트워크 사이를 빠르고 효율적으로 이동
- 전송 인코딩 헤더 및 Content-MD5 체크섬을 이용하기 때문에 조작되지 않을 것

<br>

- HTTP는 컨텐츠를 나르기 위해 잘 라벨링된 엔티티 사용
- 이 장에서는 엔티티 및 연관 헤더들이 웹상의 화물 수송을 위해 어떤 일을 하는지 논의할 것
  - HTTP가 어떻게 컨텐츠 크기, 타입, 인코딩에 대한 필수적인 값들을 제공하는지
  - HTTP 엔티티, range request, delta encoding, digest, chunked encoding 등 복잡하지만 강력한 기능들을 다룰 것

※ 이번 장에서 다룰 내용들

- HTTP 메시지를 담는 컨테이너인 HTTP 메시지 엔티티의 포맷과 작동 방식
- HTTP가 어떻게 엔티티 본문의 크기를 기술하는지
- 클라이언트가 컨텐츠를 바르게 처리할 수 있도록 제공되는 엔티티 헤더들
- 컨텐츠 인코딩
- 특정 종류의 컨텐츠 송수신 개선을 위한 전송 인코딩과 청크 인코딩
- 최신 버전을 전송할 수 있게 도와주는 태그, 라벨, 시간, 체크섬
- 버전 검사기와 최신 상태 유지를 돕는 HTTP 헤더 필드들
- 중단되었던 다운로드를 재개할 때 유용한 범위 요청
- 이미 본 페이지는 변경 부분만 재요청하게 해주는 HTTP 델타 인코딩 확장
- 프록시를 지나는 중 변경되지는 않았는지 검증하는 엔티티 본문 체크섬

<br>

## 1. 메시지는 컨테이너, 엔티티는 화물

※ HTTP/1.1의 12가지 주요 엔티티 헤더 필드

- **Content-Type** : 엔티티에 의해 전달된 객체 종류
- **Content-Length** : 전달되는 메시지의 길이나 크기
- **Content-Language** : 전달되는 객체와 가장 잘 대응되는 자연어
- **Content-Encoding** : 객체 데이터에 행해진 변형
- **Content-Location** : 요청 시점에 객체의 또 다른 위치
- **Content-Range** : 엔티티 전체에서 어느 부분에 해당하는지
- **Content-MD5** : 엔티티 본문의 컨텐츠에 대한 체크섬
- **Last-Modified** : 서버에서 컨텐츠가 생성되거나 수정된 날
- **Expires** : 엔티티 데이터의 신선도가 만료되는 날짜 및 시각
- **Allow** : 리소스에 대해 어떤 요청 메소드가 허용되는지
- **ETag** : 인스턴스에 대한 고유 검사기
- **Cache-Control** : 어떻게 문서가 캐시될 수 있는지에 대한 지시자

### 1.1 엔티티 본문

- 가공되지 않은 데이터만을 담고 있으며, 다른 정보들은 모두 헤더에 담겨 있음
  - 그렇기 때문에 엔티티 헤더는 날 데이터에 대해 설명할 필요가 있음
- 엔티티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작
  - 컨텐츠가 텍스트든, binary든, 이미지든, 압축되었든, 프랑스어든, 일본어든 상관없이 항상

<br>

## 2. Content-Length: 엔티티의 길이

- 엔티티 본문의 크기를 byte 단위로 나타냄
- 어떻게 인코딩되었든 상관없이 크기 표현 가능
- 청크 인코딩이 아닌 이상, 엔티티가 아예 없지 않은 이상, 필수적으로 있어야 함
- Content-Length는 메시지가 잘렸는지 검사할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할할 때 필요

### 2.1 잘림 검출

- Content-Length가 없으면 클라이언트는 커넥션이 정상적으로 종료된 것인지, 중간에 충돌이 있었는지 구분하지 못함
- 메시지 잘림은 캐싱 프록시 서버에서 특히 취약
  - 캐시가 잘린 메시지를 인식하지 못하면, 캐시는 결함 있는 컨텐츠를 계속해서 제공할 것
  - 이를 방지하기 위해 캐싱 프록시는 Content-Length가 명시적으로 있지 않으면 보통 본문을 캐싱하지 않음

### 2.2 잘못된 Content-Length

- 아예 없을 때보다 더 큰 피해를 유발할 수 있음
- 초창기 클라이언트 및 서버는 Content-Length 계산 관련 버그가 있으므로,<br>오늘날 몇몇 클라이언트, 서버, 프록시들은 이러한 오동작도 탐지하고 교정
- 공식적으호 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받았으며 이를 인지했을 경우, 사용자에게 알려주어야 함

### 2.3 Content-Length와 Persistent Connection

- Content-Length는 지속 커넥션을 위해 필수적
- 지속 커넥션 중에 클라이언트는 메시지 하나가 어디서 끝나고 다음 시작이 어디인지 명확히 알아야 함

### 2.4 컨텐츠 인코딩

- HTTP는 보안 강화 및 압축을 위해 엔티티 본문을 인코딩할 수 있음
- 컨텐츠가 인코딩되어 있는 경우 Content-Length는 인코딩 이후의 본문 길이를 byte 단위로 정의
- 역시 어떤 잘못된 HTTP 애플리케이션은 인코딩 전의 본문 길이를 보내기 때문에 주의해야 함

### 2.5 엔티티 본문 길이 판별을 위한 규칙

1. if (!msg.allow(body)) → Content-Length 헤더 무시
2. if (msg.contains(Transfer-Encoding))<br>커넥션이 닫혀서 트랜잭션이 끝나지 않는 이상, 엔티티는 '0 byte chunk'라 불리는 특별한 패턴으로 끝나야 함
3. if (msg.contains(Content-Length) && msg.allow(body) && !msg.contains(Transfer-Encoding))<br>Content-Length 값은 본문의 길이를 담음
4. if (msg.mediaType == 'multipart/byteranges' && !msg.contains(Content-Length))<br>멀티파트 메시지 각 부분은 각자가 스스로의 크기를 정할 수 있음<br>수신자가 이를 해석할 수 있다는 것을 알기 전에는 보내져서는 안됨
5. else → 엔티티는 커넥션이 닫힐 때 종료<br>실질적으로 서버만 메시지 종료를 알리기 위해 커넥션을 닫을 수 있음
6. HTTP/1.1 명세에서는 본문은 있지만 Content-Length가 없는 경우 400 Bad Request 혹은 411 Length Required 응답을 보내도록 조언함

<br>

## 3. 엔티티 요약

- HTTP는 TCP/IP 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 여러 이유로 전송 중 변형이 발생할 수 있음
- 변경 감지를 위해 송신자는 데이터에 대한 체크섬을 생성해서, 수신자가 엔티티의 변경을 검사할 수 있게 함
- Content-MD5 헤더: 서버가 엔티티 본문에 MD5 알고리듬을 적용한 결과를 전송
  - 오직 응답을 처음 만든 서버만이 이 헤더를 계산해서 보냄
  - 컨텐츠 인코딩이 적용되고 전송 인코딩이 적용되지 않은 엔티티 본문에 대한 MD5를 담음
  - 클라이언트는 전송 인코딩을 디코딩한 뒤에 MD5를 계산해야 함
  - 만약 gzip 알고리듬으로 압축하여 청크 인코딩으로 보낸다면, MD5 알고리듬은 압축된 본문 전체에 대해 수행
- MD5는 문서 위치를 빠르게 찾고 중복 저장을 방지하기 위한 해시 테이블의 키로도 사용 가능
- 하지만 이러한 활용 가치들에도 불구하고 그다지 자주 전송되지 않는 헤더
- HTTP 확장들은 IETF 초안으로 여러 요약 알고리듬들을 제안했음
  - 이에 따라, 클라이언트가 응답에 대해 기대하는 요약 유형을 정의할 수 있도록 새로운 헤더 Want-Digest가 제안되었음
  - Want-Digest는 quality value를 이용해서 여러 요약 알고리듬에 대한 선호도를 지정할 수 있음

<br>

## 4. 미디어 타입과 Charset

- Content-Type 헤더 필드는 엔티티 본문의 MIME 타입을 기술
- MIME 타입은 전달되는 데이터 매체의 기저 형식에 대한 표준화된 이름
  - HTML, MS Word, MPEG 등
- MIME 타입은 IANA(Internet Assigned Numbers Authority)에 등록되어 있음

※ 대표적인 MIME 타입들

|          미디어 타입          | 설명                              |
| :---------------------------: | :-------------------------------- |
|           text/html           | HTML 문서                         |
|          text/plain           | plain text 문서                   |
|           image/gif           | GIF 이미지                        |
|          image/jpeg           | JPEG 이미지                       |
|          audio/x-wav          | WAV 음향 데이터                   |
|          model/vrml           | 3차원 VRML 모델                   |
| application/vnd.ms-powerpoint | MS Powerpoint Presentation        |
|     multipart/byteranges      | 전체 문서의 특정 범위 (byte 단위) |
|         message/http          | 온전한 HTTP 메시지                |

### 4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type 헤더는 `charset`과 같이 컨텐츠 타입을 더 자세하게 지정하기 위한 선택적 매개변수 지원

```http
Content-Type: text/html; charset=iso-8859-4
```

### 4.2 멀티파트 미디어 타입

- 멀티파트 이메일 메시지의 경우 서로 붙어있는 여러 메시지를 포함
  - 하나의 복합 메시지로 전송됨
  - 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더 포함
  - 구성요소들은 문자열 하나로 서로의 경계 식별
- HTTP는 멀티파트 본문도 지원
  - 그러나 일반적으로 폼을 채워서 제출할 때나 일부분만 보내는 범위 응답을 할 때만 사용됨

### 4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출한 경우 가변 길이 텍스트 필드와 업로드될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어서 보내짐
- 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼 허용
- 이러한 요청을 Content-Type: multipart/form-data 혹은 Content-Type: multipart/mixed 헤더에 멀티파트 본문과 함께 보냄

```http
Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwxyz]
```

- `boundary`는 본문의 서로 다른 부분을 구분하기 위한 구분자

### 4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있음
- 그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

<br>

## 5. 컨텐츠 인코딩

- HTTP 애플리케이션은 때때로 컨텐츠 전송 전에 인코딩 수행
  - 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하는 경우
  - 해커가 볼 수 없도록 컨텐츠를 암호화하는 경우
- 인코딩은 발송하는 쪽에서 수행

### 5.1 컨텐츠 인코딩 과정

1. 웹 서버는 원본 Content-Type과 Content-Length 헤더를 수반한 응답 메시지 생성
2. 컨텐츠 인코딩 서버(원 서버 or 다운스트림 프록시)는 인코딩 메시지 생성<br>인코딩된 메시지는 Content-Type은 이전과 동일하지만 Content-Length가 달라짐<br>컨텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가
3. 수신 측 프로그램은 메시지를 디코딩하고 원본을 얻음

※ gzip 등으로 압축했을 때, 원본의 Content-Type을 따라야 하고, Content-Length는 또 gzip의 용량을 따라야 한다는 점에 유의!

### 5.2 컨텐츠 인코딩 유형

- HTTP는 몇 가지 표준 컨텐츠 인코딩 유형을 정의했으며, 확장 인코딩을 추가하는 것도 허용
- 인코딩은 각 컨텐츠 인코딩 알고리듬에 고유한 토큰을 할당해주는 IANA를 통해 표준화
- Content-Encoding 헤더는 표준화 토큰 값을 이용해서 인코딩에 사용된 알고리듬 기술

| 컨텐츠 인코딩 값 | 설명                                      |
| :--------------: | :---------------------------------------- |
|       gzip       | GNU zip 인코딩 적용                       |
|     compress     | 유닉스 파일 압축 프로그램 compress 실행됨 |
|     deflate      | zlib 포맷으로 압축됨                      |
|     identity     | 인코딩 없음 (default 값)                  |

- gzip, compress, deflate 인코딩은 무손실 압축 알고리듬
  - 특히 gzip이 가장 효율적이며 가장 널리 쓰임

### 5.3 Accept-Encoding 헤더

- 클라이언트가 지원하지 않는 인코딩 사용을 막기 위해, 클라이언트는 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달
  - 만약 이 헤더가 없으면 서버는 클라이언트가 어떠한 인코딩이든 다 받아들일 수 있는 것으로 간주 (Accept-Encoding: \*)

```http
Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
```

- 각 인코딩에 Q(quality) 값을 매개변수로 더해서 선호도를 나타낼 수 있음
- identity 인코딩 토큰은 오직 Accept-Encoding 헤더에만 존재할 수 있고, 클라이언트가 상대적 선호도를 나타낼 때 표현됨
