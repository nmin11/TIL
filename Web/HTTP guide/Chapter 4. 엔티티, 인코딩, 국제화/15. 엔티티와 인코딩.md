- HTTP는 매일 수십억 개의 미디어 객체를 실어 나름
- HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장함

※ HTTP가 보장하는 것들

- Content-Type과 Content-Language 헤더를 통해 객체를 올바르게 식별
- Content-Length와 Content-Encoding 헤더를 통해 객체는 올바르게 압축이 풀릴 것
- 엔티티 검사기와 캐시 만료 제어를 이용해서 객체는 항상 최신의 상태를 유지
- 내용 협상을 위한 Accept 관련 헤더들에 기반하여 사용자의 요구를 만족
- 데이터 압축을 이용해서 네트워크 사이를 빠르고 효율적으로 이동
- 전송 인코딩 헤더 및 Content-MD5 체크섬을 이용하기 때문에 조작되지 않을 것

<br>

- HTTP는 컨텐츠를 나르기 위해 잘 라벨링된 엔티티 사용
- 이 장에서는 엔티티 및 연관 헤더들이 웹상의 화물 수송을 위해 어떤 일을 하는지 논의할 것
  - HTTP가 어떻게 컨텐츠 크기, 타입, 인코딩에 대한 필수적인 값들을 제공하는지
  - HTTP 엔티티, range request, delta encoding, digest, chunked encoding 등 복잡하지만 강력한 기능들을 다룰 것

※ 이번 장에서 다룰 내용들

- HTTP 메시지를 담는 컨테이너인 HTTP 메시지 엔티티의 포맷과 작동 방식
- HTTP가 어떻게 엔티티 본문의 크기를 기술하는지
- 클라이언트가 컨텐츠를 바르게 처리할 수 있도록 제공되는 엔티티 헤더들
- 컨텐츠 인코딩
- 특정 종류의 컨텐츠 송수신 개선을 위한 전송 인코딩과 청크 인코딩
- 최신 버전을 전송할 수 있게 도와주는 태그, 라벨, 시간, 체크섬
- 버전 검사기와 최신 상태 유지를 돕는 HTTP 헤더 필드들
- 중단되었던 다운로드를 재개할 때 유용한 범위 요청
- 이미 본 페이지는 변경 부분만 재요청하게 해주는 HTTP 델타 인코딩 확장
- 프록시를 지나는 중 변경되지는 않았는지 검증하는 엔티티 본문 체크섬

<br>

## 1. 메시지는 컨테이너, 엔티티는 화물

※ HTTP/1.1의 12가지 주요 엔티티 헤더 필드

- **Content-Type** : 엔티티에 의해 전달된 객체 종류
- **Content-Length** : 전달되는 메시지의 길이나 크기
- **Content-Language** : 전달되는 객체와 가장 잘 대응되는 자연어
- **Content-Encoding** : 객체 데이터에 행해진 변형
- **Content-Location** : 요청 시점에 객체의 또 다른 위치
- **Content-Range** : 엔티티 전체에서 어느 부분에 해당하는지
- **Content-MD5** : 엔티티 본문의 컨텐츠에 대한 체크섬
- **Last-Modified** : 서버에서 컨텐츠가 생성되거나 수정된 날
- **Expires** : 엔티티 데이터의 신선도가 만료되는 날짜 및 시각
- **Allow** : 리소스에 대해 어떤 요청 메소드가 허용되는지
- **ETag** : 인스턴스에 대한 고유 검사기
- **Cache-Control** : 어떻게 문서가 캐시될 수 있는지에 대한 지시자

### 1.1 엔티티 본문

- 가공되지 않은 데이터만을 담고 있으며, 다른 정보들은 모두 헤더에 담겨 있음
  - 그렇기 때문에 엔티티 헤더는 날 데이터에 대해 설명할 필요가 있음
- 엔티티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작
  - 컨텐츠가 텍스트든, binary든, 이미지든, 압축되었든, 프랑스어든, 일본어든 상관없이 항상

<br>

## 2. Content-Length: 엔티티의 길이

- 엔티티 본문의 크기를 byte 단위로 나타냄
- 어떻게 인코딩되었든 상관없이 크기 표현 가능
- 청크 인코딩이 아닌 이상, 엔티티가 아예 없지 않은 이상, 필수적으로 있어야 함
- Content-Length는 메시지가 잘렸는지 검사할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할할 때 필요

### 2.1 잘림 검출

- Content-Length가 없으면 클라이언트는 커넥션이 정상적으로 종료된 것인지, 중간에 충돌이 있었는지 구분하지 못함
- 메시지 잘림은 캐싱 프록시 서버에서 특히 취약
  - 캐시가 잘린 메시지를 인식하지 못하면, 캐시는 결함 있는 컨텐츠를 계속해서 제공할 것
  - 이를 방지하기 위해 캐싱 프록시는 Content-Length가 명시적으로 있지 않으면 보통 본문을 캐싱하지 않음

### 2.2 잘못된 Content-Length

- 아예 없을 때보다 더 큰 피해를 유발할 수 있음
- 초창기 클라이언트 및 서버는 Content-Length 계산 관련 버그가 있으므로,<br>오늘날 몇몇 클라이언트, 서버, 프록시들은 이러한 오동작도 탐지하고 교정
- 공식적으호 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받았으며 이를 인지했을 경우, 사용자에게 알려주어야 함

### 2.3 Content-Length와 Persistent Connection

- Content-Length는 지속 커넥션을 위해 필수적
- 지속 커넥션 중에 클라이언트는 메시지 하나가 어디서 끝나고 다음 시작이 어디인지 명확히 알아야 함

### 2.4 컨텐츠 인코딩

- HTTP는 보안 강화 및 압축을 위해 엔티티 본문을 인코딩할 수 있음
- 컨텐츠가 인코딩되어 있는 경우 Content-Length는 인코딩 이후의 본문 길이를 byte 단위로 정의
- 역시 어떤 잘못된 HTTP 애플리케이션은 인코딩 전의 본문 길이를 보내기 때문에 주의해야 함

### 2.5 엔티티 본문 길이 판별을 위한 규칙

1. if (!msg.allow(body)) → Content-Length 헤더 무시
2. if (msg.contains(Transfer-Encoding))<br>커넥션이 닫혀서 트랜잭션이 끝나지 않는 이상, 엔티티는 '0 byte chunk'라 불리는 특별한 패턴으로 끝나야 함
3. if (msg.contains(Content-Length) && msg.allow(body) && !msg.contains(Transfer-Encoding))<br>Content-Length 값은 본문의 길이를 담음
4. if (msg.mediaType == 'multipart/byteranges' && !msg.contains(Content-Length))<br>멀티파트 메시지 각 부분은 각자가 스스로의 크기를 정할 수 있음<br>수신자가 이를 해석할 수 있다는 것을 알기 전에는 보내져서는 안됨
5. else → 엔티티는 커넥션이 닫힐 때 종료<br>실질적으로 서버만 메시지 종료를 알리기 위해 커넥션을 닫을 수 있음
6. HTTP/1.1 명세에서는 본문은 있지만 Content-Length가 없는 경우 400 Bad Request 혹은 411 Length Required 응답을 보내도록 조언함

<br>

## 3. 엔티티 요약

- HTTP는 TCP/IP 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 여러 이유로 전송 중 변형이 발생할 수 있음
- 변경 감지를 위해 송신자는 데이터에 대한 체크섬을 생성해서, 수신자가 엔티티의 변경을 검사할 수 있게 함
- Content-MD5 헤더: 서버가 엔티티 본문에 MD5 알고리듬을 적용한 결과를 전송
  - 오직 응답을 처음 만든 서버만이 이 헤더를 계산해서 보냄
  - 컨텐츠 인코딩이 적용되고 전송 인코딩이 적용되지 않은 엔티티 본문에 대한 MD5를 담음
  - 클라이언트는 전송 인코딩을 디코딩한 뒤에 MD5를 계산해야 함
  - 만약 gzip 알고리듬으로 압축하여 청크 인코딩으로 보낸다면, MD5 알고리듬은 압축된 본문 전체에 대해 수행
- MD5는 문서 위치를 빠르게 찾고 중복 저장을 방지하기 위한 해시 테이블의 키로도 사용 가능
- 하지만 이러한 활용 가치들에도 불구하고 그다지 자주 전송되지 않는 헤더
- HTTP 확장들은 IETF 초안으로 여러 요약 알고리듬들을 제안했음
  - 이에 따라, 클라이언트가 응답에 대해 기대하는 요약 유형을 정의할 수 있도록 새로운 헤더 Want-Digest가 제안되었음
  - Want-Digest는 quality value를 이용해서 여러 요약 알고리듬에 대한 선호도를 지정할 수 있음
