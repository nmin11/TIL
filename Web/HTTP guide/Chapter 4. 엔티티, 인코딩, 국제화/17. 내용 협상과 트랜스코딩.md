content-negotiation: 사용자가 원하는 언어로 제공하기 위한 클라이언트와 서버의 협상

- 하나의 URL이 여러 리소스 중 적합한 것에 대응되도록
- 서로 다른 버전을 variant라고 부름
- 트랜스코딩은 HTTP 클라이언트와 서버 사이의 내용 협상에 대한 응답에서 수행

<br>

## 1. 내용 협상 기법

- 클라이언트 주도
  - 작동 방식: 클라이언트가 요청을 보내면 서버는 클라이언트에게 선택지를 주고, 클라이언트가 선택
  - 장점: 서버 구현이 쉽고, 클라이언트는 최선의 선택을 할 수 있음
  - 단점: 올바른 컨텐츠를 얻기 위해 최소 2번의 요청이 필요하므로, 대기시간 증가
- 서버 주도
  - 작동 방식: 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정
  - 장점: 클라이언트 주도 협상보다 빠름, q값 매커니즘, 서버가 사용하는 목록을 나타내는 Vary 헤더
  - 단점: 요청 헤더에 맞는 것이 없다면 서버는 추측을 해야 함
- 투명
  - 작동 방식: 프록시 캐시 등의 투명한 중간 장치 서버를 통해 협상
  - 장점: 서버가 협상할 필요가 없으며, 클라이언트 주도 협상보다 빠름
  - 단점: 투명 협상에 대한 명세가 없음

<br>

## 2. 클라이언트 주도 협상

- 기술적으로, 서버가 선택지 목록을 표현하는 2가지 방법이 있음
  - 여러 버전에 대한 링크 및 설명이 담긴 HTML 페이지 반환
  - HTTP/1.1 300 Multiple Choices 응답 반환
- 또 하나의 단점은 특정 조건별 페이지들에 대해 여러 개의 URL이 추가적으로 필요하다는 점

<br>

## 3. 서버 주도 협상

- HTTP 서버가 클라이언트에게 보내줄 적절한 응답을 계산하기 위한 2가지 메커니즘
  - **내용 협상 헤더**들 탐색
    - Accept 관련 헤더들을 들여다보고 이에 알맞은 응답 헤더 준비
  - 내용 협상 헤더들 외 다른 헤더들 탐색
    - 예를 들어, 서버는 클라이언트의 User-Agent 헤더에 기반해서 응답을 보내줄 수도 있음

### 3.1 내용 협상 헤더

| 내용 협상 헤더  |   엔티티 헤더    | 설명                                             |
| :-------------: | :--------------: | :----------------------------------------------- |
|     Accept      |   Content-Type   | 서버가 어떤 미디어 타입으로 보내도 되는지 알려줌 |
| Accept-Language | Content-Language | 서버가 어떤 언어로 보내도 되는지 알려줌          |
| Accept-Charset  |   Content-Type   | 서버가 어떤 charset으로 보내도 되는지 알려줌     |
| Accept-Encoding | Content-Encoding | 서버가 어떤 인코딩으로 보내도 되는지 알려줌      |

- 15장의 엔티티 헤더들과 비슷하지만,
  - 엔티티 헤더는 선적 화물에 붙이는 라벨과 비슷, 필요한 메시지 본문의 속성을 가리킴
  - 내용 협상 헤더는 클라이언트의 선호에 가장 잘 맞는 문서를 제공하기 위한 목적으로 사용됨
- HTTP는 stateless이기 때문에 클라이언트는 자신의 선호 정보를 매 요청마다 보내야 함

### 3.2 내용 협상 헤더의 품질값

```http
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```

- 클라이언트는 각 선호의 카테고리마다 선호도를 매길 수 있는 품질값 사용 가능
- 서버가 클라이언트의 선호에 대응할 수 없는 경우, 문서를 고치거나 트랜스코딩할 수 있음 (뒷 내용)

### 3.3 그 외의 헤더들에 의해 결정

- 서버는 User-Agent 같은 다른 요청 헤더들을 이용해서 알맞은 요청을 만들어내려고 시도할 수 있음
- 캐시는 반드시 최선의 버전을 제공해야 하기 때문에 **Vary** 헤더 정의
  - 서버가 최선의 버전을 결정하기 위해 어떤 요청 헤더를 참고하는지 말해줌 (뒷 내용)

### 3.4 아파치의 내용 협상

- 웹 사이트 컨텐츠 제공자에게 달려있음
- 만약 색인 페이지를 여러 버전으로 제공하고자 한다면,<br>컨텐츠 제공자는 각 버전에 해당하는 파일들을 아파치 서버의 적절한 디렉토리에 모두 넣어주어야 함
- 그 다음 둘 중 한 가지 방법으로 내용 협상을 동작시킴
  - 웹 사이트 디렉토리에서, variant를 갖는 웹 사이트 각 URI를 위한 `type-map` 파일 작성
    - type-map: 모든 variant와 그들 각각에 대응하는 내용 협상 헤더들을 나열
  - 아파치가 디렉토리에 대해 자동으로 type-map 파일을 생성해주는 `MultiViews` 지시어 ON

**_type-map 파일 사용하기_**

```http
AddHandler type-map .var
```

- 서버 설정 파일에 type-map 파일들을 위한 파일 접미사를 명시한 핸들러를 추가해야 함
  - `.var` 확장자를 가진 파일들이 type-map 파일임을 의미

```http
URI: joes-hardware.html

URI: joes-hardware.en.html
Content-type: text/html
Content-language: en

URI: joes-hardware.fr.de.html
Content-type: text/html;charset=iso-8859-2
Content-language: fr,de
```

- 이 type-map 파일을 통해, 아파치 서버는 각 언어별로 요청된 파일들을 보내줌
- https://httpd.apache.org/docs/trunk/ko/content-negotiation.html

**_MultiViews 사용하기_**

- access.conf 파일 내에서 Option 지시어를 사용해서 웹 사이트를 포함한 디렉토리에 MultiViews를 켜면 됨
- MultiViews가 켜진 상태에서 리소스가 요청된 경우, 서버는 요청에 해당하는 모든 파일을 살펴보고 이들에 대한 type-map 작성

### 3.5 서버 측 확장

- 또 다른 방법으로, MS의 ASP(Active Server Page) 같은 서버 쪽 확장을 하는 방법도 있음

<br>

## 4. 투명 협상

- 클라이언트 입장에서 협상하는 중개자 프록시를 둠으로써,
  - 클라이언트와의 메시지 교환 최소화
  - 서버 주도 협상으로 인한 서버 부하 감소
- 프록시는 클라이언트의 기대가 무엇인지 알고 있고, 클라이언트의 입장에서 협상을 수행할 능력이 있는 것으로 가정됨
  - 프록시는 요청을 읽고서 클라이언트의 요구사항을 파악하고 있음
- 서버는 어떤 요청 헤더를 협상을 위해 검사해야 하는지 프록시에게 반드시 말해줄 수 있어야 함
  - HTTP/1.1 명세에 투명 협상에 대한 메커니즘 정의는 없지만 대신 `Vary` 헤더를 정의했음
  - Vary 헤더를 통해 서버는 중개자에게 내용 협상을 위해 어떤 헤더가 사용되는지를 알려줌
- 캐시 프록시는 단일 URL 문서에 대해 여러 다른 사본 저장 가능
  - 만약 서버가 의사결정 프로세스를 캐시에게 알려주었다면, 캐시는 서버의 입장에서 클라이언트와 협상 가능
  - 캐시는 또한 트랜스코딩하기에 훌륭한 장소
    - 캐시 안의 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 서버의 컨텐츠든 트랜스코딩할 수 있기 때문

### 4.1 캐시와 alternate

- 캐시는 올바른 캐시 문서 제공을 위해 서버의 의사결정 로직을 상당 부분 그대로 사용할 수 있어야 함

(이미지 첨부 - 캐시의 올바른 응답을 위한 내용 협상 헤더)

- 캐시가 같은 URL에 대해 여러 버전을 갖게 되었을 때, 이를 **variant** 혹은 **alternate** 라고 부름
- 따라서 내용 협상은 variant 중에서 요청에 가장 잘 맞는 것을 선택하는 과정이라고 보면 됨

### 4.2 Vary 헤더

```http
Vary: User-Agent, Cookie
```

HTTP Vary 응답 헤더: 서버가 문서를 선택하거나 커스텀 컨텐츠를 생성할 때 고려하는 클라이언트 요청 헤더 모두를 나열

- 캐시는 요청된 문서를 제공해주기 전에, 캐시되었던 응답 안에 Vary 헤더가 들어있는지 확인해야 함
  - Vary 헤더가 존재한다면, Vary 헤더가 명시하고 있는 헤더들은 새 요청과 캐시된 요청에서 그 값이 맞아야 함
- 투명 협상 구현을 위해 캐시는 반드시 캐시된 variant와 함께 클라이언트 요청 헤더와 서버 응답 헤더 양쪽 모두를 저장해야 함
- 캐시는 각 variant마다 알맞은 문서 버전을 저장해야 함
- 캐시는 먼저 내용 협상 헤더로 적합한 컨텐츠를 맞춰보고, 맞는 variant가 없으면 문서를 서버로부터 가져와야 함

<br>

## 5. 트랜스코딩

서버가 클라이언트의 요구에 맞는 문서를 아예 가지고 있지 않다면?

- 이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수 있음

  - HTML 문서 → WML 문서
  - 고해상도 이미지 → 저해상도 이미지
  - 64K색 이미지 → 흑백 이미지
  - 프레임을 포함한 복잡한 페이지 → 단순 텍스트 페이지
  - 자바 애플릿이 있는 HTML 페이지 → 자바 애플릿이 없는 페이지
  - 광고가 있는 페이지 → 광고가 없는 페이지

- 트랜스코딩에는 포맷 변환, 정보 합성, 내용 주입 3가지 종류가 있음

### 5.1 포맷 변환

- 클라이언트가 데이터를 볼 수 있도록 다른 포맷으로 변환하는 것
- WAP 모바일 단말기가 데스크탑 클라이언트 전용 문서에 접근할 때는 HTML을 WML로 변환해줄 필요가 있음
- 포맷 변환은 내용 협상 헤더에 의해 주도됨
  - User-Agent 헤더에 의해서 주도될 수도 있음
- 내용 변환 혹은 트랜스코딩은 컨텐츠 인코딩, 전송 인코딩과는 다르다는 점에 유의
  - 전자는 컨텐츠를 특정 접근 장치에서 볼 수 있게 함
  - 후자는 컨텐츠의 효율적이고 안전한 전송을 위한 것

### 5.2 정보 합성

- 문서에서 정보의 요점을 추출하는 것
- 각 절의 제목에 기반한 문서 개요 생성이나, 광고 및 로고 제거 로직
- 포털 사이트의 웹페이지 디렉토리 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용됨

### 5.3 컨텐츠 주입

- 반대로 웹 문서의 양을 오히려 늘리는 변환
- 자동 광고 생성과 사용자 추적 시스템 등

### 5.4 트랜스코딩 vs 정적으로 미리 생성해놓기

- 트랜스코딩의 대안은 웹 서버에서 웹 페이지의 여러 사본을 만들어두는 것
  - 이는 사실 여러 가지 이유로 그다지 현실적이지 못함
  - 작은 변화에도 여러 페이지를 수정해야 함
  - 각 페이지의 모든 정보를 저장하기 위해 더 많은 공간 필요
  - 광고 삽입도 사용자에 맞춰서 광고를 넣을 수 없게 되어버림
- 트랜스코딩이 더욱 쉬운 해결책
  - 대기시간이 증가할 수는 있음
  - 하지만 이또한 프록시나 캐시 등 제 3자에게 수행하게 해서 서버의 부담을 줄일 수 있음
