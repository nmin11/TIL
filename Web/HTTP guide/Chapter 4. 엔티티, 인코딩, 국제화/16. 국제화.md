※ 16장 국제화에서 배우게 될 내용들

- HTTP는 여러 언어와 문자로 된 국제 문서들의 처리 및 전송 지원
- 2가지 주요 국제화(Internationalization) 이슈
  - 문자집합 인코딩: 여러 언어의 문자 텍스트를 요청하고 보여주기 위해 사용
  - 언어 태그: 사용자가 이해할 수 있는 언어로 컨텐츠를 서술하기 위해 사용
  - \+ 여러 언어로 된 URI 및 날짜에 대해서도 다룰 것

<br>

## 1. 국제적인 컨텐츠를 다루기 위해 필요한 HTTP 지원

- HTTP에서 엔티티 본문이란 그저 bit들로 가득 찬 상자에 불과
  - 그렇기 때문에 어떤 언어로 된 컨텐츠, 이미지, 동영상 등을 미디어처럼 실어 나를 수 있는 것
- 국제 컨텐츠 지원을 위해,
  - 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘야 함
  - 클라이언트는 문서를 이루고 있는 bit들을 문자들로 풀어내고, 올바르게 처리해서 사용자에게 컨텐츠를 제공해줘야 함
- 서버가 문서의 문자와 언어를 알려주는 방법 :
  - Content-Type 헤더의 `charset` 메게변수와, Content-Language 헤더 활용
  - 이 헤더들의 역할 :
    - _엔티티 본문의 'bit들로 가득 찬 상자'에 무엇이 들어있는지_
    - 어떻게 컨텐츠를 화면에 출력할 올바른 글자들로 바꿀 수 있는지
    - 텍스트가 어떤 언어에 해당하는지
- 클라이언트는 본인이 어떤 언어를 이해할 수 있고, 어떤 Charset 인코딩 알고리듬이 브라우저에 설치되어 있는지 말해줄 필요가 있음
  - Accept-Charset 헤더와 Accept-Language 헤더 활용

```http
Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
```

<br>

## 2. 문자집합과 HTTP

국제 알파벳 스크립트, 문자집합 인코딩 → 웹 국제화에서 가장 중요하고 가장 헷갈리는 부분!

### 2.1 Charset은 글자를 bit로 변환하는 인코딩이다

- HTTP Charset = 어떻게 엔티티 컨텐츠의 bit들을 특정 문자 체계의 글자들로 바꾸는지 말해줌
- 각 charset 태그 = bit들을 글자로 변환하거나, 혹은 그 반대 작업을 하기 위한 알고리듬 명명
  - MIME 문자집합에 표준화되어 있고, IANA가 관리

![iso-8859-6 디코딩](https://user-images.githubusercontent.com/75058239/209419101-2c4ebf83-e882-488d-84f1-8c10885f1f20.png)

- 8bit로 256개의 유일한 값을 제공할 수 있음
  - 그러나 UTF-8이나 iso-2022-jp 같은 몇몇 문자 인코딩은 글자 당 bit 수가 일정하지 않음
    - 이런 경우 추가적인 bit를 사용할 수 있게 지원

### 2.2 문자집합과 인코딩은 어떻게 동작하는가

![bit를 문자로 변환하는 과정](https://user-images.githubusercontent.com/75058239/209419113-32b96973-212e-459b-9510-804bde36d671.png)

- **국제화된 문자 시스템의 핵심 목표: 시각적 표현 방식과 글자들의 의미를 분리하는 것!**
  - HTTP는 문자 데이터 및 관련 언어와, charset 라벨 전송에만 관심을 둠
  - 글자의 모양을 어떻게 표현할지는 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정

### 2.3 잘못된 Charset은 잘못된 글자들을 낳는다

- 잘못된 charset 매개변수를 사용하면 클라이언트는 깨진 글자를 보여주게 됨
- charset 값이 225(이진수 11100001)일 때 문자 코드별 인코딩 방식
  - iso-8859-1 서유럽 문자코드 (a): á
  - iso-8859-6 아랍 코드 (FEH): ف
  - iso-8859-7 그리스어 코드 (Alpha): α
  - iso-8859-8 히브리어 코드 (BET): ב

### 2.4 표준화된 MIME Charset 값

MIME Charset: 특정 문자 인코딩과 특정 코딩된 문자집합의 결합

- HTTP는 표준화된 MIME Charset 태그를 Content-Type과 Accept-Charset 헤더에 사용
- MIME Charset 값은 IANA에 등록되어 있음

※ 몇몇 MIME Charset 인코딩 구조들

us-ascii

- 'American Standard Code for Information Interchange'
- 1968년에 ANSI_X3.4-1968로 표준화된 유명한 문자 인코딩
- ASCII라고도 불리지만, 여러 국제 변형이 있었기 때문에 'US'라는 접두어 붙이기를 선호
- 7 bit 값을 128가지 글자에 대응시킴
  - 1 byte(8 bit)에서 나머지 1 bit는 Parity Bit으로서, 통신 에러를 검출하기 위한 용도로 사용됨
- high bit는 사용되지 않음

iso-8859-1

- 서유럽 언어를 지원하기 위한 ASCII의 8 bit 확장
- 0-127 부분에 ASCII 코드를 온전히 유지한 채로 여러 서유럽 글자들을 포함
- iso-latin-1로도 불리며, 'Latin1'이라는 별명도 있음

iso-8859-2

- 체코어, 폴란드어, 루마니아어 같은 중부유럽 혹은 동유럽 언어에서 사용되는 문자들을 포함하기 위해 ASCII를 확장
- iso-latin-2라고도 불림

iso-8859-5

- 러시아어, 세르비아어, 불가리아어 등에 사용되는 키릴 문자를 포함하기 위해 ASCII를 확장

iso-8859-6

- 아랍 문자들을 포함하기 위해 ASCII를 확장
- 글자들의 모양이 단어 내에서의 위치와 연관되기 때문에 이에 따른 디스플레이 엔진도 필요

iso-8859-7

- 현대 그리스 문자를 포함하기 위해 ASCII를 확장
- 이전에는 ELOT-928이나 ECMA-118:1986으로 알려져 있었음

iso-8859-8

- 히브리어와 이디시어 문자들을 포함하기 위해 ASCII 확장

iso-8859-15

- iso-8859-1에서 잘 안 쓰이는 구두점 및 분수 기호들을 빼고, 고대 프랑스어와 핀란드어 글자들을 넣었음
- 국제 통화 기호를 유로 통화 기호로 대체하기 위해 갱신한 것
- 이 문자집합에는 'Latin0'이라는 별명이 있음

iso-2022-jp

- 일본어 전자우편 및 웹 컨텐츠를 위해 널리 사용되는 인코딩
- ASCII 문자들을 지원하는 1 byte로 된 가변길이 인코딩 구조이지만,<br>3가지의 일본어 문자집합으로 전환하기 위해 3글자로 된 modal escape sequence 사용

euc-jp

- ISO 2022 호환 가변길이 인코딩
  - 여러 종류의 모드나 escape 문자열 없이 각 글자를 식별하기 위해 명시적 bit 패턴 사용
- 일본어 문자집합에서 글자 식별을 위해 1byte, 2byte, 3byte 문자열 사용

Shift-JIS

- MS에 의해 개발되었고, 때떄로 SJIS나 MS Kanji라고도 불림
- 역사적인 호환성 문제 때문에 약간 복잡하며 모든 문자에 대응하지도 못하지만 여전히 흔하게 쓰이고 있음

koi8-r

- IETF RFC 1489로 정의된, 러시아어를 위한 인기 있는 8 bit 인터넷 문자집합 인코딩
- 'Code for Information Exchange, 8 bit, Russian'

utf-8

- 전 세계의 문자들에 대해 보편적 문자집합 UCS를 표현하기 위해 흔하게 사용되는 가변길이 문자 인코딩 구조
- 각 글자를 1 ~ 6 byte로 표현하는 가변길이 인코딩을 문자 코드 값에 사용
- 주요 기능 중 하나는 통상적인 7 bit ASCII 문자열에 대한 하위호환성

windows-1252

- 윈도우 코드 페이지 1252
  - MS는 자신들의 코딩된 문자집합을 '코드 페이지'라고 부름
- CP1252 혹은 WinLatin1이라고도 불림
- iso-8859-1의 확장

### 2.5 Content-Type charset 헤더와 META 태그

```http
Content-Type: text/html; charset=iso-2022-jp
```

- 서버는 클라이언트에게 MIME charset 태그를 `charset` 매개변수와 함께 Content-Type 헤더에 담아서 보냄
- 만약 문자집합이 명시되어 있지 않은 경우, 수신자는 컨텐츠로부터 문자집합 추측을 시도
  - HTML 컨텐츠에서는 `<meta http-equiv="Content-Type">` 태그에서 찾을 수 있음

```html
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp" />
  <meta lang="jp" />
  <title>A Japanese Document</title>
</head>
```

- 만약 그래도 클라이언트가 문자 인코딩을 추측할 수 없다면, iso-8859-1인 것으로 가정

### 2.6 Accept-Charset 헤더

- 세상에는 수십 년간 개발되어 온 수천 가지 문자 인코딩 및 디코딩 방법이 있고, 클라이언트가 이 모든 걸 알 수는 없음
- HTTP 클라이언트는 어떤 문자 체계를 지원할 수 있는지를 **Accept-Charset** 요청 헤더를 통해 알려줌
  - 헤더의 값: 클라이언트가 지원하는 문자 인코딩 목록

```http
Accept-Charset: iso-8859-1, utf-8
```

- Accept-Charset 요청 헤더에 대응하는 Content-Charset 응답 헤더는 존재하지 않음
- 응답 문자집합은 MIME와의 호환을 위해 Content-Type 응답 헤더의 `charset` 매개변수를 통해 전달
  - 아쉽게도 대칭적인 구조는 아니지만, 필요한 건 다 받는 셈

<br>

## 3. 다중언어와 문자 인코딩에 대한 지침

문자 체계와 표준에 대한 개관

### 3.1 문자집합 용어

**문자**

- 알파벳, 글자, 숫자, 구두점, 표의문자(중국어 같은), 기호 등 글쓰기의 최소 단위
- UCS(Universal Character Set) 계획에 따라<br>여러 언어의 여러 글자에 알맞는 유일한 이름을 부여하기 위해 표준화된 이름 집합이 개발되어 왔음
  - 약식으로 Unicode라고도 불림
  - 'LATIN CAPITAL LETTER S'나 'ARABIC LETTER QAF' 같은 고유 이름들을 정의

**glyph**

- 하나의 글자를 표현하기 위한, 획 패턴 등과 구분되는 유일한 시각적 형태
- 하나의 글자를 여러 방식으로 쓸 수 있다면, glyph를 여러 개 가질 수도 있음

**coded character**

- 각 글자에 할당된 유일한 숫자 값

**coding space**

- 문자 코드 값으로 사용하기 위해 계획해 둔 정수의 범위

**code width**

- 각 문자 코드의 고정된 크기의 bit 개수

**character repertoire**

- 작업하고자 하는 특정 문자 집합
- 세상에 존재하는 모든 글자에 대한 부분집합

**coded character set**

- character repertoire를 받아서 각 글자 coding space에 코드를 할당해준 코딩된 문자들의 집합
- 쉽게 말해서, 실제 글자들에 숫자로 된 문자 코드를 대응시킨 것

**문자 인코딩 구조**

- 숫자로 된 문자 코드들을 bit의 연속으로 인코딩하고 디코딩할 수 있는 알고리듬
- 글자 식별을 위해 데이터를 압축하거나, 전송상의 제약을 회피하거나, 중복된 coded character set을 통합하는데 사용될 수 있음

### 3.2 'Charset'은 형편없는 이름이다

- 엄밀히 말해, MIME charset 태그는 문자집합을 의미하는 것이 결코 아님
  - 데이터 bit를 고유한 문자의 코드로 매핑하는 알고리듬
  - 문자 인코딩 구조와 coded character set의 개념을 합친 것
- RFC 2616에서 HTTP/1.1의 저자들이 용어를 잘못 사용하면서 표준이 되어버렸음
  - IETF는 RFC 2277에서 이 비표준 용어를 받아들였음

### 3.3 문자

- 쓰기의 기본적 구성요소
- 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자(중국어 같은), 수학 기호 등을 표현
- 글꼴 및 스타일에 독립적

### 3.4 glyphs, ligatures, 표현 형태

- glyph: 각 글자를 그리는 특정한 방법
  - 각 문자는 미적인 양식과 스크립트에 따라 여러 glyph를 가짐

![glyph of an a](https://user-images.githubusercontent.com/75058239/209419128-16aee41c-5777-4a9e-8241-a4b2c10b1807.png)

- ligature: 필기체와 활자체가 인접한 글자들을 부드럽게 이어주는 것

![Ligatures](https://user-images.githubusercontent.com/75058239/209419132-88098917-56d5-438d-9147-258b1514b584.png)

### 3.5 Coded Character Set

![iso-8859-1 coded character set](https://user-images.githubusercontent.com/75058239/209419137-38b430c0-77a6-4986-8d57-46dc826a3b94.jpg)

- RFC 2277과 2130에서 정의된 **Coded Character Set**은 정수를 글자로 대응시킴
- Coded Character Set은 보통 코드 번호로 인덱싱된 배열로 구현됨
  - 다차원 배열인 경우 코드 번호를 이루는 bit의 덩어리들이 각 축에 대한 색인이 됨
- 역사적으로 중요한 몇 가지 주요 Coded Character Set 표준을 살펴볼 것

**_US-ASCII: 모든 문자집합의 어머니_**

- 1968년 ANSI 표준 X3.4 'American Standard Code for Information Interchange'(정보 교환을 위한 미국 표준 코드)
- code width 전체를 표현하는데 7 bit만을 사용
- 이 문자집합의 다른 국제 변종과 구분짓기 위해, 'US-ASCII'라는 이름이 더 선호됨
- HTTP 메시지는 US-ASCII 사용

**_iso-8859_**

- 국제적인 글쓰기를 위해 필요한 글자들을 high bit를 이용해서 추가한, US-ASCII의 8 bit 확대집합
- 모든 유럽 글자(아시아 글자는 말할 것도 없고)를 담기에는 충분히 크지 않으므로 지역에 따라 커스터마이징 제공
  - iso-8859-1: 서유럽어(영어, 프랑스어)
  - iso-8859-2: 중앙 및 동유럽어(체코어, 폴란드어)
  - iso-8859-3: 남유럽어
  - iso-8859-4: 북유럽어
  - iso-8859-5: 키릴(불가리아어, 러시아어, 세르비아어)
  - iso-8859-6: 아랍어
  - iso-8859-7: 그리스어
  - iso-8859-8: 히브리어
  - iso-8859-9: 터키어
  - iso-8859-10: 노르딕어(아이슬랜드어, 이뉴잇어)
  - iso-8859-15: 새로운 유로 통화 문자를 포함하기 위한 iso-8859-1의 변형
- Latin1로도 알려진 iso-8859-1은 HTML을 위한 기본 문자집합
  - 대부분의 유럽어 텍스트를 표현하기 위해 사용될 수 있음
  - iso-8859-15를 기본 문자집합으로 정하자는 논의가 있었지만, 이미 iso-8859-1이 널리 받아들여져 있으므로 기각
    - 요즘에도 바꾸면 다들 UTF-8로 바꾸기 때문에 iso-8859-15는 더더욱 사용되지 않고 있음

**_JIS X 0201_**

- ASCII에 일본어 가타카나 반각문자를 확장한 문자집합
- 가타카나 반각문자는 본래 일본의 전신 체계에서 쓰이던 것
- 'JIS Roman'으로도 불림
- JIS는 'Japanese Industrial Standard'의 줄임말

**_JIS X 0208, JIS X 0212_**

- 일본어는 여러 문자 체계로부터 온 수천 개의 글자를 담고 있음
  - JIS X 0201의 63개 표음 가타카나 문자로 고통스럽게나마 사용이 가능하긴 하지만,<br>실질적인 사용을 위해서는 완전한 문자집합이 필요
- JIS X 0208: 최초의 multi byte 일본어 문자집합
  - 대부분이 일본식 한자로 되어 있는 6,879개의 코딩된 문자 정의
- JIS X 0212: JIS X 0208에 6,607개의 문자 추가

**_UCS_**

- UCS(Universal Character Set)는 전 세계 모든 글자를 하나의 Coded Character Set으로 통합하고자 노력하는 세계적 표준
- ISO 10646으로 정의됨
- **Unicode**는 UCS 표준을 따르는 상업적 컨소시엄
- UCS 기본 집합은 단 50,000 글자만으로 이루어져 있지만 수백만 개의 글자를 위한 coding space를 갖고 있음

### 3.6 문자 인코딩 구조

- 숫자로 된 문자 코드를 컨텐츠 bit들로 변환하는 디코딩을 하거나, 다시 문자 코드로 인코딩하는 구조

※ 문자 인코딩의 종류들

**고정폭**

- 고정폭 인코딩은 각 코딩된 문자를 고정된 길이의 bit로 표현
- 빠르게 처리 가능하지만 공간 낭비의 우려가 있음

**가변폭(non-modal)**

- 가변폭 인코딩은 다른 문자 코드 번호에 다른 길이의 bit 사용
- 자주 사용하는 글자의 bit 길이를 줄일 수 있고,<br>국제 문자에 대해 여러 byte를 사용하게 해서 8 bit 문자집합과의 호환성도 유지 가능

**가변폭(modal)**

- 모달 인코딩은 서로 다른 모드로의 전환을 위해 특별한 'escape' 패턴 사용
- 처리하기에 복잡하지만, 복잡한 표기 체계를 효과적으로 지원해줄 수 있음

※ 대표적인 인코딩 구조들

**8 bit**

- 고정폭 인코딩 방식으로, 각 문자 코드를 그에 대응하는 8 bit 값으로 인코딩
- 256개 문자의 코드 범위에 대한 문자집합만을 지원
- iso-8859 시리즈가 대표적

**UTF-8**

UCS Transformation Format

- UCS를 위해 설계된 문자 인코딩 구조
- 문자 코드의 값을 위해 non-modal 가변길이 인코딩 사용
- 규칙
  - 첫번째 byte의 앞쪽 bit들은 인코딩된 문자의 길이를 byte 단위로 나타냄
  - 그 이후 byte들은 각각 6 bit의 코드 값을 담음

| 문자 코드 bit | 첫 byte  | 둘째 byte | 셋째 byte | 넷째 byte | 다섯째 byte | 여섯째 byte |
| :-----------: | :------: | :-------: | :-------: | :-------: | :---------: | :---------: |
|      0-7      | 0xxxxxxx |           |           |           |             |             |
|     8-11      | 110xxxxx | 10xxxxxx  |           |           |             |             |
|     12-16     | 1110xxxx | 10xxxxxx  | 10xxxxxx  |           |             |             |
|     17-21     | 11110xxx | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |             |             |
|     22-26     | 111110xx | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |  10xxxxxx   |             |
|     27-31     | 1111110x | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |  10xxxxxx   |  10xxxxxx   |

- 만약 첫 번째 인코딩된 byte의 (가장 앞쪽에 있는)high bit가 0이라면, 길이는 1byte
  - 이 덕에 ASCII와의 호환성을 완벽하게 확보함
  - 하지만 iso-8859 시리즈와는 호환이 안됨 (그들은 8bit를 써야 하기 때문에)
- 예시
  - 문자 코드 90(ASCII 'Z') → 01011010
  - 문자 코드 5073 → 11100001 10001111 10010001

**iso-2022-jp**

- 일본어 인터넷 문서를 위해 널리 사용되는 인코딩
- 8 bit 문자를 지원하지 않는 소프트웨어와의 문제를 방지하기 위해 128보다 작은 값으로 이루어진 가변길이 모달 인코딩
- encoding context는 4가지의 미리 정의된 문자집합 중 하나로 설정됨
  - iso-2022-jp 인코딩은 이 4가지의 문자집합에 강하게 결합되어 있으며,<br>이는 다른 인코딩들이 특정 문자집합에 대해 독립적이라는 점과 대조됨
  - 특별한 3 byte의 'escape 문자열'은 집합 간의 전환을 할 수 있게 해줌
  - US-ASCII, JIS-Roman, JIS X 0208-1978, JIS X 0208-1983 간의 전환 가능

| escape 문자열 | 전환 후 문자집합 | 코드당 byte 수 |
| :-----------: | :--------------: | :------------: |
|    ESC ( B    |     US-ASCII     |       1        |
|    ESC ( J    |    JIS-Roman     |       1        |
|    ESC $ @    | JIS X 0208-1978  |       2        |
|    ESC $ B    | JIS X 0208-1983  |       2        |

- 일본어 텍스트는 escape 문자열과 함께 끝나야 함
- JIS X 0208 문자집합을 사용할 때 각 byte의범위는 33 ~ 126으로 제한됨

**euc-jp**

- 또 하나의 인기 있는 일본어 인코딩
- EUC: Extended Unix Code
- iso-2022-jp와 비슷하게, 여러 표준 일본어 문자집합을 사용할 수 있게 해주는 가변길이 인코딩
  - 대신 _non-modal_
  - escape 문자열이 존재하지 않음
- 반각 가타카나, JIS X 0201, JIS X 0208, JIS X 0212 총 4가지의 Coded Character Set 지원
  - 1 byte 사용: JIS Roman
  - 2 byte 사용: 반각 가타카나, JIS X 0208
  - 3 byte 사용: JIS X 0212
- 이 코딩은 다소 공간을 낭비하긴 하지만 처리가 단순

**euc-kr**

- 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩
- KS X 1003, KS X 1001 2가지 문자집합 지원
  - KS X 1003: 1 byte로 인코딩되는 로마자 문자 집합
    - 사실상 US-ASCII에서 `\`를 `₩`로 치환하기만 한 것
  - KS X 1001: 2 byte로 인코딩되는 한글, 한자, 특수문자 등으로 이루어진 한국어 문자집합
- KS X 1001이 담고 있는 한글 총 2,350자는 턱없이 부족한 숫자
  - 그래서 한글 채움 문자(fill code, 0xA4 0xD4)를 사용해서 한글을 표현하는 방식 규정
    - 한글 문자 한 개를 '(채움) 초성 중성 종성'으로 표현
    - 예시) '똠' → '(채움) ㄸ ㅗ ㅁ'

<br>

## 4. 언어 태그와 HTTP

- 언어 태그: 언어에 이름을 붙이기 위한 짧고 표준화된 문자열
- 언어 태그 예시
  - en: 영어
  - de: 독일어
  - ko: 한국어
  - pt-BR: 브라질 포르투갈어
  - en-US: 미국 영어
  - zh-xiang: 허난 중국어
  - i-klingon: 스타 트랙의 외계 종족인 클링온의 언어

### 4.1 Content-Language 헤더

```http
Content-Language: fr
```

- 엔티티가 어떤 언어 사용자를 대상으로 하고 있는지 서술
- 텍스트 문서 뿐만 아니라 오디오, 동영상, 애플리케이션 등 어떤 종류의 미디어라도 가질 수 있는 헤더
- 헤더 필드에 여러 언어를 나열할 수 있음

### 4.2 Accept-Language 헤더

```http
Accept-Language: es
```

- HTTP는 우리가 언어 제약 및 언어 선호도를 서버에 전달할 수 있게 해줌
- Accept-Language와 Accept-Charset 헤더를 통해 요청할 수 있는데, 이는 17장에서 다뤄볼 것

### 4.3 언어 태그의 종류

- 언어 태그는 RFC 3066 "Tags for the Identification of Languages"로 문서화된 표준 문접을 가짐
- 언어 태그가 표현할 수 있는 것들
  - 일반적 언어 종류
    - es: 스페인어
  - 특정 국가 언어
    - en-GB: 영국 영어
  - 방언
    - no-bok: 노르웨이의 Book Language
  - 지방어
    - sgn-US-MA: 마서스 비니어드 섬의 수화
  - 다른 언어의 변형이 아닌 표준 언어
    - i-navajo: 아메리카 원주민 나바호 족 언어
  - 비표준 언어
    - x-snowboarder-slang: 스노우보더들이 사용하는 은어

### 4.4 서브태그

- 언어 태그는 `-`로 분리된 하나 이상의 서브태그로 이루어짐
- 첫 번째 서브태그: 주 서브태그, 표준화되어 있음
- 두 번째 서브태그: optional, 자신만의 표준을 따름
- 세 번째부터의 서브태그: 등록되어 있지 않음
- 주 서브태그는 오직 A부터 Z까지의 글자만 포함
- 다음 서브태그는 알파벳이나 숫자 포함 가능, 최대 8자까지
- 예시: `sgn-US-MA`
  - sgn: 주 서브태그 (수화)
  - US: 두 번째 서브태그 (미국)
  - MA: 세 번째 서브태그 (메사추세츠 지역 변종)

### 4.5 대소문자의 구분 및 표현

- 모든 태그는 대소문자 구분 X
- 그러나 관용적으로 언어를 나타낼 때는 소문자, 국가를 나타낼 때는 대문자 사용
- ISO 3166은 이 관례를 따르도록 권장

### 4.6 IANA 언어 태그 등록

- 첫 번째 서브태그와 두 번째 서브태그는 표준 문서를 관리하는 조직에 의해 정의
- IANA는 RFC 3066의 규칙에 따라 표준 언어 태그 목록을 관리
  - 오직 표준 국가와 언어 값으로 구성될 수 없는 언어 태그들만 IANA에 의해 등록될 필요가 있음

### 4.7 첫 번째 서브태그

- 보통은 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰
- 그러나 IANA에서 등록된 이름을 의미하는 글자 `i`일 수 있고, 확장 이름을 의미하는 `x`일 수도 있음
- 규칙
  - 2글자: ISO 639, 639-1 표준 언어 코드
  - 3글자: ISO 639-2 표준과 확장에 열거된 언어 코드
  - i: IANA에 등록된 것
  - x: 특정 개인이나 집단 전용 비표준 확장 서브태그

※ ISO 639, 639-2 예시

|     언어      | ISO 639 | ISO 639-2 |
| :-----------: | :-----: | :-------: |
|    아랍어     |   ar    |    ara    |
|    중국어     |   zh    |  chi/zho  |
|  네덜란드어   |   nl    |  dut/nla  |
|     영어      |   en    |    eng    |
|   프랑스어    |   fr    |  fra/fre  |
|    독일어     |   de    |  deu/ger  |
| 현대 그리스어 |   el    |  ell/gre  |
|   히브리어    |   he    |    heb    |
|  이탈리아어   |   it    |    ita    |
|    일본어     |   ja    |    jpn    |
|    한국어     |   ko    |    kor    |
|  노르웨이어   |   no    |    nor    |
|   러시아어    |   ru    |    ru     |
|   스페인어    |   es    |  esl/spa  |
|   스웨덴어    |   sv    |  sve/swe  |
|    터키어     |   tr    |    tur    |

### 4.8 두 번째 서브태그

- 보통은 ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 토큰
- IANA에 등록된 다른 문자열일 수 있음
- 규칙
  - 2글자: ISO 3166에 정의된 국가/지역
  - 3~8글자: IANA에 등록된 것
  - 1글자: 뭔가 잘못된 것

※ ISO 3166 국가 코드

|        국가         | 코드 |
| :-----------------: | :--: |
| 교황청(바티칸 시국) |  VA  |
|        독일         |  DE  |
|     러시아 연방     |  RU  |
|       레바논        |  LB  |
|       멕시코        |  MX  |
|        미국         |  US  |
|       브라질        |  BR  |
|        영국         |  GB  |
|      이탈리아       |  IT  |
|        인도         |  IN  |
|        일본         |  JP  |
|        중국         |  CN  |
|       캐나다        |  CA  |
|      파키스탄       |  PK  |
|       프랑스        |  FR  |
|        홍콩         |  HK  |

### 4.9 나머지 서브태그

- 8자 이하의 알파벳과 숫자로 이루어져야 한다는 것을 제외하고 다른 규칙은 없

<br>

## 5. 국제화된 URI

- 오늘날 URI는 국제화를 그다지 지원하지 않음
- RFC 3986에 따라 UTF-8 문자를 사용하는 추세

### 5.1 국제적 가독성 vs 의미 있는 문자들

- URI 설계자들이 원하는 2가지
  - 전 세계 모두가 이메일, 전화, 광고판, 라디오를 통해 공유할 수 있기를
  - 사용하고 쉽고 기억하기 쉽기를
  - 이 2가지는 서로 충돌!
- URI 저자들은 리소스 식별자의 가독성 및 공유 가능성 보장이, 모든 언어를 포함하는 것보다 더 중요하다고 생각했음
- 그래서 오늘날에는 ASCII 문자들로 제한된 집합으로 이루어진 URI를 사용하게 된 것

### 5.2 URI에서 사용될 수 있는 문자들

- US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, escape 문자들로 나뉨
- 예약되지 않은 문자들은 URI의 어떤 구성요소에서든 일반적으로 사용 가능

| 문자 분류 | 사용 가능 문자집합                            |
| :-------: | :-------------------------------------------- |
|  예약 X   | \[A-Za-z0-9] `-` `_` `.` `!` `~` `*` `'` `\|` |
|  예약 O   | `;` `/` `?` `:` `@` `&` `=` `+` `$` `,`       |
|  escape   | `%`                                           |

### 5.3 escaping & unescaping

- URI escape: 예약된 문자 및 다른 지원하지 않는 글자들을 안전하게 URI에 삽입할 수 있는 방법
- escape는 `%`와 그 뒤를 잇는 16진수 글자 둘로 있는 3글자 문자열
  - 16진수 2글자는 US-ASCII 문자 코드를 나타냄
- 예를 들어 URL에 스페이스(ASCII 32)를 삽입하고자 한다면 `%20`을 사용하면 됨
  - 32의 16진수는 20이기 때문
- HTTP 애플리케이션은 데이터가 필요할 때만 URI를 unescaping 해야 함
  - 절대 2번 unescaping 되지 않도록 주의해야 함

### 5.4 국제 문자들 escaping

- escape 값들은 US-ASCII 코드 범위(0-127)에 있어야 함
- 그렇기 때문에 어떤 애플리케이션은 iso-8859-1 확장 문자들을 표현하기 위해 escape 값 사용
  - 이는 부정확하며, 어떤 애플리케이션에서는 문제를 유발할 수 있음
  - ASCII는 오직 0x7F(127)까지의 코드만을 정의하기 때문

### 5.5 URI에서의 모달 전환

- 몇몇 URI는 다른 문자집합의 글자 표현을 위해 ASCII 문자열 사용
- 예를 들어 iso-2022-jp 인코딩은 JIS-Roman으로 변경하기 위해 `ESC ( J` 삽입 가능
- URI는 국제화 친화적이지 않음
  - URI 이식성이 언어 유연성보다 중요하게 여겨졌기 때문
  - 당분간 HTTP 애플리케이션은 ASCII와 함께 해야 함

<br>

## 6. 기타 고려사항

국제화된 HTTP 애플리케이션을 작성할 때 명심해야 할 다른 몇 가지 점들

### 6.1 헤더와 명세에 맞지 않는 데이터

- HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 함
- 그러나 모든 클라이언트와 서버가 이를 올바르게 구현한 것은 아님
- 대부분의 HTTP 애플리케이션은 문자 처리를 위해 운영체제 및 라이브러리 활용
  - 오래된 라이브러리의 경우 ASCII가 아닌 문자에 대해 충돌을 일으킬 수 있음

### 6.2 날짜

- HTTP 명세는 올바른 GMT 날짜 형식을 명확하게 정의하고 있음
- 역시나 모든 클라이언트와 서버가 이를 올바르게 따르는 것은 아님
- HTTP 애플리케이션은 명세에 맞지 않는 날짜라도 관대하게 받아들여야 함

### 6.3 도메인 이름

- Internationalizing Domain Name: 국제화 문자를 포함하는 도메인 이름
- 오늘날 대부분의 웹 브라우저가 punycode를 이용해서 이를 지원
  - punycode: Unicode 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법
