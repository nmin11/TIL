**웹 서버는 누구인가?**

- 웹 서버는 매일 수십억 개의 웹페이지를 쏟아냄
- 웹 서버는 당신에게 날씨를 알려주고, 온라인 쇼핑 카트에 물건을 싣고, 오랫동안 만나지 못한 옛날 친구를 찾을 수 있게 해줌
- 웹 서버는 WWW의 일꾼이라고 할 수 있음

**이번 장에서 다룰 내용**

- 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대한 조사
- 간단한 웹 서버를 Perl 언어로 작성해보기
- 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지에 대한 단계별 설명

<br>

## 1. 다채로운 웹 서버

- 웹 서버는 HTTP 요청을 처리하고 응답을 제공
- '웹 서버'라는 용어는 웹 서버 소프트웨어 및 웹페이지 제공에 특화된 장비 양쪽 모두를 가리킴
- 웹 서버는 기능, 형태, 크기가 다양함
- 기능은 다르더라도 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 컨텐츠를 클라이언트에게 돌려준다는 점은 동일함

### 1.1 웹 서버 구현

- 웹 서버는 HTTP 및 관련된 TCP 처리를 구현한 것
- HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공함
- TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 가짐
  - 운영체제는 컴퓨터 시스템의 하드웨어 관리, TCP/IP 네트워크 지원, 웹 리소스 유지를 위한 파일 시스템,<br>연산 활동을 제어하기 위한 프로세스 관리 기능을 제공해줌
- 웹 서버의 활용 예시
  - 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치 및 실행 가능
  - 전자기기 안에 몇 개의 컴퓨터 칩만으로 구현된 웹 서버를 내장시켜서 완전한 관리 콘솔로 제공하기도 함

### 1.2 다목적 소프트웨어 웹 서버

- 네트워크에 연결된 표준 컴퓨터 시스템에서 동작
- 아파치, W3C의 직소 등 오픈 소스 소프트웨어 활용도 가능하고, MS, 아이플래닛 등 상용 소프트웨어를 활용할 수도 있음
- 웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작 가능
- 세상에는 수만 가지 종류의 웹 서버 프로그램이 존재하지만 그중 몇 가지 웹 서버 소프트웨어만이 널리 사용됨
  - [웹 사이트들이 어떤 서버를 통해 서비스되고 있는가](https://news.netcraft.com/archives/2022/09/22/september-2022-web-server-survey.html)
  - 아파치 웹 서버가 강세였지만, nginx 서버의 점유율이 수년간 꾸준히 증가하고 있음

### 1.3 임베디드 웹 서버

- 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버
  - 프린트나 가전제품에 사용됨
- 사용자가 소비자용 기기를 간편한 웹 브라우저 인터페이스로 관리할 수 있게 해줌
- 몇몇 임베디드 웹 서버는 1제곱인치도 안 되는 크기로 최소한의 기능만을 제공해주는 경우도 있음
  - [아이픽 성냥 머리 크기의 웹 서버](http://web.archive.org/web/20020126140230/http://www-ccs.cs.umass.edu/~shri/iPic.html/)

<br>

## 2. 간단한 펄 웹 서버

- 완전한 기능을 갖춘 HTTP 서버를 만드는 것은 고된 일
  - 아파치 웹 서버의 코어는 50,000줄이 넘는 코드로 되어 있음
  - 부가적인 처리 모듈들을 함께 쓰면 더욱 복잡해짐
- HTTP/1.1 기능들을 지원하려면 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링 등 각종 기능들 필요
- 하지만 최소한의 기능을 하는 HTTP 서버를 만든다면 30줄 이하의 Perl 코드로도 충분함

<br>

## 3. 진짜 웹 서버가 하는 일

<img width="575" alt="웹 서버 요청 단계" src="https://user-images.githubusercontent.com/75058239/198831375-20cd63f8-7c92-440d-9192-580cd18cae1e.png">

1. 커넥션 맺기 : 클라이언트 접속을 수락하거나, 커넥션을 끊어버릴 수도 있음
2. 요청 받기 : HTTP 요청 메시지를 네트워크로부터 읽어 들임
3. 요청 처리 : 요청 메시지 해석 및 행동을 취함
4. 리소스 접근 : 메시지에서 지정한 리소스에 접근
5. 응답 생성 : 올바른 헤더를 포함한 HTTP 응답 메시지 생성
6. 응답 전송 : 클라이언트에게 응답을 돌려줌
7. 트랜잭션을 로그에 기록 : 로그 파일에 트랜잭션 완료에 대한 기록을 남김

<br>

## 4. 단계 1: 클라이언트 커넥션 수락

- 이미 지속 커넥션을 갖고 있다면 그것을 계속해서 사용할 수 있지만, 없다면 새 커넥션을 열어야 함

### 4.1 새 커넥션 다루기

- 클라이언트가 TCP 커넥션을 요청하면, 웹 서버는 커넥션을 맺고<br>TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인함
  - TCP 커넥션을 조작하는 인터페이스 및 자료구조는 운영체제마다 다름
  - 유닉스 환경에서는 소켓으로 표현되며, 클라이언트의 IP 주소는 `getpeername`을 호출해서 그 소켓으로부터 얻을 수 있음
- 새 커넥션이 맺어지면 서버는 커넥션 목록에 새 커넥션을 추가하고, 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 함
- 웹 서버는 IP 주소나 호스트 명이 인가되지 않았거나 악의적으라고 판단했을 때 커넥션을 닫을 수 있음

### 4.2 클라이언트 호스트 명 식별

- 대부분의 웹 서버는 **reverse DNS**를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환하도록 설정되어 있음
- 웹 서버는 클라이언트의 호스트 명을 구체적인 접근 제어 및 로깅을 위해 사용할 수 있음
- **hostname lookup**은 웹 트랜잭션을 느려지게 할 수도 있으니 유의할 것!
  - 수많은 대용량 웹 서버들은 hostname lookup을 꺼두거나 혹은 특정 컨텐츠에 대해서만 켜놓음
- 아파치에서는 `HostnameLookups` 설정 지시자로 호스트 명 룩업을 켤 수 있음

※ 아파치에서 HTML과 CGI 리소스만을 위해 호스트 명 분석을 켜는 예제

```html
HostnameLookups off
<Files ~ "\.(html|htm|cgi)$">
    HostnameLookups on
</Files>
```

### 4.3 ident를 통해 클라이언트 사용자 알아내기

- 몇몇 웹 서버는 **IETF ident 프로토콜**을 지원함
- ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해줌
- 이 정보는 로깅에 특히 유용하기에, 널리 쓰이는 Common Log Format의 2번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고 있음
- 클라이언트가 ident 프로토콜을 지원하는 경우에 클라이언트는 ident 결과를 위해 TCP 113번을 listen함

![ident 프로토콜](https://user-images.githubusercontent.com/75058239/198831390-e009a819-ff4f-4e38-9390-46c85f0766e5.png)

- ident는 조직 내부에서는 잘 활용될 수 있지만 공공 인터넷에는 다음 이유들 때문에 잘 동작하지 않음
  - 많은 클라이언트 PC는 identd 신원학인 프로토콜 데몬 소프트웨어를 실행하지 않음
  - HTTP 트랜잭션을 지연시킴
  - 방화벽이 ident 트래픽을 막는 경우가 많음
  - 안전하지 않고 조작하기 쉬움
  - 가상 IP 주소를 잘 지원하지 않음
  - 클라이언트 사용자 이름의 노출로 인한 프라이버시 침해의 우려가 있음
- 아파치 웹 서버의 경우 `IdentityCheck` 지시어를 통해서 ident 룩업을 사용하게 할 수 있음
  - 만약 가용한 ident 정보가 없는 경우에는 아파치에서 ident 로그 필드를 `-`로 채워버림
  - 보통의 경우 ident 정보가 없기 때문에 Common Log Format의 2번째 필드는 `-`로 채워짐

## 5. 단계 2: 요청 메시지 수신

![커넥션에서 요청 메시지 읽기](https://user-images.githubusercontent.com/75058239/198831398-46a01e5c-4ffd-40e5-9fd8-229c4dcd7676.png)

- 웹 서버는 네트워크 커넥션에서 데이터를 읽어 들이고 파싱하여 요청 메시지를 구성함
- 웹 서버가 요청 메시지를 파싱할 때 하는 작업
  - 요청 메소드, URI, 버전 번호(생략된 경우 HTTP/0.9)를 찾아냄<br>각 값은 스페이스 1개로 분리되어 있고, 요청줄은 CRLF 문자열로 끝남
  - 메시지 헤더들을 읽음, 각 메시지 헤더는 CRLF로 끝남
  - 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아냄
  - 요청 본문이 있는 경우에 그것을 읽어 들임
- 요청 메시지를 파싱할 때 웹 서버는 입력 데이터를 네트워크로부터 불규칙하게 받음
- 네트워크 커넥션은 언제라도 무효화될 수 있기에, 웹 서버는 메시지 일부분을 메모리에 임시 저장해 둘 필요가 있음

### 5.1 메시지의 내부 표현

<img width="581" alt="메시지 내부 표현 파싱" src="https://user-images.githubusercontent.com/75058239/198831407-7e1da7b7-c456-4fc1-9485-78549a581ec9.png">

- 몇몇 웹 서버는 요청 메시지를 쉽게 다루기 위해 내부 자료 구조에 저장함
- 예를 들면 요청 메시지 각 조각에 대한 포인터 및 길이를 담을 수 있으며, 헤더는 속도가 빠른 룩업 테이블에 저장될 수 있을 것

### 5.2 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원함
  - 이 커넥션들은 전 세계의 클라이언트들과 각각 1개 이상의 커넥션을 통해 통신할 수 있게 해줌
- 이런 경우 어떤 커넥션들로부터는 요청이 느리거나 아직 대기 중인데 비해, 일부 커넥션들은 웹 서버로 급속히 요청을 보내고 있을 것
- 요청은 언제라도 도착할 수 있기 때문에, 웹 서버들은 항상 새 요청을 주시하고 있음
- 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라짐

![웹 서버 입출력 아키텍처](https://user-images.githubusercontent.com/75058239/198831420-c057ba12-8abc-48cc-80bf-b82367f59c89.png)

**단일 스레드 웹 서버**

- 한 번에 하나의 요청만 처리
- 트랜잭션 완료 이후 다음 커넥션이 처리됨
- 구현이 간단하지만 처리 도중 다른 커넥션을 무시하게 됨
- 심각한 성능 문제가 있으므로 로드가 적은 서버 혹은 진단용 서버에만 적합

**멀티프로세스와 멀티스레드 웹 서버**

- 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당함
- 스레드/프로세스는 필요에 따라 만들어질 수도 있고 미리 만들어질 수도 있음
  - 스레드가 미리 생성되는 시스템을 worker pool 시스템이라고 부름
- 어떤 서버들은 매 커넥션마다 스레드/프로세스 하나를 할당하지만, 만약 서버가 수만 개의 동시 커넥션을 다룬다면<br>스레드/프로세스들은 지나친 메모리나 시스템 리소스를 소비하게 될 것
- 그렇기 때문에 멀티스레드 웹 서비스는 스레드/프로세스의 최대 개수에 제한을 둠

**다중 I/O 서버**

- 대량의 커넥션을 지원하기 위해, 많은 웹 서버는 다중 아키텍처를 채택했음
- 모든 커넥션이 동시에 그 활동을 감시당함
- 커넥션의 상태가 바뀌면 해당 커넥션에 대한 작은 양의 처리가 수행됨
- 처리 완료 이후 커넥션은 다음 상태 변경을 위해 열린 커넥션 목록으로 돌아감
- 특정 커넥션이 작업을 수행하는 것은 해당 커넥션에 실제로 해야 할 일이 있을 때뿐
  - 스레드와 프로세스는 유휴 상태의 커넥션에 매여 있느라 리소스를 낭비하는 일이 없음

**다중 멀티스레드 웹 서버**

- 몇몇 시스템은 CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 multiplexing을 결합함
- 여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행함

<br>

## 6. 단계 3: 요청 처리

- 요청으로부터 메소드, 리소스, 헤더, 본문을 얻어내서 처리함
- POST를 비롯한 몇몇 메소드는 요청에 반드시 본문이 있을 것을 요구함
  - OPTIONS를 비롯한 다수의 메소드는 요청 본문을 허용하되 요구하지는 않음
- 요청 처리는 이 책 나머지 대부분의 주제이기 때문에 이야기하지 않을 것

<br>

## 7. 단계 4: 리소스의 매핑과 접근

- 웹 서버는 리소스 서버로서, HTML 페이지나 JPEG 이미지 등 미리 만들어진 컨텐츠를 제공함
  - 서버 위에서 동작하는 리소스 생성 애플리케이션을 통해 만들어진 동적 컨텐츠도 존재함
- 웹 서버는 컨텐츠를 전달하기 전에 요청 메시지의 URL에 대응하는 컨텐츠 및 컨텐츠 생성기를 찾아서 컨텐츠의 원천을 식별해야 함

### 7.1 Docroot

- 웹 서버의 여러 종류의 리소스 매핑 방법 중 가장 단순하게 요청 URI를 웹 서버 파일 시스템 안의 파일 이름으로 사용하는 형태
- 일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 컨텐츠를 위해 예약해 둠
  - 해당 폴더는 문서 루트 혹은 docroot라고 불림
- 웹 서버는 요청 메시지에서 URI를 가져와서 문서 루트 뒤에 붙임

![요청 URI를 local 웹 서버 리소스에 매핑](https://user-images.githubusercontent.com/75058239/198858090-38f75633-570a-43d6-8167-a6aca45263ff.png)

- 아파치 웹 서버의 경우 `httpd.conf` 설정 파일에 `DocumentRoot`로 설정 가능

```
DocumentRoot /usr/local/httpd/files
```

- 서버는 docroot로 사용되는 상대적 URL이 docroot 이외의 부분을 노출하지 않도록 주의해야 함

**가상 호스팅된 docroot**

- 가상 호스팅 웹 서버는 각 사이트에 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅함
- URI 혹은 Host 헤더에서 얻은 IP 주소 혹은 호스트 명을 통해 올바른 문서 루트를 식별함

![가상 호스트 요청에 따라 다른 docroot](https://user-images.githubusercontent.com/75058239/198858094-bff973f5-3d92-4496-8f88-efd507acf7be.png)

- 아파치 웹 서버의 경우 각 가상 웹 사이트의 `VirtualHost` 블록에서<br>가상 서버에 대한 `DocumentRoot` 지시자를 포함하도록 설정함

```html
<VirtualHost www.joes-hardware.com>
  ServerName www.joes-hardware.com DocumentRoot /docs/joe TransferLog
  /logs/joe.access_log ErrorLog /logs/joe.error_log
</VirtualHost>
<VirtualHost www.marys-antiques.com>
  ServerName www.marys-antiques.com DocumentRoot /docs/mary TransferLog
  /logs/mary.access_log ErrorLog /logs/mary.error_log
</VirtualHost>
```

**사용자 홈 디렉토리 docroots**

- 사용자들이 한 대의 웹 서버에 개인 웹 사이트를 만들 수 있도록 해주는 방식
- 보통 `/` `~` 다음에 사용자 이름이 오는 것으로 시작하는 URI는 사용자 개인 문서 루트를 가리킴
- 개인 docroot는 주로 사용자 홈 디렉토리 안의 `public_html`로 불리는 디렉토리이지만, 설정에 따라 다름

<img width="576" alt="사용자별로 다른 docroot" src="https://user-images.githubusercontent.com/75058239/198858097-a2e70553-61ce-4635-b3d9-263b2dec73b5.png">

### 7.2 디렉토리 목록

- 웹 서버는 경로가 파일이 아닌 디렉토리를 가리키는 디렉터리 URL에 대한 요청을 받을 수 있음
- 대부분의 웹 서버가 디렉토리 요청을 받았을 때 취하는 행동들
  - 에러 반환
  - 디렉토리 대신 특별한 '색인 파일' 반환
  - 디렉토리 탐색 및 내용이 담긴 HTML 페이지 반환
- 대부분의 웹 서버는 요청 URL에 대응되는 디렉토리 안에서 `index.html` 파일을 찾아내고 반환함
- 아파치 웹 서버의 경우 `DirectoryIndex` 설정 지시자를 사용해서 기본 디렉토리 파일로 사용될 파일 이름 집합을 설정할 수 있음
  - `DirectoryIndex`는 색인 파일로 사용될 모든 파일의 이름을 우선순위로 나열함

```
DirectoryIndex index.html index.htm home.html home.htm index.cgi
```

- 사용자가 디렉토리 URI를 요청했을 때 기본 색인 파일이 없고 디렉토리 색인 기능이 꺼져 있으면<br>많은 웹 서버는 자동으로 디렉토리의 파일들을 크기, 변경일, 파일 링크와 함께 열거한 HTML 파일로 응답함
  - 파일 열거는 편리할 수도 있지만, 일반적으로 발견할 수 없는 파일도 드러나게 함
- 아파치의 경우 디렉토리 색인 파일 자동 생성을 끌 수 있음

```
Options -Indexes
```

### 7.3 동적 컨텐츠 리소스 매핑

![동적 리소스](https://user-images.githubusercontent.com/75058239/198858100-c7726911-4703-47a4-aa01-0d7681b61cf2.png)

- 웹 서버는 요청에 맞게 컨텐츠를 생성하는 프로그램에 URI를 매핑할 수 있음
- 사실, 웹 서버들 중 애플리케이션 서버라고 불리는 것들은 웹 서버를 복잡한 백엔드 애플리케이션과 연결하는 일을 수행함
- 특정 리소스가 동적 리소스라면 서버는 동적 컨텐츠 생성 프로그램이 어디에 있으며, 어떻게 실행하는지 알려줄 수 있어야 함
- 대부분의 웹 서버는 동적 리소스를 식별하고 매핑할 수 있는 기본적인 메커니즘을 갖고 있음
- 아파치의 경우 URI 경로명이 실행 가능한 프로그램이 위치한 디렉토리로 매핑되도록 설정하는 기능을 제공함

```
ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/
```

- 또한 아파치는 특정 확장자의 파일만 실행하도록 설정할 수도 있음

```
AddHandler cgi-script .cgi
```

- 웹 초창기에 널리 쓰인 CGI는 서버사이드 애플리케이션 실행을 위한 간단한 인터페이스
  - 오늘날의 애플리케이션 서버는 MS의 액티브 서버 페이지, 자바 서블릿 같은<br>강력하고 효과적인 서버사이드 동적 컨텐츠 지원 기능을 갖고 있음

### 7.4 SSI(Server-Side Includes)

- 특정 리소스가 SSI를 포함하고 있다면, 서버는 해당 리소스의 컨텐츠를 클라이언트에게 보내기 전에 처리함
- 컨텐츠의 변수 이름이나 내장된 스크립트가 될 수 있는 패턴이 있는지 등에 대해 검사를 진행함
- 특별한 패턴은 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환됨

### 7.5 접근 제어

- 웹 서버는 각 리소스에 접근 제어를 할당할 수 있음
- 접근 제어 대상 리소스 요청이 도착하면 웹 서버는 클라이언트 IP 주소에 근거하여 접근을 제어할 수 있으며,<br>리소스에 접근하기 위한 비밀번호를 물어볼 수도 있음

<br>

## 8. 단계 5: 응답 만들기

- 서버는 리소스 식별 이후, 동작을 수행한 뒤 응답 메시지를 반환함
- 응답 메시지는 응답 상태 코드, 응답 헤더, 응답 본문을 포함함

### 8.1 응답 엔티티

- 응답에 본문이 존재한다면 다음 요소들을 주로 포함하게 됨
  - 본문의 MIME 타입을 서술하는 Content-Type 헤더
  - 본문의 길이를 서술하는 Content-Length 헤더
  - 실제 본문 내용

### 8.2 MIME 타입 결정하기

- 웹 서버에게는 응답 본문의 MIME 타입을 결정해야 한다는 책임이 있음
- 이번 절에서 MIME 타입과 리소스를 연결하는 여러 방법들을 알아볼 것

**mime.types**

- 웹 서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있음
- 각 리소스의 MIME 타입 계산을 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색함
- 이러한 확장자 기반 타입 연계가 가장 흔한 방법

<img width="577" alt="MIME 타입 목록 파일" src="https://user-images.githubusercontent.com/75058239/198863334-87e45728-66af-4c69-802c-6567bcfcaf2b.png">

**Magic typing**

- 아파치의 경우 파일의 MIME 타입을 알아내기 위해 파일 내용을 검사해서<br>알려진 패턴에 대한 테이블(매직 파일)에 해당하는 패턴이 있는지 찾아봄
- 느린 방법이지만 파일에 표준 확장자가 없는 경우에 특히 편리함

**Explicit typing**

- 파일 확장자나 내용에 상관없이 특정 MIME 타입을 갖도록 웹 서버를 설정할 수 있음

**Type negotiation**

- 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있음
- 사용자와의 협상 과정을 통해 사용하기 가장 좋으며 대응되는 MIME 타입으로 판별할 수도 있음
- 웹 서버는 특정 파일이 특정 MIME 타입을 갖게끔 설정할 수도 있음

### 8.3 리다이렉션

- 웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환함
- Location 응답 헤더는 컨텐츠의 위치에 대한 URI를 포함함
- 다음으로, 리다이렉트가 유용한 경우들에 대해서 알아볼 것

**영구히 리소스가 옮겨진 경우**

- 리소스는 새 URL이 부여되어 새로운 위치로 이동했거나, 이름이 바뀌었을 수 있음
- 클라이언트에게 북마크를 갱신할 수 있다고 말해줄 수 있음
- 301 Moved Permanently 상태 코드가 함께 사용됨

**임시로 리소스가 옮겨진 경우**

- 서버는 클라이언트가 새 위치로 리다이렉트하길 원할 것이지만 나중에는 원래 URL로 찾아오고 북마크도 갱신하지 않기를 원할 것
- 303 See Other, 307 Temporary Redirect 상태 코드가 함께 사용됨

**URL 증강**

- 서버는 종종 문맥 정보 포함을 위해 재작성된 URL로 리다이렉트해줌
- 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 여기로 리다이렉트함
- 이와 같이 상태 정보가 추가되어 확장된 URL을 흔히 fat URL 이라고도 부름
- 클라이언트는 리다이렉트를 따라가게 되고, 상태정보가 포함된 완전한 URL을 포함한 요청을 다시 보냄
- 이 방법은 트랜잭션 간 상태를 유지하는 유용한 방법
- 303 See Other, 307 Temporary Redirect 상태 코드가 함께 사용됨

**부하 균형**

- 과부하된 서버가 요청을 받았을 때 부하가 덜 걸린 다른 서버로 리다이렉트할 수 있음
- 303 See Other, 307 Temporary Redirect 상태 코드가 함께 사용됨

**친밀한 다른 서버가 있을 때**

- 웹 서버는 특정 사용자에 대한 정보를 가질 수 있음
- 서버는 클라이언트에 대한 정보를 갖고 있는 다른 서버로 리다이렉트할 수 있음
- 303 See Other, 307 Temporary Redirect 상태 코드가 함께 사용됨

**디렉토리 이름 정규화**

- 클라이언트가 디렉토리 이름에 대한 URI를 요청하면서 `/`를 빠뜨렸을 때,<br>서버는 상대경로가 정상 작동하도록 `/`를 추가한 URI로 리다이렉트함
