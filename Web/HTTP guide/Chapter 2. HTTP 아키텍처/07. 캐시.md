- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면 문서는 캐시로부터 제공됨

※ 캐시의 혜택

- 불필요한 데이터 전송을 줄여서, 네트워크 요금을 줄여줌
- 네트워크 병목을 줄여주기 때문에 대역폭을 늘리지 않고도 페이지를 빠르게 불러올 수 있게 해줌
- 원 서버에 대한 요청을 줄여줘서 서버의 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 됨
- 거리로 인한 지연을 줄여줌

※ 이 장에서 배울 것

- 캐시가 어떻게 성능을 개선하고 비용을 줄여주는지
- 캐시의 효과를 어떻게 측정하는지
- 캐시의 효과를 극대화하기 위해 캐시를 어디에 위치시켜야 하는지
- HTTP는 어떻게 캐시된 사본을 신선하게 유지하는지
- 캐시가 다른 캐시나 서버와 어떻게 상호작용하는지

<br>

## 1. 불필요한 데이터 전송

- 캐시가 없다면, 다수의 클라이언트가 자주 사용되는 원 서버 페이지에 접근할 때,<br>서버는 똑같은 파일들을 네트워크를 통해 반복해서 이동시켜야 함
- 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 하며, 웹 서버에 부하를 줌
- 캐시가 있으면, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 됨

<br>

## 2. 대역폭 병목

- 대다수의 네트워크들은 원격 서버보다 로컬 네트워크 클라이언트에게 더 넓은 대역폭을 제공함
- 클라이언트가 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같음
- 클라이언트가 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것

<br>

## 3. Flash Crowds

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요함
- 갑작스런 사건 등으로 인한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킴

<br>

## 4. 거리로 인한 지연

- 대역폭 뿐만이 아니라 거리도 문제가 될 수 있음
- 모든 네트워크 라우터들을 지나갈 때마다 인터넷 트래픽 지연이 생김
- 라우터들의 개수 뿐만이 아니라 신호의 속도 자체도 유의미한 지연
  - 보스턴과 샌프란시스코 사이의 거리는 약 4,400km이며 이를 빛의 속도(300,000km/s)로 주파하면 15ms, 왕복은 30ms
    - 하지만 신호의 속도는 빛의 속도보다는 약간 느리다는 점을 또한 감안해야 함
  - 보스턴과 10,800km 떨어진 도쿄와 통신한다면 지연은 600ms로 커짐
    - 복잡한 웹 페이지의 경우 수 초가 걸릴 수도 있는 것
- 캐시와 함께라면 문서가 전송되는 거리를 수천 km에서 수십 m로 줄일 수 있음

<br>

## 5. 적중과 부적중

- 캐시가 세상 모든 문서의 사본을 저장하지는 않음
  - 설령 모든 웹에 대한 캐시를 샀다고 해도, 문서의 최신화를 항상 유지하지는 못할 것
- **cache hit** : 요청에 대응하는 사본이 캐시에 있어서 요청을 바로 처리할 수 있음
- **cache miss** : 대응하는 사본이 없어서 원 서버로 전달해야 함

![캐시 적중 부적중 재검사](https://user-images.githubusercontent.com/75058239/200198594-57b607ff-3cef-4b25-9f98-5348abe10ac0.png)

### 5.1 Revalidation

- 원 서버 컨텐츠는 변경될 수 있기에, 캐시는 반드시 갖고 있는 사본들에 대한 최신화 상태를 때때로 점검해야 함
  - 이러한 '신선도 검사'를 HTTP 재검사라고 부름
- 효과적인 재검사를 위해, HTTP는 전체 객체를 가져오지 않고도 신선도를 빠르게 검사할 수 있는 특별한 요청을 정의했음
- 캐시는 원한다면 언제든지 사본을 재검사할 수 있음
  - 하지만 캐시가 문서를 수백만 개씩 갖고 있는 경우가 흔한데 비해, 네트워크 대역폭은 부족함
- 그래서 캐시는 사본이 검사가 필요할 정도로 충분히 오래된 경우에만 재검사를 함
- 캐시는 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄
  - 컨텐츠 변경이 없다면 서버는 아주 작은 304 Not Modified 응답을 보냄
  - 사본이 여전히 유효함을 알게 된 캐시는 임시로 사본이 신선하다는 표시를 해두고 클라이언트에게 제공함
- If-Modified-Since 헤더: GET 요청에 이 헤더를 추가하면 캐시된 시간 이후 변경된 경우에만 사본을 보내달라는 의미

**재검사 적중**

- 서버 객체가 변경되지 않았다면 작은 304 Not Modified 응답을 보냄

**재검사 부적중**

- 서버 객체가 캐시 사본과 다르다면 컨텐츠 전체와 함께 평범한 200 OK를 보냄

**객체 삭제**

- 서버 객체가 삭제되었다면 404 Not Found 응답을 보내며, 캐시는 사본을 삭제함

### 5.2 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 함
- 적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 함
- 비율을 따질 때 일반 적중률과 재검사 적중률을 별도로 측정해야 함
- 적중률은 캐시 크기, 사용자들의 관심사, 변경 빈도, 개인화, 캐시 설정에 따라 다름
- 예측하기 어려운 것으로 악명이 높지만 오늘날 적중률 40%면 괜찮은 편

### 5.3 byte 적중률

- 문서들이 모두 같은 크기가 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않음
- 몇몇 큰 객체는 접근 빈도는 낮지만 그 크기 때문에 전체 트래픽에는 더 크게 기여함
- byte 단위 적중률은 캐시를 통해 제공된 모든 byte의 비율을 표현함
- byte 단위 적중률 100%는 모든 byte가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미
- 문서 적중률과 byte 단위 적중률 둘 다 캐시 성능에 유용한 지표
  - 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지를 보여줌
  - byte 단위 적중률은 얼마나 많은 byte가 인터넷으로 나가지 않았는지를 보여줌

### 5.4 적중과 부적중의 구별

- 클라이언트 입장에서는 캐시 적중이 있었는지, 원 서버에 접근했는지 알 수 없음
  - 두 경우 모두 응답 코드는 200 OK
- 어떤 상용 프록시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 입력해줌
- 클라이언트가 응답이 캐시로부터 왔는지 알아내는 한 가지 방법은 **Date 헤더**를 이용하는 것
  - 응답의 Date 헤더 값을 현재 시각과 비교해서 오래되었다면 캐시된 것
- 또 다른 방법으로는 Age 헤더를 이용할 수도 있음

<br>

## 6. 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당될 수도 있고, 반대로 수천 명의 사용자들 사이에 공유될 수도 있음
- private cache: 한 명에게만 할당되는 개인 전용 캐시
- public cache: 사용자 집단에게 공유되는 캐시

### 6.1 개인 전용 캐시

- 많은 에너지나 저장 공간이 필요한 것이 아니기 때문에 작고 저렴함
- 웹 브라우저는 개인 전용 캐시를 내장하고 있음
  - 대부분 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 설정할 수 있도록 허용함
  - 사용자들은 캐시를 확인하기 위해 브라우저 안을 들여다볼 수 있음

### 6.2 공용 프록시 캐시

- 공용 캐시는 공유된 프록시 서버
- 프록시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 서버에 접근함
- 여러 사용자가 이용하기 때문에 불필요한 트래픽을 더욱 많이 줄일 수 있음
- 캐시는 자주 찾는 객체를 단 한 번만 가져와서 모든 동일한 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임
- 클라이언트의 프록시 설정을 통해, 브라우저가 프록시 캐시를 사용하도록 설정할 수 있음
- 인터셉트 프록시를 사용함으로써 브라우저 설정 없이도 요청이 캐시를 통하도록 강제할 수도 있음 (나중 내용)

### 6.3 프록시 캐시 계층들

(이미지 첨부 - 캐시 계층)

- 여러 캐시들을 자식과 부모 계층으로 만들어 두고, 부적중이 발생했을 때 걸려 남겨진 트래픽을 부모 캐시가 처리하도록 하는 구조
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 상단에는 많은 사용자들에 의해 공유되는 문서를 유지
  - 부모 캐시일수록 많은 자식 캐시들의 트래픽들을 감당해야 하므로 더욱 고성능이어야 함
- 캐시 계층이 너무 깊어지면 프록시 연쇄가 길어지고, 성능 저하가 발생할 것
  - 그렇기에 네트워크 아키텍트들은 2개 혹은 3개의 프록시만 거치도록 스스로 제한함
  - 그러나 새로운 세대의 고성능 프록시 서버들은 프록시 연쇄 길이가 문제가 되지 않도록 할 것

### 6.4 캐시망, 컨텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 **캐시망**을 만듦
- 캐시망의 프록시 캐시는 복잡한 방법으로 서로 대화하며,<br>어떤 부모 캐시와 대화할지 혹은 우회해서 원 서버로 갈지, 동적으로 결정을 내림
- 캐시망 안에서 컨텐츠 라우팅을 위해 설계된 캐시들이 할 수 있는 일들
  - URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들의 부분적 접근 허용, 하지만 트래픽이 다른 네트워크로 넘어가는 **Internet transit** 은 허용하지 않음
- 이러한 복잡한 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로 찾아볼 수 있게 함
- 선택적인 피어링을 지원하는 캐시는 **형제 캐시**라고 불림
  - HTTP에서 형제 캐시를 지원하지 않기 때문에 사람들은 ICP(Internet Cache Protocol)나<br>HTCP(HyperText Cache Protocol) 같은 프로토콜을 이용해서 HTTP를 확장했음
