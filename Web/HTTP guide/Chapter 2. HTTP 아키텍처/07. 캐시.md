- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면 문서는 캐시로부터 제공됨

※ 캐시의 혜택

- 불필요한 데이터 전송을 줄여서, 네트워크 요금을 줄여줌
- 네트워크 병목을 줄여주기 때문에 대역폭을 늘리지 않고도 페이지를 빠르게 불러올 수 있게 해줌
- 원 서버에 대한 요청을 줄여줘서 서버의 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 됨
- 거리로 인한 지연을 줄여줌

※ 이 장에서 배울 것

- 캐시가 어떻게 성능을 개선하고 비용을 줄여주는지
- 캐시의 효과를 어떻게 측정하는지
- 캐시의 효과를 극대화하기 위해 캐시를 어디에 위치시켜야 하는지
- HTTP는 어떻게 캐시된 사본을 신선하게 유지하는지
- 캐시가 다른 캐시나 서버와 어떻게 상호작용하는지

<br>

## 1. 불필요한 데이터 전송

- 캐시가 없다면, 다수의 클라이언트가 자주 사용되는 원 서버 페이지에 접근할 때,<br>서버는 똑같은 파일들을 네트워크를 통해 반복해서 이동시켜야 함
- 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 하며, 웹 서버에 부하를 줌
- 캐시가 있으면, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 됨

<br>

## 2. 대역폭 병목

- 대다수의 네트워크들은 원격 서버보다 로컬 네트워크 클라이언트에게 더 넓은 대역폭을 제공함
- 클라이언트가 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같음
- 클라이언트가 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것

<br>

## 3. Flash Crowds

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요함
- 갑작스런 사건 등으로 인한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킴

<br>

## 4. 거리로 인한 지연

- 대역폭 뿐만이 아니라 거리도 문제가 될 수 있음
- 모든 네트워크 라우터들을 지나갈 때마다 인터넷 트래픽 지연이 생김
- 라우터들의 개수 뿐만이 아니라 신호의 속도 자체도 유의미한 지연
  - 보스턴과 샌프란시스코 사이의 거리는 약 4,400km이며 이를 빛의 속도(300,000km/s)로 주파하면 15ms, 왕복은 30ms
    - 하지만 신호의 속도는 빛의 속도보다는 약간 느리다는 점을 또한 감안해야 함
  - 보스턴과 10,800km 떨어진 도쿄와 통신한다면 지연은 600ms로 커짐
    - 복잡한 웹 페이지의 경우 수 초가 걸릴 수도 있는 것
- 캐시와 함께라면 문서가 전송되는 거리를 수천 km에서 수십 m로 줄일 수 있음

<br>

## 5. 적중과 부적중

- 캐시가 세상 모든 문서의 사본을 저장하지는 않음
  - 설령 모든 웹에 대한 캐시를 샀다고 해도, 문서의 최신화를 항상 유지하지는 못할 것
- **cache hit** : 요청에 대응하는 사본이 캐시에 있어서 요청을 바로 처리할 수 있음
- **cache miss** : 대응하는 사본이 없어서 원 서버로 전달해야 함

![캐시 적중 부적중 재검사](https://user-images.githubusercontent.com/75058239/200198594-57b607ff-3cef-4b25-9f98-5348abe10ac0.png)

### 5.1 Revalidation

- 원 서버 컨텐츠는 변경될 수 있기에, 캐시는 반드시 갖고 있는 사본들에 대한 최신화 상태를 때때로 점검해야 함
  - 이러한 '신선도 검사'를 HTTP 재검사라고 부름
- 효과적인 재검사를 위해, HTTP는 전체 객체를 가져오지 않고도 신선도를 빠르게 검사할 수 있는 특별한 요청을 정의했음
- 캐시는 원한다면 언제든지 사본을 재검사할 수 있음
  - 하지만 캐시가 문서를 수백만 개씩 갖고 있는 경우가 흔한데 비해, 네트워크 대역폭은 부족함
- 그래서 캐시는 사본이 검사가 필요할 정도로 충분히 오래된 경우에만 재검사를 함
- 캐시는 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄
  - 컨텐츠 변경이 없다면 서버는 아주 작은 304 Not Modified 응답을 보냄
  - 사본이 여전히 유효함을 알게 된 캐시는 임시로 사본이 신선하다는 표시를 해두고 클라이언트에게 제공함
- If-Modified-Since 헤더: GET 요청에 이 헤더를 추가하면 캐시된 시간 이후 변경된 경우에만 사본을 보내달라는 의미

**재검사 적중**

- 서버 객체가 변경되지 않았다면 작은 304 Not Modified 응답을 보냄

**재검사 부적중**

- 서버 객체가 캐시 사본과 다르다면 컨텐츠 전체와 함께 평범한 200 OK를 보냄

**객체 삭제**

- 서버 객체가 삭제되었다면 404 Not Found 응답을 보내며, 캐시는 사본을 삭제함

### 5.2 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 함
- 적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 함
- 비율을 따질 때 일반 적중률과 재검사 적중률을 별도로 측정해야 함
- 적중률은 캐시 크기, 사용자들의 관심사, 변경 빈도, 개인화, 캐시 설정에 따라 다름
- 예측하기 어려운 것으로 악명이 높지만 오늘날 적중률 40%면 괜찮은 편

### 5.3 byte 적중률

- 문서들이 모두 같은 크기가 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않음
- 몇몇 큰 객체는 접근 빈도는 낮지만 그 크기 때문에 전체 트래픽에는 더 크게 기여함
- byte 단위 적중률은 캐시를 통해 제공된 모든 byte의 비율을 표현함
- byte 단위 적중률 100%는 모든 byte가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미
- 문서 적중률과 byte 단위 적중률 둘 다 캐시 성능에 유용한 지표
  - 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지를 보여줌
  - byte 단위 적중률은 얼마나 많은 byte가 인터넷으로 나가지 않았는지를 보여줌

### 5.4 적중과 부적중의 구별

- 클라이언트 입장에서는 캐시 적중이 있었는지, 원 서버에 접근했는지 알 수 없음
  - 두 경우 모두 응답 코드는 200 OK
- 어떤 상용 프록시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 입력해줌
- 클라이언트가 응답이 캐시로부터 왔는지 알아내는 한 가지 방법은 **Date 헤더**를 이용하는 것
  - 응답의 Date 헤더 값을 현재 시각과 비교해서 오래되었다면 캐시된 것
- 또 다른 방법으로는 Age 헤더를 이용할 수도 있음

<br>

## 6. 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당될 수도 있고, 반대로 수천 명의 사용자들 사이에 공유될 수도 있음
- private cache: 한 명에게만 할당되는 개인 전용 캐시
- public cache: 사용자 집단에게 공유되는 캐시

### 6.1 개인 전용 캐시

- 많은 에너지나 저장 공간이 필요한 것이 아니기 때문에 작고 저렴함
- 웹 브라우저는 개인 전용 캐시를 내장하고 있음
  - 대부분 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 설정할 수 있도록 허용함
  - 사용자들은 캐시를 확인하기 위해 브라우저 안을 들여다볼 수 있음

### 6.2 공용 프록시 캐시

- 공용 캐시는 공유된 프록시 서버
- 프록시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 서버에 접근함
- 여러 사용자가 이용하기 때문에 불필요한 트래픽을 더욱 많이 줄일 수 있음
- 캐시는 자주 찾는 객체를 단 한 번만 가져와서 모든 동일한 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임
- 클라이언트의 프록시 설정을 통해, 브라우저가 프록시 캐시를 사용하도록 설정할 수 있음
- 인터셉트 프록시를 사용함으로써 브라우저 설정 없이도 요청이 캐시를 통하도록 강제할 수도 있음 (나중 내용)

### 6.3 프록시 캐시 계층들

![캐시 계층](https://user-images.githubusercontent.com/75058239/200310082-705cf89f-822c-4434-9b89-1d26358b6e52.png)

- 여러 캐시들을 자식과 부모 계층으로 만들어 두고, 부적중이 발생했을 때 걸려 남겨진 트래픽을 부모 캐시가 처리하도록 하는 구조
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 상단에는 많은 사용자들에 의해 공유되는 문서를 유지
  - 부모 캐시일수록 많은 자식 캐시들의 트래픽들을 감당해야 하므로 더욱 고성능이어야 함
- 캐시 계층이 너무 깊어지면 프록시 연쇄가 길어지고, 성능 저하가 발생할 것
  - 그렇기에 네트워크 아키텍트들은 2개 혹은 3개의 프록시만 거치도록 스스로 제한함
  - 그러나 새로운 세대의 고성능 프록시 서버들은 프록시 연쇄 길이가 문제가 되지 않도록 할 것

### 6.4 캐시망, 컨텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 **캐시망**을 만듦
- 캐시망의 프록시 캐시는 복잡한 방법으로 서로 대화하며,<br>어떤 부모 캐시와 대화할지 혹은 우회해서 원 서버로 갈지, 동적으로 결정을 내림
- 캐시망 안에서 컨텐츠 라우팅을 위해 설계된 캐시들이 할 수 있는 일들
  - URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들의 부분적 접근 허용, 하지만 트래픽이 다른 네트워크로 넘어가는 **Internet transit** 은 허용하지 않음
- 이러한 복잡한 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로 찾아볼 수 있게 함
- 선택적인 피어링을 지원하는 캐시는 **형제 캐시**라고 불림
  - HTTP에서 형제 캐시를 지원하지 않기 때문에 사람들은 ICP(Internet Cache Protocol)나<br>HTCP(HyperText Cache Protocol) 같은 프로토콜을 이용해서 HTTP를 확장했음

![형제 캐시](https://user-images.githubusercontent.com/75058239/200310153-6aa09bb8-efad-439f-a6c3-fd4bb011c878.jpeg)

<br>

## 7. 캐시 처리 단계

![캐시 처리 단계](https://user-images.githubusercontent.com/75058239/200434608-456ba07d-efd5-4839-8389-4db958594bbe.png)

1. 요청 받기: 네트워크로부터 도착한 요청 메시지를 읽음
2. 파싱: 메시지를 파싱하여 URL과 헤더들을 추출함
3. 검색: 로컬 복사본을 검사하고, 사본이 없다면 사본을 받아옴
4. 신선도 검사: 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항을 서버에 물어봄
5. 응답 생성: 새로운 헤더 및 캐시된 본문으로 응답 메시지를 만듦
6. 발송: 네트워크를 통해 응답을 클라이언트에게 돌려줌
7. 로깅: (Optional) 로그 파일에 트랜잭션에 대한 로그 하나를 남김

### 7.1 단계 1: 요청 받기

- 캐시는 네트워크 커넥션에의 활동을 감지하고, 들어오는 데이터를 읽어들임
- 고성능 캐시의 경우 동시에 여러 데이터를 읽어들이고 메시지 전체가 들어오기도 전에 트랜잭션 처리를 시작함

### 7.2 단계 2: 파싱

- 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담음
- 이 작업을 통해 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어줌
- 파서는 또한 헤더의 대소문자 구분, 날짜 형식 등 중요하지 않은 차이점이 무시되도록 정규화할 책임을 가짐

### 7.3 단계 3: 검색

- 캐시는 URL을 알아내고, 그에 해당하는 로컬 사본이 있는지 검사함
- 로컬 복사본은 메모리, 디스크, 심지어는 근처의 다른 컴퓨터에 있을 수도 있음
- 전문적인 캐시는 객체를 로컬에서 가져올 수 있는지 판단하기 위해 빠른 알고리듬을 사용함
  - 문서를 로컬에서 가져올 수 없다면, 상황이나 설정에 따라 원 서버나 부모 프록시에서 가져오거나, 아니면 실패를 반환함
- 캐시된 객체는 응답 본문, 원 서버의 응답 헤더와 함께,<br>객체가 얼마나 오래 캐시에 머물렀는지, 얼마나 자주 사용했는지 등의 몇몇 메타데이터를 포함함

### 7.4 단계 4: 신선도 검사

- HTTP에서 캐시는 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 하며, 일정 기간이 지나면 '신선하지 않은 것'으로 간주함
- HTTP의 신선도 검사 규칙은 매우 복잡
  - 캐시 제품들이 지원하는 설정 옵션과 비 HTTP 신선도 표준이 들어오면서, 상황은 더욱 복잡해졌음
  - 이는 7장 뒷부분의 대부분이 될 내용

### 7.5 단계 5: 응답 생성

- 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성함
- 캐시는 클라이언트에 맞게 응답 헤더를 조정해야 하는 책임이 있음
  - 예를 들면 클라이언트가 원하는 HTTP 버전을 적용해줘야 함
- 캐시 신선도 정보(Cache-Control, Age, Expires)를 삽입하며, 종종 Via 헤더도 포함함
- 단, Date 헤더는 캐시가 조정해선 안됨
  - Date 헤더는 해당 객체가 원 서버에서 최초로 생겨난 일시를 표현함

### 7.6 단계 6: 전송

- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려줌
- 응답 전송 후, 프록시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
- 고성능 캐시는 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서 컨텐츠 복사를 피함으로써 데이터를 효과적으로 전송하고자 함

### 7.7 단계 7: 로깅

- 대부분의 캐시는 로그 파일 및 캐시 사용에 대한 통계를 유지함
- 각 캐시 트랜잭션 완료 후, 캐시 적중과 부적중 횟수에 대한 통계 갱신, 로그 파일에 요청 종류 및 URL, 무엇이 일어났는지를 추가함
- 가장 많이 쓰이는 로그 포맷: Squid log format, Netscape extended common log format
- 많은 제품이 커스텀 로그 파일을 허용함

### 7.8 캐시 처리 플로 차트

![캐시 처리 플로 차트](https://user-images.githubusercontent.com/75058239/200434630-df5725ec-3731-4c68-a1e3-43ca4505b903.png)

<br>

## 8. 사본을 신선하게 유지하기

- 오래된 데이터를 제공하는 캐시는 불필요하며, 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 함
- 문서 만료와 서버 재검사: HTTP는 서버에서 캐시가 어떻게 관리되고 있는지 모르더라도<br>사본이 서버와 충분히 일치하도록 유지해주는 단순한 메커니즘을 갖고 있음

### 8.1 문서 만료

- HTTP는 **Expires** 와 **Cache-Control** 헤더들을 이용해서 원 서버가 문서의 유효기간을 설정할 수 있게 함

![Expires 헤더와 Cache-Control 헤더](https://user-images.githubusercontent.com/75058239/200664741-5c78cfe9-6439-4894-b135-2c73ea8c094e.png)

- 이 만료 기간 전에 캐시는 서버와의 접촉 없이 사본을 제공할 수 있음
- 캐시된 문서가 만료되었다면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하고,<br>변경사항이 있다면 신선한 사본을 새로운 유효기간과 함께 받아와야 함

### 8.2 유효기간과 나이

- Expires 헤더와 Cache-Control: max-age 응답 헤더는 유효기간을 명시한다는 같은 일을 하지만,<br>절대 시간은 컴퓨터 시계가 올바르게 맞춰져 있을 것을 요구함

|          헤더          | 설명                                                                                                                                           |
| :--------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------- |
| Cache-Control: max-age | 문서 최대 나이를 정의<br>최대 나이는 문서의 첫 생성 이후 신선하지 않다고 간주될 때까지 경과한 시간의 최댓값<br>`Cache-Control: max-age=484200` |
|        Expires         | 절대 유효기간 명시<br>`Expires: Fir, 05 Jul 2002, 05:00:00 GMT`                                                                                |

※ 모든 HTTP 날짜와 시간은 GMT로 표현된다는 점에 주의해야 함! (KST보다는 9시간 느림)

### 8.3 서버 재검사

- 캐시된 문서의 만료는 해당 문서가 원 서버에 존재하는 것과 반드시 다르다는 의미는 아님
  - 다만 이제 검사할 시간이 되었다는 뜻
- 서버 재검사 과정
  - 재검사 결과 컨텐츠가 변경되었다면, 캐시는 새로운 사본을 가져와서 저장한 뒤에 클라이언트에게도 이를 보내줌
  - 재검사 결과 컨텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신함
- 이런 괜찮은 시스템을 통해 캐시는 매 요청마다 신선도를 검증할 필요가 없고, 문서가 만료되었을 때만 서버와 재검사하면 됨
  - 신선하지 않은 컨텐츠를 제공하지 않으면서도, 서버 트래픽도 절약하고, 사용자 응답 시간도 개선함
- HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 행동을 적절히 취하도록 요구함
  - '충분히 신선한' 캐시된 사본
  - 재검사가 이루어졌기에 충분히 신선하다고 확신할 수 있는 캐시된 사본
  - 재검사해야 하는 원 서버가 다운된 경우를 위한 에러 메시지
  - 사본이 부정확한 경우 경고 메시지가 부착된 캐시된 사본

### 8.4 조건부 메소드와의 재검사

- HTTP의 조건부 메소드는 재검사를 효율적으로 만들어줌
- HTTP는 캐시가 서버에게 '조건부 GET' 요청을 보낼 수 있도록 해줌
  - 서버가 갖고 있는 문서가 캐시의 것과 다를 때만 객체 본문을 보내달라고 하는 요청
- 신선도 검사와 객체를 받아오는 작업은 하나의 조건부 GET으로 결합해서 처리 가능!
- 조건부 GET은 GET 요청에 특별한 조건부 헤더를 추가함으로써 시작됨
- HTTP는 5가지 조건부 요청 헤더를 정의하며, 이 중에서 2가지 헤더가 가장 유용하게 쓰임

|            헤더            | 설명                                                                                                       |
| :------------------------: | :--------------------------------------------------------------------------------------------------------- |
| If-Modified-Since: \<date> | 문서가 주어진 날짜 이후로 수정되었다면 요청 메소드 처리<br>Last-Modified 응답 헤더와 함께 쓰임             |
|   If-None-Match: \<tags>   | 문서의 일련번호와 같은 특별한 태그를 활용하는 방법<br>캐시된 태그가 서버 문서의 태그와 다를 때만 요청 처리 |

※ 나머지 3개의 조건부 요청 헤더

- `If-Unmodified-Since` : 문서를 부분적으로 받았을 때, 전에 일부분 받았던 문서가 여전히 신선한지를 확인할 때 유용
- `If-Range` : 불완전한 문서의 캐싱 지원
- `If-Match` : 웹 서버에 대한 동시성 제어를 할 때 유용
  - 예를 들면 문서가 변경되지 않았을 때에만 PUT 요청을 보낼 수도 있음

### 8.5 If-Modified-Since: 날짜 재검사

- 가장 흔하게 쓰이는 캐시 재검사 헤더
- 'IMS' 요청이라고도 불림
- 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 본문을 보내달라고 함

※ 처리 과정

- 문서가 주어진 날짜 이후에 변경되었다면 IMS 조건은 참이 되고, GET 요청은 평범하게 성공함
  - 새 문서가 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환됨
- 문서가 주어진 날짜 이후에 변경되지 않았다면 IMS 조건은 거짓이 되고, 서버는 작은 304 Not Modified 응답을 돌려줌
  - 응답 헤더들은 갱신이 필요한 것만 갱신해서 보내줌

<br>

- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작함
  - 원 서버는 제공하는 문서에 최근 변경 일시를 붙여줌
- 몇몇 웹 서버는 IMS를 실제 날짜 비교 대신 변경일 간의 문자열 비교로 수행하는 경우도 있음
  - '이 날짜 이후 변경되었다면'이 아닌, '정확히 이 날짜가 마지막 변경일이 아니라면'
  - 예를 들면 일련번호 같은 것을 최근 변경 일시로 사용하는 경우
  - IMS 헤더를 시간에 대한 값으로 활용할 수는 없겠지만, 캐시 만료 관련 동작에는 문제가 없음

### 8.6 If-None-Match: 엔티티 태그 재검사

- 최근 변경 일시 재검사가 어려운 상황들
  - 어떤 문서는 일정 시간 간격으로 다시 쓰여지는데, 실제로는 같은 데이터를 포함하는 경우
  - 철자나 주석의 변경 등 캐시가 데이터를 다시 읽어들이기에는 너무 사소한 변경일 경우
  - 어떤 서버들은 그들의 페이지에 대한 최근 변경 일시를 정확히 판별할 수 없음
  - 1초보다 적은 간격으로 갱신되는 문서들은, 1초의 정밀도가 충분하지 않을 수 있음

![if-none-match](https://user-images.githubusercontent.com/75058239/200953520-19074d75-2744-4af4-8bb2-f5b00242b307.jpeg)

- 퍼블리셔는 문서 변경 후, 문서의 엔티티 태그를 새로운 버전으로 표현할 수 있음
- If-None-Match 헤더에 일치 여부를 확인하고 싶은 엔티티 태그를 담아서 보내면, 서버는 ETag 헤더와 함께 응답을 보내줌
  - 일치한다면 304 Not Modified 응답을 같은 엔티티 태그를 가진 ETag 헤더와 함께 반환
  - 엔티티 태그가 변경되었다면 200 OK와 함께 변경된 엔티티 태그를 가진 ETag 헤더와 함께 반환
- 캐시가 객체에 대한 여러 사본을 갖고 있는 경우, If-None-Match 헤더에 여러 개의 엔티티 태그를 포함시킬 수 있음

```
If-None-Match: "v2.4","v2.5","v2.6"
If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
```

### 8.7 약한 검사기와 강한 검사기

- 최근 변경일시와 엔티티 태그는 둘 다 캐시 검사기
- 서버는 때때로 모든 캐시 사본을 무효화하지 않고 문서를 살짝 고치고 싶은 경우가 있음
- 이에 HTTP/1.1은 컨텐츠가 조금 변경되어도 "그 정도면 같은 것"이라고 서버가 주장할 수 있도록, **weak validator**를 지원함
  - **strong validator**는 컨텐츠가 바뀔 때마다 변경 여부를 갱신함
  - **weak validator**는 어느 정도 컨텐츠 변경을 허용하지만, 중요한 의미가 변경되면 변경 여부를 갱신함
- weak validator는 조건부 요청 헤더의 값에 `W/` 접두사를 붙여서 구분하도록 함

```
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

### 8.8 언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP/1.1 클라이언트는 만약 서버가 엔티티 태그를 반환했다면 반드시 엔티티 태그 검사기를 사용해야 함
- 만약 서버가 Last-Modified 값만을 반환했다면 클라이언트는 IMS 검사를 사용할 수 있음
- 만약 IMS와 엔티티 태그 모두 사용 가능하다면,<br>HTTP/1.0과 HTTP/1.1 명세상 모두 적절히 응답하도록 두 가지 재검사 정책을 모두 사용해야 함
  - 강한 엔티티 태그 검사 대신 약한 엔티티 태그 검사를 활용할 순 있음
  - HTTP/1.1 캐시나 서버가 IMS와 엔티티 태그 조건부 헤더 둘 다 받았다면,<br>모든 조건부 헤더가 조건에 부합해야만 304 Not Modified 응답을 반환할 수 있음

<br>

## 9. 캐시 제어

- HTTP 명세는 서버가 캐시를 얼마 오래 지속할 것인지 설정할 수 있는 여러 가지 방법을 정의함

### 9.1 no-cache와 no-store 응답 헤더

- no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시 객체로 응답하는 것을 막아줌

```
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

- `no-store` : 캐시가 응답의 사본을 만드는 것을 금지
  - 캐시는 프록시 서버처럼 no-store 응답을 전달하고 나면 해당 객체를 삭제
- `no-cache` : 로컬 캐시 저장소에 저장할 순 있지만 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공할 수 없음
- `Pragma: no-cache` : HTTP/1.0+와의 호환성을 위한 것

### 9.2 Max-Age 응답 헤더

- `Cache-Control: max-age` 헤더는 신선하다고 간주된 문서가 서버로부터 온 이후로 흐른 시간이며, 초로 표현됨
  - `s-maxage`는 공용 캐시에만 적용됨

```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

- maximum aging 값을 0으로 설정함으로써, 캐시가 매 접근마다 캐시를 하지 않거나 혹은 refresh 하도록 요청할 수 있음

### 9.3 Expires 응답 헤더

- deprecated 헤더
- 초 대신 만료 날짜를 명시함
- 신선도 수명의 근사값은 만료일과 생성일의 초 단위 시간차를 계산해서 얻을 수 있음

```
Expires: Fir, 05 Jul 2002, 05:00:00 GMT
```

### 9.4 Must-Revalidate 응답 헤더

- 캐시는 성능 개선을 위해 신선하지 않은 객체를 제공하도록 설정될 수 있음
- 만약 캐시가 만료 정보를 엄격히 따르길 원한다면, 원 서버는 다음 헤더를 추가해줄 수 있음

```
Cache-Cotrol: must-revalidate
```

- 위 응답 헤더는 신선하지 않은 사본을 원 서버와의 최초 재검사 없이는 제공할 수 없음을 의미함
- 만약 캐시가 must-revalidate 신선도 검사를 시도했을 때 원 서버가 사용 불가라면<br>캐시는 반드시 504 Gateway Timeout error를 반환해야 함

### 9.5 휴리스틱 만료

- 만약 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않는다면<br>캐시는 경험적인 방법으로(heuristic) 최대 나이를 계산할 것
- 어떤 알고리듬이든 사용 가능하지만 계산 결과 maximum aging이 24시간보다 크다면<br>Heuristic Expriation 경고(경고 13) 헤더가 응답 헤더에 추가되어야 함
  - 이 경고 정보를 사용자에게 출력해주는 브라우저는 거의 없음
- LM 인자 알고리듬
  - 유명한 휴리스틱 만료 알고리듬 중 하나
  - 문서가 최근 변경 일시를 포함하고 있다면 사용 가능
  - 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정을 위해 사용
  - 만약 최근 변경 일시가 오래 전이라면 변경 가능성도 그리 크지 않으니 캐시에 더 오래 보관하도록 함
  - 반대로 최근 변경 일시가 오래되지 않았다면 변경 가능성도 크므로 짧은 기간 동안만 캐시해야 함

※ LM 알고리듬에 대한 펄 pseudocode

```perl
$마지막_수정_이후_경과시간 = max(0, $서버_Date - $서버_Last_Modified);
$서버_신선도_한계 = int($마지막_수정_이후_경과시간 * $lm_인자);
```

![LM 인자 알고리듬](https://user-images.githubusercontent.com/75058239/201102166-833537c6-8b11-4f7e-8fa8-ca5ecb3b0279.PNG)

- 일반적으로 사람들은 휴리스틱 신선도 유지기간에 상한을 설정함
  - 보통 1주일로 하지만, 보수적인 경우 하루로 설정하기도 함
- 만약 최근 변경일조차 없고, 캐시가 신선도에 대한 아무런 단서도 얻을 수 없을 때는 default 값을 설정함 (보통 1시간 or 하루)
  - 보수적인 경우 휴리스틱 문서들에 대해 0의 신선도 수명을 설정함
- 휴리스틱 신선도 계산은 생각보다 흔히 수행됨
  - 많은 원 서버들이 아직도 Expires와 max-age 헤더를 생성하지 못함
  - 그러므로 캐시 만료 기본값을 신중하게 선택해야 함

### 9.6 클라이언트 신선도 제약

- 브라우저의 refresh나 reload 버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜서 강제로 재검사하고 문서를 가져옴
- 클라이언트는 Cache-Control 요청 헤더를 사용해서 만료 제약의 강도를 조절할 수 있음

|                           지시어                            | 목적                                                                                                                           |
| :---------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------- |
| Cache-Control: max-stale<br>Cache-Control: max-stale = \<s> | 신선하지 않은 문서도 자유롭게 제공 가능<br>매개변수가 지정되면 매개변수 값만큼 지난 문서도 받아들임<br>캐싱 규칙을 느슨하게 함 |
|               Cache-Control: min-fresh = \<s>               | 클라이언트는 지금으로부터 s초 후까지 신선한 문서만을 받아들임<br>캐싱 규칙을 엄격하게 함                                       |
|                Cache-Control: max-age = \<s>                | 캐시는 s초보다 오래된 캐시 문서를 반환할 수 없음<br>max-stale과 함께 사용되지 않는 이상, 캐싱 규칙을 엄격하게 함               |
|         Cache-Control: no-cache<br>Pragma: no-cache         | 클라이언트는 캐시된 리소스를 재검사하기 전에는 받아들이지 않을 것                                                              |
|                   Cache-Control: no-store                   | 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 함<br>문서에 민감한 정보가 있을 경우 사용                                 |
|                Cache-Control: only-if-cached                | 클라이언트는 캐시에 들어있는 사본만을 원함                                                                                     |

### 9.7 주의할 점

- 문서 만료는 완벽한 시스템이 아님
- 유효기간을 까마득한 미래로 설정해버리면 어떤 변경도 캐시에 반영되지 않을 것
  - DNS와 같은 인터넷 프로토콜에서도 사용되는 TTL 기법의 한 형식인데,<br>HTTP는 만료일을 덮어쓰고 강제로 reload하는 메커니즘을 제공하기는 함
- 유효기간을 길게 잡거나 아예 설정도 하지 않는 경우에 주의해야 함

<br>

## 10. 캐시 제어 설정

- 웹 서버들은 캐시 제어 및 만료 HTTP 헤더들을 각기 다른 메커니즘으로 설정함
- 이번 절에서는 유명한 아파치 웹 서버가 캐시 제어를 어떻게 지원하는지 간략히 살펴볼 것
  - 구체적인 상세는 웹 서버 공식문서 참조

### 10.1 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 캐시 제어 헤더를 설정할 수 있는 여러 메커니즘을 제공함
- 메커니즘들 중 많은 것들이 default로 설정되어 있지 않으니, 일단 활성화시킬 필요가 있음
- 어떤 경우에는 아파치 확장 모듈이 필요함

**mod_headers**

- 개별 헤더들을 설정할 수 있게 해주는 모듈
- 지시어를 활용해서 아파치 설정 파일에 설정을 추가할 수 있음
- 개별 컨텐츠에 헤더들을 연결하기 위해 아파치의 정규식과 필터를 조합해서 사용할 수 있음

※ 디렉토리 내 모든 HTML 파일이 캐시되지 않도록 설정하는 예시

```html
<Files *.html> Header set Cache-Control no-cache </Files>
```

**mod_expires**

- 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공해주는 모듈
- 마지막 접근일 혹은 수정일 이후의 일정 시한으로 유효기간을 설정할 수 있게 해줌
- 파일 종류별로 다른 만료 날짜를 설정할 수 있음

```
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
```

**mod_cern_meta**

- HTTP 헤더들의 파일을 특정 객체와 연결시켜주는 모듈
- 제어하고자 하는 파일 각각에 대응되는 메타파일들을 생성하게 됨
  - 각 메타파일에 원하는 헤더를 추가하면 됨

### 10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용함
- HTML 2.0은 `<META HTTP-EQUIV>` 태그를 통해,<br>웹 서버 설정과의 상호작용 없이도 손쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있게 함
  - 이 선택적 태그는 HTML 문서의 최상단에서 문서와 연동되어야 하는 HTTP 헤더들을 정의함

※ HTML 문서를 캐시하지 않도록 설정하는 \<META HTTP-EQUIV> 태그 예시

```html
<head>
  <title>My Document</title>
  <meta http-equiv="Cache-control" content="no-cache" />
</head>
```

- 이 태그는 원래 웹 서버에서 사용되도록 의도된 것
- 웹 서버가 이 태그를 파싱하여 HTTP 응답에 정해진 헤더를 삽입할 수 있게 함
  - RFC 1866에 정의되어 있음
- 불행히도 이 기능을 지원하는 웹 서버나 프록시는 거의 없음
  - 서버의 부하를 가중시키고, 설정값이 정적이고, HTML 외 다른 파일을 지원하지 않기 때문
- 몇몇 브라우저는 이 태그를 파싱하고 실제 HTTP 헤더처럼 다루지만 이는 불행한 일
  - 이 태그를 지원하면 오히려 중간의 프록시 캐시와는 다른 캐시 제어 규칙을 적용할 것이기 때문
- 일반적으로 `<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어하는 서투른 방법
  - 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것

<br>

## 11. 자세한 알고리듬

- HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 자세하고도 어려운 알고리듬들을 제공함
- 캐시 내부에 대한 일을 하는 분들에게 가장 유용할 것
  - 캐시 만료 공식의 적나라한 세부사항에 관심이 없다면 건너뛰어도 좋음

### 11.1 나이와 신선도 수명

- 캐시 문서가 제공되기에 충분히 신선한지 알려면 단 두 가지 값만 계산하면 됨
  - 캐시 사본의 나이, 신선도 수명
- 캐시 사본의 나이가 신선도 수명보다 작으면 사본을 제공하기에 충분히 신선한 것

```perl
$충분히_신선한가 = ($나이 < $신선도_수명);
```

- 캐시 문서의 나이는 서버가 문서를 보내준 후 문서가 '나이를 먹은' 시간의 총합
- 캐시는 문서가 업스트림 캐시에서 왔는지 서버에서 왔는지 모를 수 있기에, 문서가 완전히 새롭다고 가정하지 못함
  - 그러므로 Age 헤더를 통해 명시적으로 계산하는 방법이 권장되고, 아니면 Date 헤더를 통해 계산해야 함
