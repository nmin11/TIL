- 시간이 지나면서 사람들은 더욱 복잡한 리소스(DB 컨텐츠나 동적 HTML 페이지)를 공유하기를 원했음
- HTTP 위에 다른 프로토콜을 얹으려 해도 우선 HTTP가 기본 구성 요소
  - HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됨
  - 애플리케이션 간에 서로 다른 프로토콜을 상호 운용하는 용도로도 사용됨

※ 이번 장에서 살펴볼 내용들

- 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
- 애플리케이션 인터페이스: 서로 다른 웹 애플리케이션이 통신하는 데 사용됨
- 터널: HTTP 커넥션을 통해서 HTTP가 아닌 다른 트래픽을 전송하는 데 사용됨
- 릴레이: 일종의 단순한 HTTP 프록시로, 한 번에 한 개의 홉에 데이터를 전달하는 데 사용됨

<br>

## 1. 게이트웨이

- 웹에 복잡한 리소스를 올려야 할 필요가 생겼음
  - 모든 리소스를 한 개의 애플리케이션으로 처리할 수 없다는 것이 분명해졌음
  - HTTP의 확장과 인터페이스가 사람들의 필요에 따라 발전
- 개발자들은 이 문제에 대한 해결책으로 **인터프리터** 같이 리소스를 받기 위한 경로 안내 역할을 하는 게이트웨이를 고안해냈음
- 게이트웨이: 리소스와 애플리케이션을 연결하는 역할 수행
  - 애플리케이션은 게이트웨이에게 요청할 수 있고, 게이트웨이는 이에 응답할 수 있음
  - 요청을 받고 응답을 보내는 포털 같이 동작
  - 동적 컨텐츠를 생성하거나 DB에 질의를 보낼 수 있음

<img width="637" alt="gateway magic" src="https://user-images.githubusercontent.com/75058239/201547188-51302fe8-a046-46bc-9d1e-3f929a8c0c4a.png">

- 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환함
  - HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속하게 해줄 수 있음

<img width="565" alt="웹 게이트웨이 예시" src="https://user-images.githubusercontent.com/75058239/201547201-9d0317ba-7110-41dc-a822-8ae06ea9f77e.png">

- 게이트웨이는 FTP URL을 가리키는 HTTP 요청을 수행할 수 있음
  - 게이트웨이는 FTP 서버에 적절한 명령을 전송
  - 클라이언트는 적절한 HTTP 헤더와 함께 HTTP를 통해서 문서를 받을 수 있음
- 게이트웨이는 암호화된 웹 요청을 SSL을 통해 받고 해독해서 생성한 일반 HTTP 요청을 목적지 서버에 전달할 수 있음
  - 이 경우 게이트웨이에 해당 서버에 대한 인증서가 설치되어 있어야 함
  - 이러한 보안 가속기는 원 서버에 고성능 암호화 기능을 제공하기 위해 웹 서버 바로 앞단에 위치시킴
- 게이트웨이는 애플리케이션 서버 게이트웨이 API를 통해서 클라이언트를 서버 측 애플리케이션 프로그램과 연결할 수 있음
  - 물건을 구입하거나, 일기예보를 보거나, 주식시세를 볼 때, 사실은 애플리케이션 서버 게이트웨이를 방문하는 것

### 1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

- 게이트웨이의 양쪽 끝은 서로 다른 프로토콜로 통신함
- 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 `/`으로 구분해서 기술함

```
<클라이언트 프로토콜>/<서버 프로토콜>
```

- 만약 게이트웨이가 HTTP 클라이언트와 NNTP 뉴스 서버 사이에 있다면 `HTTP/NNTP` 게이트웨이가 되는 것
- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와 외래 프로토콜로 통신함
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신함

<br>

## 2. 프로토콜 게이트웨이

- 프록시에 트래픽을 바로 보내듯 게이트웨이에도 트래픽을 바로 보낼 수 있음
- 보통 브라우저에 명시적으로 게이트웨이를 설정하거나, 대리 서버(리버스 프록시)로 설정함
- FTP와 같은 특정 프로토콜에 대해 HTTP/FTP 게이트웨이를 설정해서,<br>브라우저가 HTTP 명령을 보내면 게이트웨이는 FTP 요청으로 변환하여 처리하고, 결과를 HTTP로 전송함

![프로토콜 게이트웨이](https://user-images.githubusercontent.com/75058239/201776279-02e6e24e-8aee-43a0-bfb5-f3581b6fbd00.png)

### 2.1 HTTP/\* : 서버 측 웹 게이트웨이

<img width="498" alt="서버 측 웹 게이트웨이" src="https://user-images.githubusercontent.com/75058239/201776326-da1e48dc-382e-4c69-8374-528606192e31.png">

- HTTP 요청이 원 서버로 들어오는 시점에 HTTP 요청을 외래 프로토콜로 전환함
- 수행하는 작업
  - USER와 PASS 명령을 보내서 서버에 로그인
  - 서버상 적절한 디렉토리를 찾기 위해 CWS 명령을 내림
  - 다운로드 형식을 ASCII로 설정
  - MDTM으로 문서의 최근 수정 시간을 가져옴
  - PASV로 서버에게 수동형 데이터 검색을 하겠다고 전달
  - RETR(RETRIEVE) 명령으로 객체 검색
  - 제어 채널에서 반환된 포트로 커넥션을 맺고, 객체를 게이트웨이로 받아옴

### 2.2 HTTP/HTTPS : 서버 측 보안 게이트웨이

<img width="500" alt="보안 게이트웨이" src="https://user-images.githubusercontent.com/75058239/201776362-25777403-4c5b-42f8-8403-58a9d4f3e97b.png">

- 기업 내부의 모든 웹 요청을 암호화해서 개인 정보 보호와 보안을 제공하는 데에 게이트웨이를 사용할 수 있음
- 클라이언트는 HTTP를 사용할 수 있지만 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것

### 2.3 HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이

<img width="498" alt="보안 가속 게이트웨이" src="https://user-images.githubusercontent.com/75058239/201776384-d89a6716-3a89-46c9-9d1c-fe604350419a.png">

- 웹 서버 앞단에서 보이지 않는 인터셉트 게이트웨이나 리버스 프록시 역할 수행
- 보안 HTTPS 트래픽을 받아서 복호화하고 웹 서버로 보낼 일반 HTTP 요청을 만듦
- 원 서버보다 더 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 함
- 게이트웨이와 서버 사이에는 확실한 네트워크 안전 보장이 필요함

<br>

## 3. 리소스 게이트웨이

- 여기까지 클라이언트와 서버를 연결하는 게이트웨이에 대해 이야기했음
- 그러나 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 하나의 서버로 결합함
  - 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이

![리소스 게이트웨이](https://user-images.githubusercontent.com/75058239/202045705-6ad30f74-7cbb-4dda-9855-d7013fa7f50e.png)

- 애플리케이션 서버는 게이트웨이의 API(Application Programming Interface)를 통해<br>요청을 서버에서 동작하고 있는 애플리케이션에 전달
- CGI(Common Gateway Interface) : 애플리케이션 게이트웨이에서 유명했던 최초의 API
  - 특정 URL에 대한 HTTP 요청에 따라 프로그램 실행, 출력 수집, HTTP 응답으로 회신하는,<br>웹 서버가 사용하는 표준화된 인터페이스 집합
- 웹 서버는 지금까지도 게이트웨이의 인터페이스를 구현하는 단순한 접근 방식을 이어오고 있음
- 게이트웨이를 통해야만 받을 수 있는 요청이 들어온 경우, 서버는 헬퍼 애플리케이션을 생성해서 요청을 처리함

### 3.1 CGI

- CGI는 최초이면서 지금까지도 가장 널리 쓰이는 서버 확장
- 웹에서 동적 HTML, 신용카드 결제, DB 질의 등을 제공하는 데에 사용됨
- CGI 애플리케이션은 서버와 분리되면서 수많은 언어로 구현할 수 있게 되었음
- 또한 CGI는 단순하므로 거의 모든 HTTP 서버가 지원함
- CGI의 내부 처리 과정은 사용자에게 보이지 않음
  - CGI가 무언가를 하고 있다는 것을 알 수 있는 유일한 단서는 URL에 있는 `cgi` 혹은 `?` 키워드
- CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서, 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공함
  - 확장으로부터 서버를 보호한다는 점에서는 훌륭함
- 하지만 이러한 분리 때문에 성능 관련 비용이 발생함
  - 모든 CGI 요청마다 새로운 프로세스를 만들면서 따르는 부하가 꽤 큼
- 문제점을 개선하고자 새로운 CGI 형식인 Fast CGI가 개발되었음
  - CGI와 유사하지만 데몬으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거함

### 3.2 서버 확장 API

- 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스, 서버 확장 API가 필요한 2가지 이유
  - 서버 자체의 동작을 바꾸고 싶음
  - 서버의 처리능력을 최고치로 올리고자 함
- 유명 서버 대부분은 확장 API를 1개 이상 제공해줌
  - 이러한 확장은 서버 자체의 아키텍처에 의존함
- 예시: MS - FrontPage Server Extension(FPSE)
  - RPC 명령을 HTTP POST 메소드를 통해서 인식할 수 있음

<br>

## 4. 애플리케이션 인터페이스와 웹 서비스

- 애플리케이션 연결 시 까다로운 점은 두 애플리케이션 사이에 프로토콜 인터페이스를 맞추는 일
- 상호 운용 시 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있음
  - 나중 내용에서 HTTP 확장 및 HTTP 위에 프로토콜을 덧씌우는 방식에 대해 알아볼 것
- 인터넷 커뮤니티는 웹 애플리케이션이 통신하는데 사용할 표준 및 프로토콜 집합을 개발했음
- 이 표준은 그냥 웹 서비스라고 불리게 되었음
  - 사실은 독립형 웹 애플리케이션 그 자체를 의미함
- 웹 서비스는 애플리케이션이 정보를 공유하는 새로운 메커니즘으로, HTTP 같은 표준 웹 기술 위에서 개발됨
  - 웹 서비스는 SOAP를 통해 XML을 사용하여 정보를 교환함
  - XML(eXtensible Markup Language)은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공함
  - SOAP(Simple Object Access Protocol)은 HTTP 메시지에 XML 데이터를 담는 방식에 대한 표준
  - 현대 웹 서비스의 데이터 교환 방식은 SOAP보다 REST 방식을 더 많이 사용하며, 데이터 포맷도 XML보다는 JSON을 주로 사용함

<br>

## 5. 터널

- HTTP의 또다른 방식, 웹 터널
- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해서 접근하는 방법을 제공함
- 다른 프로토콜을 HTTP 위에 올릴 수 있게 해줌
  - 웹 터널을 사용하는 가장 일반적인 이유
- 따라서 웹 터널을 사용하면 웹 트래픽만 허용하는 방화벽이 있어도 HTTP가 아닌 트래픽을 전송할 수 있음

### 5.1 CONNECT로 HTTP 터널 커넥션 맺기

- 웹 터널은 HTTP의 CONNECT 메소드를 사용해서 커넥션을 맺음
- CONNECT 메소드는 HTTP/1.1 명세에는 자세하게 나와 있지는 않지만 많이들 구현하는 확장
- CONNECT 메소드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 데이터를 무조건 전달하기를 요청

![CONNECT 헤더](https://user-images.githubusercontent.com/75058239/202281825-2d51449f-c2c3-4d52-85b8-5a8da141f57c.jpg)

- CONNECT 메소드는 모든 서버나 프로토콜에 TCP 커넥션을 맺는데 사용할 수 있음

**_CONNECT 요청_**

- 시작줄을 제외하고는 다른 HTTP 메소드와 같음
- 요청 URI는 호스트 명이 대신하고, `:` 뒤에 포트를 기술함

```
CONNECT home.netscape.com:443 HTTP/1.0
User-Agent: Mozilla/4.0
```

- 시작줄 다음에 HTTP 요청 헤더 필드가 있을 수도 있고 없을 수도 있음
- 각 행은 CRLF로 끝나고, 헤더 목록의 끝은 빈 줄의 CRLF로 끝남

**_CONNECT 응답_**

- 요청 이후 게이트웨이로부터 **200 Connection Established** 응답을 기다림

```
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
```

- Content-Type 헤더를 포함할 필요가 없음
  - 커넥션이 메시지 대신 byte를 그대로 전달하기 때문에 컨텐츠 형식이 불필요함

### 5.2 데이터 터널링, 시간, 커넥션 관리

- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없음
  - 게이트웨이는 패킷의 순서나 흐름에 대해 어떤 가정도 할 수 없게 됨
  - 터널 양 끝단에서 두 커넥션으로부터 언제든 패킷을 받을 준비를 해서, 데이터를 즉시 전달해야 함
    - 터널링된 프로토콜은 데이터 의존성을 포함하고 있거나 다른 데이터를 무시할 수도 있기 때문
- 클라이언트는 성능을 위해 CONNECT 요청 이후 응답을 받기 전에 터널 데이터를 전송할 수 있음
  - 이 방법은 게이트웨이가 요청에 이어서 데이터를 적절하게 처리할 수 있어야 함을 전제로 함
  - 특히 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만 반환할 것이라 가정할 수 없고<br>커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 데이터를 모두 서버에 전송해야 함
- 클라이언트는 authentication challenge나 200 외 응답이 왔을 경우 요청 데이터를 다시 보낼 준비가 되어 있어야 함
  - TCP 요청 패킷 영역을 넘어서는 큰 데이터를 파이프라인을 통해 전달하지 말아야 함
  - 게이트웨이가 파이프라인을 통해 모든 TCP 패킷을 받기 전에 커넥션을 끊었을 때, TCP 리셋을 일으킬 수 있음
  - TCP 리셋은 응답을 잃게 해서 통신 실패에 대한 원인이 네트워크 에러 때문인지 접근 제어나 인증요구 때문인지 알 수 없게 됨

### 5.3 SSL 터널링

- 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하기 위해 개발되었음
- 많은 회사가 강력한 보안을 위해 모든 트래픽이 패킷을 필터링하는 라우터와 프록시를 지나게 했음
  - 하지만 SSL 같이 암호화된 프로토콜은 낡은 방식의 프록시에서 처리되지 않았음
  - 터널을 사용해서 SSL 트래픽을 80 포트의 HTTP만을 허용하는 방화벽을 통과하도록 할 수 있음

<img width="599" alt="SSL 터널링" src="https://user-images.githubusercontent.com/75058239/202281885-eb256f11-0db2-4b8e-b64c-470404ffddef.png">

- 이 터널링 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송함

![터널링된 SSL 커넥션](https://user-images.githubusercontent.com/75058239/202281926-001ee61d-3da9-4257-81af-012f7875e03c.png)

- 직접 SSL 커넥션을 사용하는 경우, SSL 트래픽이 443포트를 통해 바로 전송됨
- 터널링된 SSL 커넥션을 사용하는 경우, SSL 트래픽은 SSL 커넥션에 오기 전까지는 80포트를 거쳐서 전송됨
- 터널은 비 HTTP 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해줌
- 하지만 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있음
  - 일종의 치트키인가?

### 5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTPS 프로토콜(SSL상의 HTTP)은 터널 없이도 게이트웨이를 통과할 수 있음
  - 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 HTTPS 트랜잭션을 수행하는 방식
  - 응답은 프록시가 받아서 복호화하고, HTTP를 통해 클라이언트로 전송함
- 위 방식은 게이트웨이가 FTP를 처리하는 방식과도 같지만, 몇 가지 단점이 존재함
  - 클라이언트와 게이트웨이 사이에는 보안이 적용되지 않는 HTTP 커넥션이 맺어져 있음
  - 프록시가 인증을 담당하고 있기에, 클라이언트는 원 서버에 SSL 클라이언트 인증을 할 수 없음
  - 게이트웨이가 SSL을 완벽히 지원해야 함
- 하지만 이 상황에서 SSL 터널링을 사용하면 프록시에 SSL을 구현할 필요가 없음
  - 프록시 서버는 트랜잭션의 보안에 관여하지 않고, 암호화된 데이터를 그대로 터널링할 뿐

### 5.5 터널 인증

- 프록시 인증 기능은 터널 사용에 대한 권한을 검사하는 용도로 터널에서 사용될 수 있음
  - 인증이 필요한 경우, 407 Proxy authentication required 응답이 돌아옴
  - 클라이언트는 Proxy-authorization 헤더가 포함된 CONNECT 요청으로 인증할 수 있음

### 5.6 터널 보안에 대한 고려사항들

- 터널 게이트웨이는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음
- 예시
  - 회사 직원이 회사 방화벽에 터널을 열고 게임을 할 수 있음
  - 악의적인 사용자가 회사에 텔넷 세션을 열거나 이메일 차단 장치를 우회할 수 있음
- 이러한 오용을 최소화하기 위해, 게이트웨이는 HTTPS 전용 포트인 443 같이, 잘 알려진 특정 포트만을 터널링하도록 허용해야 함

<br>

## 6. 릴레이

HTTP 릴레이: HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프록시

- 릴레이는 커넥션을 맺기 위한 HTTP 통신 이후, byte를 맹목적으로 전달함
- 단순 필터링이나 컨텐츠 변환을 위해 사용되기도 함
- 하지만 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 각별히 주의해서 배포해야 함
- 악명 높은 문제 중 하나는 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해 keep-alive 커넥션이 hang에 걸리는 사태

![hang](https://user-images.githubusercontent.com/75058239/202282119-e677ef82-e456-43ff-8ad0-1139ef700792.png)

- Connection 헤더는 hop-by-hop에서 사용되는 헤더이므로, 릴레이가 이해하지 못하게 됨
- 릴레이는 keep-alive 규칙에 맞는 동작을 할 수 없고, 그래서 클라이언트와 서버는 서로 지속 커넥션을 맺고 있다고 믿게 되어버림
- 단순 HTTP 릴레이를 구축한다면, 이를 어떻게 사용할지 신중하게 고민해봐야 함
  - HTTP를 제대로 준수하는 프록시를 사용하는 것이 좋음
