- HTTP 성능 문제를 개선하기 위해, HTTP/2.0 제작 과정이 진행 중임
- 이번 장에서는 HTTP/2.0을 만들게 된 배경, HTTP/1.1과의 주요 차이점, 보안 이슈에 대해서 다룰 것

<br>

## 1. HTTP/2.0의 등장 배경

- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었음
- 그러다 보니 어느 정도의 성능 희생이 있었음
  - 요청 하나에 대해 응답 하나를 받는 단순성은 좋았지만,<br>응답을 받아야만 다음 요청을 할 수 있었기 때문에 심각한 회전 latency를 피할 수 없었음
  - 병렬 커넥션이나 파이프라인 커넥션도 근본적인 해결책이 되지는 못했음
- HTTP 작업 그룹은 HTTP/1.1이 발표되기도 전인 1997년 7월에 HTTP-NG 프로젝트를 시작했음
  - Roy Fielding은 WAKA 프로토콜을 제안했고, MS는 Microsoft S+M 프로토콜 개발을 시작했음
- 한펀 구글은 웹을 더욱 빠르게 하겠다는 목표 아래 2009년 SPDY 프로토콜을 내놓았음
  - 헤더를 압축해서 대역폭을 절약
  - 하나의 TCP 커넥션에 여러 요청을 동시에 보내서 회전 latency를 줄임
  - 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 있음
  - https://www.chromium.org/spdy/spdy-whitepaper/

※ SPDY 적용시 RTT(Round-trip delay time) 별 성능 개선 효과

![SPDY 적용시 RTT 별 성능 개선도](https://user-images.githubusercontent.com/75058239/204066038-ce61c0e4-aae3-4244-b1a5-150ab0cf612a.png)

- 마침내 2012년 10월 3일, HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정

<br>

## 2. 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작
  - TCP 커넥션을 초기화하는 것은 클라이언트
- 요청과 응답은 길이가 최대 16,383 Byte로 정의된 한 개 이상의 프레임에 담김
  - 이 때 HTTP 헤더는 압축되서 담김
- 프레임들에 담긴 요청과 응답은 스트림을 통해 보내짐
  - 한 개의 스트림이 한 쌍의 요청과 응답을 처리
  - 하나의 커넥션 위에 여러 개의 스트림이 있을 수 있기에, 여러 개의 요청과 응답 동시 처리 가능
  - HTTP/2.0은 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공
- 기존의 요청-응답과는 다르게 새로운 상호작용을 하는 모델, **서버 푸시** 도입
  - 서버는 클라이언트에게 필요하다고 생각되는 리소스를 요청 없이 능동적으로 보내줄 수 있음
- 기존 웹 애플리케이션들과의 호환성을 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있음
  - 다만 `Content-Length` 헤더는 `:content-length` 헤더로, 상태 코드는 `:status` 헤더로 바뀌는 등 표현 방식이 조금 달라졌음

<br>

## 3. HTTP/1.1과의 차이점

### 3.1 프레임

(이미지 첨부 - HTTP 2.0 프레임)

- HTTP/2.0에서 모든 메시지는 프레임에 담겨서 전송됨
- 모든 프레임은 8 Byte 크기의 헤더로 시작하고, 뒤이어 최대 16,383 Byte 크기의 페이로드가 옴
- 프레임 헤더의 필드들
  - R: 예약된 2 bit 필드, 값의 의미가 정의되어 있지 않고 반드시 0이어야 함, 받는 쪽에서 이 값을 무시해야 함
  - 길이: 페이로드의 길이를 나타내는 14 bit의 unsigned integer, 프레임 헤더의 길이는 포함되지 않음
  - 종류: 프레임의 종류
  - 플래그: 8 bit 플래그, 값의 의미는 프레임 종류에 따라 다름
  - R: 예약된 1 bit 필드, 첫 R과 같이 의미가 없고 0이어야 하며 받는 쪽에서 무시해야 함
  - 스트림 식별자: 31 bit 스트림 식별자, 특별히 0은 커넥션 전체와 연관된 프레임이라는 의미를 내포
- 프레임 종류
  - DATA, HEADERS, PRIORITY, RST_STREAM, SETTING, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION 총 10가지
  - 페이로드의 형식이나 내용은 이 프레임 종류에 따라 달라짐

### 3.2 스트림과 멀티플렉싱

- 스트림: HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어짐
  - 클라이언트는 새 스트림을 만들고 그를 통해 HTTP 요청을 보냄
  - 요청 받은 서버는 같은 스트림으로 응답을 보냄
  - 그 이후에는 스트림이 닫히게 됨
- HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보내면, 응답이 돌아와야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있음
  - 따라서 웹 브라우저들은 회전 지연을 줄이기 위해 여러 TCP 커넥션을 만들고 동시에 여러 요청을 보내는 방법을 사용
  - 그렇다고 TCP 커넥션을 무한정 만들 수는 없기 때문에 회전 지연을 완전히 피하기는 어려움
  - 파이프라인 커넥션을 통해 회전 지연을 피할 순 있지만 그다지 널리 구현되어 있지 않음
- 반면에 HTTP/2.0에서는 하나의 커넥션에 여러 스트림이 동시에 열릴 수 있음
  - `SETTINGS` 프레임의 `SETTINGS_MAX_CONCURRENT_STREAMS` 매개변수 값을 조정해서 동시 스트림 갯수를 제한할 수 있음
  - 하나의 HTTP/2.0 커넥션을 통해 여러 요청을 동시에 보낼 수 있기 때문에 HTTP/1.1의 회전 지연 문제를 해결할 수 있음
- 게다가 스트림은 우선순위도 가질 수 있음
  - 예를 들어 네트워크 대역폭이 충분치 않은 경우 보다 중요한 리소스를 요청하는 스트림에게 우선순위를 부여할 수 있음
  - 그러나 우선순위에 따르는 것이 의무사항은 아니기 때문에, 요청이 우선순위대로 처리된다는 보장이 없음
- 모든 스트림은 31 bit의 무부호 정수로 된 고유 식별자를 가짐
  - 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수 / 반대로 서버가 초기화했으면 짝수
  - 새로 만들어지는 스트림 식별자는 이전의 식별자들보다 값이 커야 함
    - 이 규칙을 어기는 식별자를 받았다면 `PROTOCOL_ERROR` 커넥션 에러로 응답해야 함
- 서버와 클라이언트는 스트림을 만들 때 쌍방 협의 없이 일방적으로 만듦
  - 이는 스트림을 만들 때 협상을 위해 TCP 패킷을 주고받는 시간 낭비를 하지 않아도 된다는 뜻
- 한 번 사용한 스트림 식별자는 재사용 불가
  - 커넥션을 오래 지속하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 함
  - 이런 경우에는 커넥션을 다시 맺을 것
- 동시에 여러 스트림들을 사용하면 스트림이 블록될 우려가 있다는 주장이 있음
  - `WINDOW_UPDATE` 프레임은 flow control을 통해, 스트림이 서로 간섭해서 망가지는 것을 막아줌

### 3.3 헤더 압축

- HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송되었음
  - 과거에는 헤더의 크기가 그다지 큰 문제가 되진 않았기 때문
- 요즘에는 웹 페이지 하나를 보기 위해 수십에서 수백 번의 요청이 필요하기 때문에<br>헤더 크기가 회전 지연과 대역폭 양쪽 모두에 실질적 영향을 끼치게 되었음
  - [IETF83: SPDY and What to Consider for HTTP/2.0](http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3)
  - [SPDY: What I Like About You](http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html)
- HTTP/2.0에서는 헤더를 **HPACK 명세**에 정의된 헤더 압축 방법으로 압축한 뒤 '헤더 블록 조각들'로 쪼개서 전송
  - SPDY에서는 deflate 알고리듬으로 압축했지만<br>CRIME(데이터 압축을 노리는 HTTP 쿠키 탈취 공격)에 취약해서 HPACK을 사용하게 됨
- HPACK은 헤더를 압축하고 해제할 때 **compression context**를 사용함
  - 오작동하지 않기 위해 항상 올바른 압축 컨텍스트를 유지해야 함
  - 압축 컨텍스트는 수신한 헤더의 압축을 풀 때 영향을 받아서 바뀌게 됨
  - 송신 측은 수신 측이 헤더의 압축을 풀었고, 이에 따라 압축 컨텍스트가 바뀌었다고 가정할 것
  - 따라서 수신 측은 어떠한 경우에도 반드시 압축 해제를 수행해야 함
  - 수신 측이 압축 해제를 할 수 없다면 `COMPRESSION_ERROR`와 함께 커넥션을 끊어야 함

### 3.4 서버 푸시

- HTTP/2.0은 서버가 하나의 요청에 대한 응답으로 여러 개의 리소스를 보낼 수 있게 해줌
- 서버가 클라이언트에서 어떤 리소스를 요구할 것인지를 미리 알 수 있는 상황에서 유용
- 예를 들어, HTML 문서를 요청 받은 서버가 해당 문서의 링크된 이미지, CSS 파일, JS 파일 등의 리소스를 함께 푸시해서,<br>클라이언트가 필요한 리소스를 다시 요청하는 일이 없게 해줌
- 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 `PUSH_PROMISE` 프레임을 통해 알려야 함
  - 클라이언트가 `PUSH_PROMISE` 프레임을 받으면 해당 프레임의 스트림은 클라이언트 입장에서 '예약됨(원격)' 상태가 됨
  - 이 상태에서 클라이언트는 `RST_STREAM` 프레임을 보내서 푸시를 거절할 수 있음
    - `RST_STREAM` 전송 이후에는 해당 스트림이 즉각 닫히게 됨
  - 스트림이 닫히기 전에 클라이언트는 서버가 푸시하고자 하는 리소스를 요청해선 안됨
    - 서버 푸시를 하는 이유가 클라이언트의 불필요한 추가 요청을 피하기 위해서이기 때문

※ 주의 사항

- 서버 푸시를 사용하기로 했어도, 중간의 프록시가 추가 리소스를 클라이언트에게 전송하지 않을 수 있음
  - 반대로 프록시가 아무런 추가 리소스를 받지 않고도 클라이언트에게 추가 리소스를 전달할 수도 있음
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있음
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 함
  - 서버의 `PUSH_PROMISE` 프레임도 원 요청을 위해 만들어진 스트림을 통해서 보내져야 함
- 클라이언트는 서버가 푸시한 리소스를 **Same-origin policy**에 따라 검사해야 함
- 서버 푸시를 끄고 시다면 `SETTINGS_ENABLE_PUSH` 값을 0으로 설정할 것
