- HTTP 명세는 HTTP 커넥션과 HTTP 메시지의 흐름에 대한 내용은 충분히 다루고 있지 않음
- HTTP 애플리케이션을 개발하고 있다면 HTTP 커넥션에 대해 잘 이해해야 함
- HTTP 커넥션 관리는 실험이나 시행착오를 통해서 많은 것을 배울 수 있는 마술 같은 기술

<br>

## 1. TCP 커넥션

- 전 세계 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어짐
- 세계 어디서든 클라이언트 애플리케이션과 서버 애플리케이션은 TCP/IP 커넥션을 맺을 수 있음
- 일단 커넥션이 맺어지면 주고받는 메시지들은 손실되거나 손상되거나 순서가 뒤바뀌거나 하지 않고 안전하게 전달됨

![TCP IP 커넥션](https://user-images.githubusercontent.com/75058239/196821618-3b8bbb21-8bdf-405b-b268-dff12df2a4f8.png)

### 1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션에서 몇몇 사용 규칙을 빼면 TCP 커넥션이나 다름 없음
- 신속 정확하게 데이터를 보내고자 한다면 TCP의 기초적인 내용을 알아야 함
- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공
- TCP 커넥션 상에서 byte들은 순서에 맞게 정확하게 전달됨

### 1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 IP 패킷이라 불리는 작은 조각을 통해 데이터를 전송함

![HTTP HTTPS 네트워크 프로토콜 스택](https://user-images.githubusercontent.com/75058239/196821631-f9864cef-fbb4-4337-8ea1-2f97fb29b4b1.png)

- HTTP는 메시지를 전송할 때 연결되어 있는 TCP 커넥션을 통해서 메시지의 내용을 순서대로 보냄
- TCP는 세그먼트라는 단위로 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라 불리는 봉투에 담아서 전달함
- 위 과정은 TCP/IP 소프트웨어에 의해 처리되며, 그 과정은 HTTP 프로그래머에게 보이지 않음
- 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달되며 다음 요소들을 포함함
  - IP 패킷 헤더 (보통 20byte)
    - 발신지, 목적지 IP 주소, 크기, 기타 플래그를 가짐
  - TCP 세그먼트 헤더 (보통 20byte)
    - TCP 포트 번호, TCP 제어 플래그, 데이터 순서 무결성 검사를 위한 숫자 값
  - TCP 데이터 조각 (0 이상의 byte)

![IP 패킷](https://user-images.githubusercontent.com/75058239/197070500-5b777778-c408-4509-9d38-3d43ff521e47.png)

### 1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있고, TCP는 포트 번호를 통해서 커넥션을 유지함
- 포트 번호는 회사 직원의 내선전화와도 같음
  - 대표 전화번호는 안내 데스크로 연결되고 내선전화는 직원에게 연결되듯,<br>IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결됨
- TCP 커넥션은 4가지 값으로 식별함

```
<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
```

- 위 값들로 유일한 커넥션을 생성함

### 1.4 TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공함
- 소켓 API는 HTTP 프로그래머에게 TCP와 IP의 세부사항들을 감춰주고 주요 인터페이스를 보여줌
  - 유닉스 운영체제용으로 먼저 개발되었지만 지금은 대부분의 운영체제와 프로그래밍 언어에서 사용 가능

|         소켓 API 호출          | 설명                                                   |
| :----------------------------: | :----------------------------------------------------- |
|   `s = socket(<parameters>)`   | 연결되지 않은 익명의 새 소켓 생성                      |
|   `bind(s, <local IP:port>)`   | 소켓에 로컬 포트 번호와 인터페이스 할당                |
| `connect(s, <remote IP:port>)` | 로컬 소켓과 원격 호스트 및 포트 사이에 TCP 커넥션 생성 |
|        `listen(s, ...)`        | 로컬 소켓에서의 커넥션 허용                            |
|        `s2 = accept(s)`        | 로컬 포트에 커넥션이 맺어지기를 기다림                 |
|    `n = read(s, buffer, n)`    | 소켓으로부터 버퍼에 n byte 읽기 시도                   |
|   `n = write(s, buffer, n)`    | 소켓으로부터 버퍼에 n byte 쓰기 시도                   |
|           `close(s)`           | TCP 커넥션 완전 끊기                                   |
|     `shutdown(s, <side>)`      | TCP 커넥션 입출력만 닫음                               |
|      `getsockopt(s, ...)`      | 내부 소켓 설정 옵션값 읽기                             |
|      `getsockopt(s, ...)`      | 내부 소켓 설정 옵션값 변경                             |

- 소켓 API를 사용하면 TCP endpoint 데이터 구조를 생성하고, 원격 서버의 TCP endpoint에<br>생성된 endpoint를 연결해서 데이터 스트림을 읽고 쓸 수 있음
- TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림,<br>IP 패킷 간 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨겨줌

![TCP socket interface](https://user-images.githubusercontent.com/75058239/197070460-bcbb93f1-9465-4cdb-9b62-40c95e585d95.png)

<br>

## 2. TCP의 성능에 대한 고려

- HTTP 트랜잭션의 성능은 아래 계층인 TCP 성능에 영향을 받음
- 기본적인 TCP 성능의 특성을 이해함으로써 HTTP 커넥션 최적화 요소들을 더 잘 알게 되고,<br>더 좋은 성능의 HTTP 애플리케이션 설계 및 구현이 가능해짐
- TCP는 복잡한 주제이기 때문에 여기서는 TCP 성능에 대한 간략한 내용을 다루게 될 것

### 2.1 HTTP 트랜잭션 지연

![HTTP 트랜잭션이 처리되는 과정](https://user-images.githubusercontent.com/75058239/197311392-234ae9e1-bf67-4d24-bc2c-582f51eb4cda.jpg)

- 트랜잭션 처리 시간은 TCP 커넥션 설정, 요청 전송, 응답 전송에 비하면 상당히 짧음
- 클라이언트나 서버가 지나치게 많은 데이터를 처리하지 않는 한, 대부분의 HTTP 지연은 TCP 네트워크 때문에 발생

**HTTP 트랜잭션이 지연되는 여러 가지 원인들**

1. 클라이언트는 URI에서 웹 서버 IP 주소와 포트 번호를 알아내야 함<br>만약 URI에 있는 호스트에 방문한 적이 최근에 없다면 DNS resolution을 활용해서 호스트명을 IP 주소로 변환해야 함
2. 클라이언트는 TCP 커넥션 요청을 서버에 보내고 서버가 커넥션 허가 응답을 회신하기를 기다림<br>1초 미만으로 끝나지만 수백 개의 HTTP 트랜잭션이 만들어지면 소요시간이 크게 증가할 것
3. 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송<br>웹 서버는 TCP 커넥션에서 요청 메시지를 읽고 처리<br>전달 및 처리 과정에서의 시간 소모가 있음
4. 웹 서버가 HTTP 응답을 보내는 데에 시간 소모가 있음

- TCP 네트워크 지연은 하드웨어 성능, 네트워크 및 서버의 전송 속도, 요청 및 응답 메시지의 크기,<br>클라이언트와 서버 간의 거리에 따라 크게 달라짐
- TCP 프로토콜의 기술적인 복잡성도 지연에 영향을 끼침

### 2.2 성능 관련 중요 요소

**HTTP 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연들**

- TCP 커넥션의 핸드셰이크 설정
- 인터넷 혼잡 제어를 위한 TCP의 slow-start
- 데이터를 모아서 한번에 전송하기 위한 nagle 알고리듬
- TCP의 piggyback acknowledgment를 위한 확인응답 지연 알고리듬
- TIME_WAIT 지연 및 포트 고갈

### 2.3 TCP 커넥션 핸드셰이크 지연

- 새로운 TCP 커넥션을 열면 TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환함

![커넥션 핸드셰이크 지연](https://user-images.githubusercontent.com/75058239/197311396-2f786f99-caf4-4c8c-92bc-dd9d3adfc603.png)

**TCP 커넥션이 핸드셰이크를 하는 순서**

1. 클라이언트는 새 TCP 커넥션을 생성하기 위해 작은 TCP 패킷(보통 40~60 byte)을 서버에게 보냄<br>패킷은 '커넥션 생성' 요청이라는 뜻의 `SYN`이라는 특별한 플래그를 가짐
2. 서버는 커넥션에서 몇 가지 커넥션 매개변수를 산출하고,<br>커넥션 요청이 받아들여졌다는 의미의 `SYN`과 `ACK` 플래그를 포함한 TCP 패킷을 클라이언트에게 보냄
3. 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에 다시 확인응답 신호를 보냄<br>오늘날의 TCP는 클라이언트가 패킷과 함께 데이터도 보낼 수 있음

<br>

- HTTP 프로그래머는 이 패킷들을 보지 못함
  - 패킷들은 TCP 소프트웨어가 보이지 않게 관리함
  - HTTP 프로그래머가 보는 것은 새 TCP 커넥션이 생성될 때 발생하는 지연이 전부
- HTTP 트랜잭션이 아주 큰 데이터를 주고받는 경우가 아니라면 SYN/SYN+ACK 핸드셰이크가 눈에 띄는 지연을 발생시킴
  - 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 씀
- TCP의 ACP 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 큰 경우가 많고, 많은 HTTP 응답 메시지도 하나의 IP 패킷에 담길 수 있음
  - IP 패킷은 인터넷상에서 수백 byte 정도 되고 로컬상에서 1500 byte 정도 됨

### 2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않음
  - 인터넷 라우터는 과부하가 걸렸을 때 패킷을 마음대로 파괴할 수 있음
- 그러므로 TCP는 성공적인 데이터 전송을 보장하기 위한 자체적인 확인 체계를 가짐
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가짐
  - 각 세그먼트의 수신자는 세그먼트를 온전히 받았을 때 작은 확인응답 패킷을 송신자에게 반환
  - 송신자가 특정 시간 안에 확인응답 메시지를 받지 못하면 패킷이 파기되었거나 오류가 있다고 간주하고 데이터를 재전송
- 확인응답은 크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 **piggyback(편승)** 시킴
  - TCP는 송출 데이터 패킷과 확인응답을 하나로 묶음으로써 네트워크를 좀 더 효율적으로 사용함
  - 확인응답이 같은 방향으로 가는 편승의 경우를 늘리기 위해서, 많은 TCP 스택이 '확인응답 지연' 알고리듬을 구현함
  - 확인응답 지연은 송출할 확인응답을 특정 시간(보통 0.1~0.2초) 동안 버퍼에 저장해두고,<br>확인응답을 편승시키기 위한 송출 데이터 패킷을 찾아냄<br>만약 일정 시간 내에 송출 데이터 패킷을 찾지 못하면 확인 응답은 별도 패킷을 만들어서 전송함
- 안타깝게도 요청과 응답 2가지 형식만으로 이루어지는 HTTP 동작 방식은 편승의 기회를 감소시킴
  - 막상 편승할 패킷을 찾으려고 하면 해당 방향으로 송출될 패킷이 많지 않음 → 확인응답 지연 알고리듬으로 인한 지연이 자주 발생
  - 운영체제에 따라 다르지만, 확인응답 지연 관련 기능을 수정하거나 비활성화할 수 있음
- TCP 스택에 있는 매개변수를 수정할 때는 항상 잘 알고 수정해야 함
  - TCP 내부 알고리듬은 잘못 만들어진 애플리케이션으로부터 인터넷을 보호하도록 설계되어 있음
  - TCP 설정을 수정할 때 TCP 내부 알고리듬이 원치 않는 문제를 일으키지 않을 것이라고 확신할 수 있어야 함

### 2.5 TCP slow start

- TCP 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있음
- TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'됨
  - 처음에는 커넥션 최대 속도를 제한하다가, 데이터가 성공적으로 전송되면 속도 제한을 높여나감
  - 이러한 조율을 TCP slow start 라고 부름
  - 인터넷의 급작스러운 부하와 혼잡을 방지하는 용도
- TCP slow start는 TCP가 한번에 전송할 수 있는 패킷의 수를 제한함
  - 패킷이 성공적으로 전달되는 각 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있게 됨
  - 데이터의 양이 많은 경우, 1개의 패킷만 전송하고 확인응답을 받고, 2개의 패킷을 전송하고 확인 응답을 받고,<br>또 각각의 패킷에 대한 확인응답을 받으면 총 4개의 패킷을 받을 수 있는 셈인데,<br>이를 **opening the congestion window**라고 부름
- 새로운 커넥션은 이미 튜닝된 커넥션보다 느리기 때문에, HTTP에는 이미 존재하는 커넥션을 재사용하는 기능이 있음

### 2.6 Nagle 알고리듬과 TCP_NODELAY

- TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공함
- 각 TCP 세그먼트는 40byte 정도의 플래그와 헤더를 포함하여 전송하기 때문에,<br>지나치게 작은 데이터를 상당한 수의 패킷으로 나눠 전송하면 네트워크 성능은 크게 떨어짐
  - 1byte 크기의 패킷을 대량으로 전송하는 것을 *silly window syndrome*이라고 부르며,<br>이는 반사회적인 것이고 다른 인터넷 통신을 방해함
- Nagle 알고리듬은 만들어낸 John Nagle의 이름을 따서 만들어졌으며,<br>네트워크 효율을 위해 패킷 전송 이전에 많은 양의 TCP 데이터를 한 덩어리로 합침
  - RFC896, "Congestion Control in IP/TCP Internetworks"에 설명되어 있음
- Nagle 알고리듬은 세그먼트가 최대 크기(LAN 1500byte 정도, 인터넷상 수백 byte 정도)가 되지 않으면 전송하지 않음
  - 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기에 도달하지 못한 작은 패킷의 전송을 허락함
  - 다른 패킷들이 전송 중이라면 데이터는 버퍼에 저장됨
  - 패킷이 확인응답을 받았거나 전송하기 충분한 패킷이 쌓였을 때 버퍼에 저장되어 있던 데이터가 전송됨
- Nagle 알고리듬은 HTTP 성능과 관련된 여러 문제를 발생시킴
  - 크기가 작은 HTTP 메시지는 앞으로 생길지도 모르는 추가 데이터를 기다리며 지연됨
  - Nagle 알고리듬과 확인응답 지연 알고리듬을 함께 사용하면 형편없이 동작함
    - Nagle 알고리듬은 확인응답이 도착할 때까지 데이터 전송을 멈추고,<br>확인응답 지연 알고리듬은 확인응답을 100~200밀리초 지연시킴
- HTTP 애플리케이션은 성능을 위해서 HTTP 스택에 `TCP_NODELAY` 파라미터 값을 설정해서<br>Nagle 알고리듬을 비활성화하기도 함
  - 이 설정을 했다면 패킷이 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 함

### 2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT 포트 고갈은 성능 측정 시에 심각한 성능 저하를 일으키고, 실제 상황에서는 문제가 없음
  - 성능 측정을 하는 사람이라면 이 문제에 특별히 조심해야 함
  - 성능 측정 대상 서버는 클라이언트가 접속할 IP 주소 개수를 제한하고, 서버에 접속해서 부하를 발생시킬 컴퓨터 수는 적기 때문에
  - 일반적으로 서버는 기본 TCP 포트인 80번을 사용하기에, 가능한 연결의 조합이 제한됨
  - TIME_WAIT로 인해 순간순간 포트를 재활용하는 것이 불가능해짐

```
<클라이언트 IP, 발신지 포트, 서버 IP, 80>
```

※ 사용할 수 있는 발신지 포트는 제한되어 있고(6만개로 가정),<br>2MSL 동안 커넥션이 재사용될 수 없으므로 초당 500개로 커넥션이 제한됨<br>→ 서버가 초당 500개 이상의 트랜잭션을 처리할 만큼 빠르지 않으면 TIME_WAIT 포트 고갈은 일어나지 않음  
※ 이 문제를 해결하기 위해 부하를 생성하는 장비를 더 많이 사용하거나, 더 많은 커넥션을 위해 여러 가상 IP 주소를 사용할 수도 있음

- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면,<br>종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 control block에 기록해둠
  - 이 정보는 같은 주소와 포트 번호를 사용하는 새 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것
  - 보통 세그먼트 최대 생명주기의 2배 정도(2MSL, 보통 2분 정도)의 시간 동안 유지됨
- 현대의 빠른 라우터들 덕분에 커넥션이 닫힌 후 중복 패킷이 생기는 경우는 거의 없어졌음
  - 라우터가 매우 느렸을 때 중복 패킷의 복제본이 삭제되기 전까지<br>인터넷의 큐에 1분 넘게 보관되었기 때문에 최대 생명주기를 1분으로 정했던 것<br>2MSL이라는 용어의 유래도 여기에서 비롯됨
- 2MSL을 더 짧은 값으로 수정하는 운영체제도 있지만, 값 수정에 주의해야 함
  - 만약 이전 커넥션이 서로 같은 연결 값으로 생성된 커넥션에 삽입되면 패킷이 중복되고 TCP 데이터는 충돌함
- 포트 고갈 문제를 겪지 않더라도, 커넥션을 너무 많이 맺거나 control block이 너무 많아지는 상황을 주의해야 함

<br>

## 3. HTTP 커넥션 관리

- 앞의 두 절은 TCP 커넥션과 그로 인한 성능상의 영향을 다루었음
- 이번 절은 커넥션을 생성하고 최적화하는 HTTP 기술을 설명할 것

### 3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락함
- HTTP 메시지는 중개 서버들을 하나하나 거치면서 전달됨
- 어떤 경우에는 2개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있음
- HTTP **Connection** 헤더 필드는 커넥션 토큰을 `,`로 구분하여 가지고 있음
  - 해당 값들은 다른 커넥션에 전달되지 않음
  - 예를 들어, 메시지를 보낸 다음 끊어져야 할 커넥션은 `Connection: close`라고 명시할 수 있음
- Connection 헤더에는 3종류의 토큰이 전달될 수 있음
  - HTTP 헤더 필드 명은, 해당 커넥션에 대한 헤더들을 나열
  - 임시 토큰 값은, 커넥션에 대한 비표준 옵션을 의미
  - close 값은, 커넥션 작업이 완료되면 종료되어야 함을 의미
- 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면,<br>해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안됨
- Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 함
- Connection 헤더에는 **hop-by-hop** 헤더 명을 기술하는데, 이를 '헤더 보호하기'라고 부름

※ hop-by-hop: hop은 각 서버를 의미하며 hop-by-hop은 두 서버만 영향을 미치고 다른 서버에는 영향을 미치지 않음을 뜻함

![커넥션 헤더](https://user-images.githubusercontent.com/75058239/197367890-80daaf35-0d85-4281-b6ca-ada949b01429.png)

- HTTP 애플리케이션은 Connection 헤더와 함께 메시지를 받았을 때,<br>송신자에게서 온 요청에 기술되어 있는 모든 옵션을 적용함
  - 그리고 다음 hop에게 메시지를 전달하기 전에 Connection 헤더 및 그 안의 모든 헤더들을 삭제함
- Connection 헤더에 기술되지 않은 hop별 헤더도 있음
  - Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 등

### 3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안 좋아질 수 있음
  - 예를 들어 4개의 트랜잭션이 있을 때 각 트랜잭션이 새로운 커넥션을 필요로 한다면,<br>커넥션을 맺을 때 발생하는 지연과 함께 느린 시작 지연이 발생할 것

<img width="250" alt="순차 커넥션" src="https://user-images.githubusercontent.com/75058239/197367949-da963d19-d883-4583-a99a-d869dfa651d8.png">

- 단점
  - 사용자들은 웹페이지에서 이미지가 순차적으로 로드되는 것보다, 여러 이미지가 동시에 로드되는 방식이 더 빠르다고 느낄 것
  - 특정 브라우저의 경우 객체를 화면에 배치하기 전 객체의 크기를 알아야 하는데,<br>모든 객체를 다 내려받기 전에 알 방법이 없고, 따라서 텅 빈 화면을 보여주게 됨
- 그러므로 등장한, HTTP 커넥션의 성능을 향상시킬 수 있는 채신 기술들
  - **parallel 커넥션** : 여러 TCP 커넥션을 활용한 동시 요청
  - **persistent 커넥션** : 커넥션 맺음 및 끊기에서 발생하는 지연을 제거하기 위한 TCP 커넥션 재활용
  - **pipelined 커넥션** : 공유 TCP 커넥션을 통한 병렬 요청
  - **multiplexed 커넥션** : 요청과 응답들에 대한 중재 (실험적인 기술)
