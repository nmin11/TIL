- HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같음
- 이번 장에서는 HTTP 메시지를 어떻게 만들고 이해하는지 학습하게 될 것

<br>

## 1. 메시지의 흐름

- HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들
  - 데이터 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작
  - 그 다음에 선택적으로 데이터가 존재할 수 있음
- HTTP 메시지는 클라이언트, 서버, 프락시 사이를 흐름
  - '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어

### 1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- 인바운드와 아웃바운드는 트랜잭션 방향을 표현하기 위해 사용됨
  - 인바운드: 메시지가 원 서버로 향하는 것
  - 아웃바운드: 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것

### 1.2 다운스트림으로 흐르는 메시지

![http downstream](https://user-images.githubusercontent.com/75058239/196015297-4b1b1d87-2e5d-42a4-818b-0a8ef8dc9f16.png)

- HTTP 메시지는 강물과 같이 요청과 응답에 관계 없이 다운스트림으로 흐름
- 메시지 발송자는 수신자의 업스트림

<br>

## 2. 메시지의 각 부분

![http message](https://user-images.githubusercontent.com/75058239/196017394-4e440ecd-55ec-426f-a231-440b261b792b.png)

- 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함
- 시작줄, 헤더 블록, 본문 이렇게 3부분으로 이루어짐
  - 시작줄: 어떤 메시지인지 서술
  - 헤더 블록: 속성을 정의
  - 본문: 데이터를 담고 있음
- 시작줄과 헤더는 그냥 줄 단위로 분리된 ASCII 문자열
  - 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 2글자의 줄바꿈 문자열로 끝남
  - 줄바꿈 문자열은 **CRLF**라고 씀
- 본문은 선택적 데이터 덩어리
  - 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있음

### 2.1 메시지 문법

- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류됨
- 어떤 메시지인지에 따라서 메시지의 형식이 달라짐

※ 요청 메시지 형식

```
<method> <request URL> <version>
<header>

<body>
```

※ 응답 메시지 형식

```
<version> <status code> <reason phrase>
<header>

<body>
```

**method**

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있음

**request URL**

- 요청 대상이 되는 리소스를 지칭하는 URL
- 완전한 URL이 아니더라도 클라이언트와 서버가 직접 대화하고 있으면 대체로 문제가 없음
  - 서버는 URL에 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 수 있음

**version**

```
HTTP/<major>.<minor>
```

- 메시지에서 사용 중인 HTTP 버전
- 메이저와 마이너는 모두 정수

**status code**

- 요청 중에 무슨 일이 일어났는지 설명하는 3자리 숫자
- 첫 번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타냄

**reason phrase**

- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
- 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절
- 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재함
  - 예를 들어, 'HTTP/1.0 200 NOT OK'와 'HTTP/1.0 200 OK'는 동등하게 성공을 의미하는 것으로 처리되어야 함

**headers**

- 이름, `:`, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
- 헤더 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시함
- HTTP/1.1 같은 몇몇 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야만 유효한 것으로 간주

**entity body**

- 임의의 데이터 블록을 포함
- 모든 메시지가 엔티티 본문을 갖는 것은 아니므로, 그냥 CRLF로 끝나게 되는 경우도 있음

### 2.2 시작줄

- 요청 메시지의 시작줄: 무엇을 해야 하는지
- 응답 메시지의 시작줄: 무슨 일이 일어났는지

**요청줄**

- 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁함
- 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메소드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있음
- 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 알려주기 위해 HTTP 버전도 포함
- 위의 모든 필드들은 공백으로 구분됨

**응답줄**

- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
- HTTP 버전, 상태 코드, 사유 구절이 들어있음
- 위의 모든 필드들은 공백으로 구분됨

**method**

- 요청 시작줄은 메소드로 시작하면서, 서버에게 무엇을 해야 하는지 말해줌

※ 대표적인 HTTP 메소드들

| method  | description                                        | has body? |
| :-----: | :------------------------------------------------- | :-------: |
|   GET   | 서버에서 어떤 문서를 가져옴                        |     X     |
|  HEAD   | 서버에서 어떤 문서에 대한 헤더만 가져옴            |     X     |
|  POST   | 서버가 처리해야 할 데이터 전송                     |     O     |
|   PUT   | 서버에 요청 메시지의 본문 저장                     |     O     |
|  TRACE  | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적 |     X     |
| OPTIONS | 서버가 어떤 메소드를 수행할 수 있는지 확인         |     X     |
| DELETE  | 서버에서 문서를 제거                               |     X     |

- 위의 표는 모든 메소드들을 담은 것이 아니며,<br>HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에 해당 서버만의 메소드를 추가로 구현했을 수도 있음
  - 자기 서버만의 HTTP 메소드를 갖는 것은 HTTP 명세를 확장하는 것이기에 **확장 메소드**라고 부름

**status code**

- 메소드가 서버에게 무엇을 해야 할지 말해주듯, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해줌
- 응답의 시작줄에 위치함
  - 숫자로 된 코드와 문자열로 된 사유 구절을 함께 주기 때문에 이해하기 쉬움
- 클라이언트가 HTTP 서버에게 요청 메시지를 보낼 때 많은 일이 발생함
  - 운이 좋다면 요청은 완전히 성공할 것
  - 서버에서 요청한 리소스가 발견되지 않거나, 리소스 접근 권한이 없거나, 리소스가 옮겨졌다고 알려올 수도 있음

| 전체 범위 | 정의된 범위 |      분류       |
| :-------: | :---------: | :-------------: |
|  100-199  |   100-101   |      정보       |
|  200-299  |   200-206   |      성공       |
|  300-399  |   300-305   |   리다이렉션    |
|  400-499  |   400-415   | 클라이언트 에러 |
|  500-599  |   500-505   |    서버 에러    |

- 현재 HTTP 버전에서는 각 상태 분류에 대해 적은 수의 코드만을 정의했음
  - 프로토콜이 진화함에 따라 더 많은 상태 코드가 HTTP 명세에 공식적으로 정의될 것
- 누군가 프로토콜 확장으로 정의한 상태 코드를 받게 되는 경우도 있을 수 있음
  - 예를 들어, 상태 코드 515를 받게 되었다면 다른 5XX와 마찬가지로 서버 에러로 간주하고 다루어야 할 것

**reason phrase**

- 응답 시작줄의 마지막 구성요소
- 상태 코드에 대한 글로 된 설명을 제공하며, 상태 코드와 1:1로 대응됨
- HTTP 명세에는 사유 구절이 어때야 한다는 엄격한 규칙이 없음

**version**

- 요청과 응답 메시지 양쪽 모두에 기술됨
- HTTP 애플리케이션들이 자신의 프로토콜 버전을 상대방에게 말해주기 위한 수단이 됨
- HTTP로 대화하는 애플리케이션들에게 대화 상대의 능력과 메시지 형식에 대한 단서를 제공해주기 위한 용도
- 해당 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킴
- 버전 번호는 분수로 다루어지지 않고, 각각 분리된 숫자로 다루어짐
  - 예를 들어, HTTP/2.22는 HTTP/2.3보다 높은 버전

### 2.3 헤더

- 시작줄 다음에는 0개 이상의 HTTP 헤더가 옴
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더함
- 이름/값 쌍의 목록으로 이루어짐

```
Content-length: 19
```

- HTTP 헤더 명세는 여러 헤더 필드를 정의하며, 또한 자유롭게 자신만의 헤더를 만들어낼 수도 있음

**일반 헤더**

- 요청과 응답 양쪽에 모두 나타날 수 있음

**요청 헤더**

- 요청에 대한 부가 정보 제공

**응답 헤더**

- 응답에 대한 부가 정보 제공

**Entity 헤더**

- 본문 크기와 컨텐츠, 혹은 리소스 그 자체에 대해 서술

**확장 헤더**

- 명세에 정의되지 않은 새로운 헤더

※ 흔히 쓰이는 헤더 예시

| 예시                                     | 설명                                           |
| :--------------------------------------- | :--------------------------------------------- |
| Date: Tue, 3 Oct 1997 02:16:03 GMT       | 서버가 응답을 만들어낸 시각                    |
| Content-length: 15040                    | 15,040 Byte의 데이터를 포함한 엔티티 본문      |
| Content-type: image/gif                  | 엔티티 본문은 GIF 이미지                       |
| Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지와 HTML 수용 가능 |

**헤더를 여러 줄로 나누기**

- 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있음
- 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자가 와야 함

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
    Version 1.0
```

- 위 예에서 Server 헤더의 완전한 값은 `Test Server Version 1.0`

### 2.4 엔티티 본문

- HTTP 메시지의 세 번째 부분은 Optional한 엔티티 본문
- HTTP 메시지의 화물이라고 할 수 있음
  - 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등<br>여러 종류의 디지털 데이터를 실어 나를 수 있음

### 2.5 버전 0.9 메시지

- 오늘날 HTTP가 가지는 요청과 응답 메시지의 시초이지만 훨씬 단순한 프로토콜로 되어 있음
- 요청은 그저 메소드와 요청 URL을 가지며, 응답은 오직 엔티티로만 되어 있음
- 여전히 HTTP/0.9를 사용하는 클라이언트, 서버, 기타 애플리케이션들이 있기 때문에 이러한 제약에 대해 알고 있어야 함

<br>

## 3. 메소드

- 모든 서버가 모든 메소드를 구현하지는 않는다는 점에 주의할 것
- 사이트마다 서버마다 메소드 구현이 상이하게 다를 수 있음

### 3.1 Safe Method

- GET과 HEAD 메소드는 안전하다고 할 수 있음
  - 두 종류의 HTTP 요청으로는 서버에서 일어나는 작용이 없다는 뜻
- 사실 안전한 메소드는 관념적인 것일 뿐, 개발자가 어떻게 설계했느냐에 따라 달라질 수는 있음
- 안전한 메소드의 목적: 서버에 영향이 가는 안전하지 않은 메소드가 사용될 때<br>사용자들에게 그 사실을 알려줄 수 있는 HTTP 애플리케이션을 설계하도록 방향을 제시해주는 것

### 3.2 GET

- 가장 흔하게 쓰이는 메소드
- 주로 서버에게 리소스를 요구하기 위해 사용됨

### 3.3 HEAD

- 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려줌
- 사용 목적
  - 리소스 대신 리소스에 대한 타입 등을 알고 싶을 때
  - 응답의 상태 코드를 통해 개채가 존재하는지 여부만 알고 싶을 때
  - 리소스의 변경 여부만 확인하고 싶을 때
- 서버 개발자들은 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 함
- HTTP/1.1 준수를 위해서 HEAD 메소드는 반드시 구현되어 있어야 함

### 3.4 PUT

- 서버에 문서를 작성하는 메소드
- 서버가 요청의 본문을 통해 새 문서를 만들거나, 이미 존재한다면 본문을 사용해서 교체함

### 3.5 POST

- 서버에 입력 데이터를 전송하기 위해 설계되었음
- 실제로 HTML 폼을 지원하기 위해서 흔히 사용됨

### 3.6 TRACE

- 클라이언트가 특정 요청을 보내면 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과하게 됨
- TRACE는 클라이언트에게 요청이 서버에 도달했을 때 어떻게 보이는지 알려줌
- 목적지 서버에서 **loopback 진단**을 시작하며, 서버가 받은 요청 메시지를 본문에 넣어서 응답으로 돌려줌
- 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서<br>자신의 메시지가 망가졌는지, 수정되었는지, 어떻게 변경되었는지 확인할 수 있음
- 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 끼치는지 확인해볼 때 유용함
- 다만 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정해버리는 문제가 있음
  - 서로 다른 HTTP 메소드들을 구별하는 메커니즘을 제공하지 않음
  - TRACE 요청에 대해 어떻게 처리할 것인지는 일반적으로 중간 애플리케이션이 결정을 내림
- 엔티티 본문을 담아서 보낼 수 없음
  - 응답 본문에는 서버가 받은 요청이 그대로 들어있음

### 3.7 OPTIONS

- 서버에게 메소드 지원 범위에 대해 물어보는 메소드
- 특정 리소스에 대해 어떤 메소드가 지원되는지를 물어볼 수 있음
- 여러 리소스에 대한 실제적인 접근 없이 접근 수단을 클라이언트에게 알려줄 수 있음

### 3.8 DELETE

- 지정한 리소스에 대한 삭제 요청
- 하지만 클라이언트는 삭제가 수행되는 것을 보장하지는 못함
  - HTTP 명세상 서버가 클라이언트에게 알리지 않은 채 요청을 무시하는 것이 허용되기 때문

### 3.9 확장 메소드

- HTTP는 필요에 따라 확장하더라도 문제가 없도록 설계되어 있음
- 개발자들은 HTTP/1.1 명세에 정의되어 있지 않은 메소드를 활용함으로써,<br>리소스에 대한 능력을 확장하는 수단으로 활용할 수 있음

※ 확장 메소드의 예시

| 메소드 | 설명                                |
| :----: | :---------------------------------- |
|  LOCK  | 사용자가 리소스를 잠글 수 있게 해줌 |
| MKCOL  | 사용자가 문서를 생성할 수 있게 해줌 |
|  COPY  | 리소스 복사                         |
|  MOVE  | 리소스 이동                         |

- 확장 메소드는 명세를 갖춘 것이 아니기 때문에,
  - 내가 정의한 확장 메소드를 다른 HTTP 애플리케이션들이 이해할 수 없는 경우가 생길 수 있음
  - 내 HTTP 애플리케이션이 이해할 수 없는 확장 메소드를 사용하는 다른 애플리케이션을 마주치게 될 수도 있음
- 확장 메소드에 대해 관용적인 것이 최고
  - 프락시는 end-to-end 행위를 망가뜨리지 않을 수 있다면, 알려지지 않은 확장 메소드라도 다운스트림 서버로 전달하려고 시도함
  - 만약 프락시의 전송이 관대하지 않다면 501 Not Implemented 상태 코드로 응답해야 함
  - "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙을 따르는 것이 좋음

<br>

## 4. 상태 코드

- HTTP 상태 코드는 크게 다섯 가지로 나뉨
- 클라이언트에게 트랜잭션을 이해할 수 있는 쉬운 방법을 제공함

### 4.1 100-199: 정보성 상태 코드

- HTTP/1.1에서 도입된 비교적 새로운 코드들
  - 번잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있음

| 상태 코드 |      사유 구절      | 의미                                                                                                                              |
| :-------: | :-----------------: | :-------------------------------------------------------------------------------------------------------------------------------- |
|    100    |      Continue       | 요청의 시작 부분이 받아들여졌으니, 클라이언트는 나머지 요청을 계속 보내야 함<br>이후 서버는 반드시 나머지 요청을 받고 응답해야 함 |
|    101    | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 프로토콜 중 하나로 변환되었음                                                                  |

**클라이언트와 100 Continue**

- 클라이언트가 엔티티 본문을 서버에 보내려고 하면서 100 응답을 기다리겠다면,<br>클라이언트는 `Expect` 요청 헤더에 `100-continue` 값을 담아서 보내야 함
- 이 요청을 보내면 서버는 엔티티 본문을 기다리게 되므로 사용에 유의할 것!
- `100-continue`는 최적화를 위한 것
  - 지나치게 큰 엔티티 본문을 서버에게 보내지 않으려는 목적으로만 사용할 것
- `100-continue` 값을 보냈다면 서버가 `100 Continue` 응답을 보내주기를 막연히 기다리기만 해선 안됨
  - 약간의 타임아웃 후에 클라이언트는 그냥 엔티티를 보내야 함
- 사실 클라이언트 개발자는 예상치 못한 100 Continue 응답에도 대비해야 함
  - 몇몇 잘못 만들어진 HTTP 애플리케이션은 이 코드를 부적절하게 보내기 때문

**서버와 100 Continue**

- 서버가 Expect 헤더에 100-continue 값이 담긴 요청 헤더를 받았다면 100 Continue 혹은 에러 코드로 답해야 함
- 서버는 절대로 100-continue 응답을 받도록 의도하지 않은 클라이언트에게 100 Continue를 보내선 안됨
  - 몇몇 잘못 만들어진 서버는 그렇게 할 수도 있으니 유의할 것
- 서버가 100 Continue 응답을 보내기 전에 어떠한 이유로 이미 엔티티 본문을 수신했다면,<br>서버는 이 상태 코드를 보낼 필요가 없음
  - 클라이언트가 이미 계속 전송하기로 결정했기 때문
  - 그러나 서버가 요청을 끝까지 다 읽은 후에는 해당 요청에 대한 최종 응답을 보내야 함
- 만약 서버가 100-continue 요청을 받은 이후 엔티티 본문을 읽기 전에 요청을 끝내기로 결정했다면<br>그냥 응답을 보내고 연결을 닫아선 안됨 (4장에서 학습하게 될 것)

**프락시와 100 Continue**

- next-hop 서버가 HTTP/1.1을 따르거나 알 수 없는 경우 Expect 헤더를 포함시켜서 다음 요청에 전달해야 함
- next-hop 서버가 HTTP/1.1 이전의 버전을 사용하는 것이 확실하다면 프락시는 417 Expectation Failed로 응답해야 함
- 만약 프락시가 HTTP/1.1 이전 버전의 클라이언트를 대신해서 `Expect: 100-continue` 요청을 포함시키기로 했다면,<br>100 Contunue 응답을 클라이언테에게 전달해서는 안됨
  - 클라이언트는 해당 응답을 알 수 없기 때문에
- 프락시가 next-hop 서버들에 대한 상태 및 지원하는 HTTP 버전을 기억해두면 `100-continue` 요청을 더욱 잘 다룰 수 있게 될 것

### 4.2 200-299: 성공 상태 코드

| 상태 코드 |           사유 구절           | 의미                                                                                                                                                                                                                                                                          |
| :-------: | :---------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    200    |              OK               | 요청이 정상이며, 응답 본문은 요청된 리소스를 포함하고 있음                                                                                                                                                                                                                    |
|    201    |            Created            | 객체 생성 요청에 대한 응답<br>Location 헤더에 생성된 리소스에 대한 구체적인 참조를 담아줌<br>리소스 참조를 위한 URL을 본문에 포함해야 함<br>서버는 상태 코드를 보내기에 앞서 객체를 생성했어야 함                                                                             |
|    202    |           Accepted            | 요청은 받아들여졌으나 서버는 어떤 동작도 수행하지 않았음<br>서버가 요청에 대한 처리를 완료할 것인지에 대한 보장이 없음<br>단지 요청이 받아들이기에 적법해 보인다는 의미<br>응답 본문에는 가급적이면 요청 처리 추정 시간과,<br>해당 정보를 어디서 얻을 수 있는지를 포함해야 함 |
|    203    | Non-Authoritative Information | 헤더의 정보가 원 서버가 아닌 다른 리소스의 사본으로부터 왔음<br>중개자가 리소스의 사본을 갖고 있었으나, 메타 정보 검증에 실패한 경우<br>필수적으로 사용되는 응답 코드가 아니며,<br>헤더가 원 서버에서 왔다면 응답이 200이었을 애플리케이션을 위한 선택 사항                   |
|    204    |          No Content           | 응답은 본문을 포함하지 않음<br>주로 웹 브라우저를 새 문서로 이동하지 않고 갱신할 때 사용됨                                                                                                                                                                                    |
|    205    |         Reset Content         | 주로 브라우저를 위해 사용되는 코드<br>브라우저에게 현재 페이지에 있는 HTML 폼의 모든 값을 비우라고 말해줌                                                                                                                                                                     |
|    206    |        Partial Content        | 부분적인 요청 성공<br>클라이언트는 Range 헤더를 사용해서 문서의 특정 범위를 요청할 수 있음<br>응답은 Content-Range와 Date 헤더를 반드시 포함해야 함<br>Etag 혹은 Content-Loaction 둘 중 하나의 헤더도 반드시 포함해야 함                                                      |

### 4.3 300-399: 리다이렉션 상태 코드

- 클라이언트가 원하는 리소스에 대해 다른 위치를 사용하라고 말하거나 다른 대안을 제시해줌
- 선택적으로 Location 헤더를 활용해서 위치를 알려줄 수 있음
- 브라우저가 사용자를 귀찮게 하지 않고 알아서 새 위치로 이동할 수 있게 해줌
- 몇몇 3XX 코드는 리소스에 대한 애플리케이션의 복사본이 원 서버와 비교했을 때 유효한지를 확인하기 위해 사용됨
  - 로컬 복사본이 여전히 최신인지
- 클라이언트는 특정 시점 이후에 수정된 경우에만 문서를 가져오기 위해서 `If-Modified-Since` 헤더를 전송할 수도 있음
  - 해당 시점 이후 변경사항이 없다면 `304 Not Modified` 응답이 반환됨
- 일반적으로 HEAD가 아닌 요청에 대해 3XX 응답을 한다면 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것이 좋음

| 상태 코드 |     사유 구절      | 의미                                                                                                                                                                                                                                                           |
| :-------: | :----------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    300    |  Multiple Choices  | 클라이언트가 동시에 여러 URL을 요청한 경우 리소스의 목록과 함께 반환됨<br>사용자는 목록에서 원하는 리소스를 선택할 수 있음<br>예를 들어 서버가 HTML 문서를 영어와 프랑스어 모두 제공하는 경우에 사용<br>서버는 Location 헤더에 선호하는 URL을 포함시킬 수 있음 |
|    301    | Moved Permanently  | 요청한 URL이 옮겨졌을 때 사용<br>응답은 Location 헤더에 리소스가 존재하고 있는 URL을 포함해야 함                                                                                                                                                               |
|    302    |       Found        | 301과 같지만 Location 헤더로 주어진 URL이 임시적일 때 사용됨<br>이후 요청에서는 원래 URL을 사용해야 함                                                                                                                                                         |
|    303    |     See Other      | 리소스를 다른 URL에서 가져와야 한다고 말해주는 역할<br>새 URL은 응답 메시지의 Location 헤더에 있음<br>POST 요청에 대한 응답 이후 리소스가 어디로 갔는지 알려주기 위한 목적                                                                                     |
|    304    |    Not Modified    | 클라이언트가 최종 수정일 같은 조건부 헤더를 사용했을 때에 대한 응답<br>이 응답은 본문을 가져서는 안됨                                                                                                                                                          |
|    305    |     Use Proxy      | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타냄<br>Location 헤더에 프락시의 위치가 담김                                                                                                                                                                 |
|    306    |     (not used)     | 현재 사용되지 않음                                                                                                                                                                                                                                             |
|    307    | Temporary Redirect | 302와 비슷하게 Location 헤더로 주어진 URL을 임시로 사용하게 함<br>이후 요청에서는 원래 URL을 사용해야 함                                                                                                                                                       |

- 302, 303, 307 상태 코드가 미묘하게 겹치는 부분이 있음
  - HTTP/1.0과 HTTP/1.1 애플리케이션이 상태 코드를 다루는 방식의 차이점에서 비롯됨
  - HTTP/1.0은 POST 요청 이후 302 응답을 받으면, Location 헤더의 URL을 GET으로 따라감
  - HTTP/1.1은 위와 같은 작업을 위해 303 응답을 사용함
  - 혼란을 막기 위해서 HTTP/1.1은 일시적인 리다이렉트를 위해선 302 대신 307을 사용하라고 함
  - 결국 302 응답은 HTTP/1.0 클라이언트를 위해 남겨둔 것

### 4.4 400-499: 클라이언트 에러 상태 코드

- 클라이언트가 서버가 다룰 수 없는 요청을 보냈을 때에 대한 응답
- 가장 흔한 것은 존재하지 않는 URL에 대한 요청
  - 악명 높은 404 Not Found

| 상태 코드 |            사유 구절            | 의미                                                                                                                                                                                         |
| :-------: | :-----------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    400    |           Bad Request           | 클라이언트가 요청을 잘못 보냄                                                                                                                                                                |
|    401    |          Unauthorized           | 리소스를 보내주기 전에 클라이언트의 인증 필요<br>인증을 요구하는 내용의 적절한 헤더와 함께 반환됨                                                                                            |
|    402    |        Payment Required         | 현재 쓰이지 않지만 미래를 위해 남겨둔 상태 코드                                                                                                                                              |
|    403    |            Forbidden            | 요청이 서버에 의해 거부되었음을 알려줌<br>서버는 그 이유를 설명하는 본문을 포함할 수도 있음<br>하지만 이 코드는 보통 거절의 이유를 숨기고 싶을 때 사용됨                                     |
|    404    |            Not Found            | 서버가 요청받은 URL을 찾을 수 없음<br>종종 클라이언트가 사용자에게 보여줄 엔티티가 포함되기도 함                                                                                             |
|    405    |       Method Not Allowed        | 지원하지 않는 메소드로 요청받았을 때 사용됨<br>요청 리소스에 대해 어떤 메소드가 가용한지를 응답의 Allow 헤더에 포함해야 함                                                                   |
|    406    |         Not Acceptable          | 클라이언트는 어떤 종류의 엔티티를 받고자 하는지 매개변수로 명시 가능<br>이 코드는 클라이언트가 받아들일 수 없는 리소스가 있을 때 사용됨                                                      |
|    407    |  Proxy Authentication Required  | 프락시 서버를 위해 사용되는 401 상태 코드라고 볼 수 있음                                                                                                                                     |
|    408    |         Request Timeout         | 요청을 완수하기까지 시간이 너무 오래 걸리는 경우,<br>서버는 이 상태 코드로 응답하고 연결을 끊을 수 있음<br>타임아웃의 길이는 대개 어떠한 적법한 요청도 받아들일 수 있을 만큼 충분함          |
|    409    |            Conflict             | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용됨<br>서버는 요청이 충돌을 일으킬 염려가 있다고 생각될 때 이 요청을 보냄<br>응답은 충돌에 대해 설명하는 본문을 포함해야 함 |
|    410    |              Gone               | 404와 비슷하지만 서버가 한때 해당 리소스를 갖고 있었다는 점이 다름                                                                                                                           |
|    411    |         Length Required         | 요청 메시지에 Content-Length 헤더가 있을 것을 요구하는 코드                                                                                                                                  |
|    412    |       Precondition Failed       | 클라이언트의 조건부 요청 중 하나가 실패했을 경우<br>조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생함                                                                              |
|    413    |    Request Entity Too Large     | 서버가 처리할 수 있는 한계를 넘은 크기의 요청을 받았을 때                                                                                                                                    |
|    414    |      Request URI Too Long       | 서버가 처리할 수 있는 한계를 넘은 길이의 요청 URI를 받았을 때                                                                                                                                |
|    415    |     Unsupported Media Type      | 서버가 이해하지 못하는 유형의 엔티티를 받았을 때                                                                                                                                             |
|    416    | Requested Range Not Satisfiable | 리소스의 특정 범위를 요청받았으나 범위가 잘못되거나 맞지 않았을 때                                                                                                                           |
|    417    |       Expectation Failed        | 요청의 Expect 헤더에 서버가 만족시킬 수 없는 기대가 담겨 있는 경우                                                                                                                           |

### 4.5 500-599: 서버 에러 상태 코드

- 서버 또한 서버 제한이나 게이트웨이 리소스 등의 문제로 에러가 발생할 수 있음
- 프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 5XX 에러 상태 코드를 생성함

| 상태 코드 |         사유 구절          | 의미                                                                                                              |
| :-------: | :------------------------: | :---------------------------------------------------------------------------------------------------------------- |
|    500    |   Internal Server Error    | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때                                                              |
|    501    |      Not Implemented       | 서버의 능력을 넘어서는 요청을 했을 때                                                                             |
|    502    |        Bad Gateway         | 프락시, 게이트웨이 등 요청 응답 연쇄에 있는<br>다음 링크로부터 잘못된 응답을 마주하게 되었을 때                   |
|    503    |    Service Unavailable     | 현재는 서버가 요청을 처리할 수 없지만 나중에는 가능함<br>Retry-After 헤더를 보내서 언제 가능할지 알려줄 수도 있음 |
|    504    |      Gateway Timeout       | 408과 비슷하지만,<br>게이트웨이나 프락시의 시점에서 응답을 기다리다가 타임아웃이 났다는 점이 다름                 |
|    505    | HTTP Version Not Supported | 서버 지원 범위에 없는 버전의 프로토콜 요청을 받았을 때<br>몇몇 애플리케이션들은 구버전의 프로토콜을 지원하지 않음 |

<br>

## 5. 헤더

**General Headers**

- 클라이언트와 서버 양쪽 모두 사용
- 다양한 목적으로 사용됨
- `Date: Tue, 3 Oct 1974 02:16:00 GMT`

**Request Headers**

- 클라이언트가 받고자 하는 데이터 타입이 무엇인지 등 서버에 부가적인 정보를 제공함
- `Accept: */*`

**Response Headers**

- 클라이언트에게 정보를 제공하기 위한 헤더
- `Server: Tiki-Hut/1.0`

**Entity Headers**

- 엔티티 본문에 대한 헤더
- `Content-Type: text/html; charset=iso-latin-1`

**Extension Headers**

- 개발자들에 의해 만들어진 비표준 헤더
- HTTP 프로그램은 확장 헤더들의 의미를 모른다 할지라도 전달해야 할 필요가 있음

### 5.1 일반 헤더

- 메시지에 대한 아주 기본적인 정보 제공
- 어떤 종류의 메시지든 유용한 정보를 제공하기 위한 목적을 가짐

|           헤더           | 설명                                                |
| :----------------------: | :-------------------------------------------------- |
|        Connection        | 요청/응답에 대한 연결 옵션을 정할 수 있게 함        |
|           Date           | 메시지가 언제 만들어졌는지                          |
|       MIME-Version       | 발송자가 사용한 MIME 버전                           |
| Trailer chunked transfer | 인코딩된 메시지 끝의 헤더 목록 나열                 |
|    Transfer-Encoding     | 메시지에 어떤 인코딩이 적용되었는지                 |
|         Upgrade          | 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜 |
|           Via            | 메시지가 어떤 중개자를 거쳐 왔는지                  |

**일반 캐시 헤더**

- HTTP/1.0에서 도입된, 로컬 복사본으로 캐시할 수 있게 해주는 헤더
- 최신 버전의 HTTP는 풍부한 캐시 매개변수의 집합을 가지고 있음

※ 기본적인 캐시 헤더들

|     헤더      | 설명                                         |
| :-----------: | :------------------------------------------- |
| Cache-Control | 메시지와 함께 캐시 지시자 전달               |
|    Pragma     | Cache-Control과 같지만, 캐시에 국한되지 않음 |

※ Pragma는 엄밀히 말하면 요청 헤더, 그리고 deprecated 상태임

### 5.2 요청 헤더

- 누가 혹은 무엇이 그 요청을 보냈는지, 클라이언트의 선호나 능력이 무엇인지
- 서버는 요청 헤더를 더 나은 응답을 주기 위해서 활용할 수 있음

|    헤더    | 설명                                        |
| :--------: | :------------------------------------------ |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP             |
|    From    | 클라이언트 사용자의 메일 주소               |
|    Host    | 요청 대상 서버의 호스트 명과 포트           |
|  Referer   | 현재 요청 URI가 들어있던 문서의 URL 제공    |
|  UA-Color  | 클라이언트 기기 디스플레이의 색상 능력      |
|   UA-CPU   | 클라이언트 CPU의 종류나 제조사              |
|  UA-Disp   | 클라이언트 디스플레이 능력                  |
|   UA-OS    | 클라이언트 운영체제의 이름과 버전           |
| UA-Pixels  | 클라이언트 기기 디스플레이에 대한 픽셀 정보 |
| User-Agent | 요청을 보낸 애플리케이션 이름               |

※ Client-IP, UA- 헤더들은 RFC 2616에 정의되어 있지는 않지만 많은 HTTP 클라이언트 애플리케이션에서 구현되어 있음  
※ UA- 헤더는 해로울 수 있음 - HTML 컨텐츠가 특정 클라이언트 설정에 맞춰지는 것은 좋지 않음

**Accept 관련 헤더**

- 클라이언트의 선호도와 능력
  - 클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 원치 않는 것은 무엇인지
- 서버는 무엇을 보내줄지에 대해 더 똑똑한 결정을 내릴 수 있게 됨
- 클라이언트는 원하는 것을 얻을 수 있고, 서버는 대역폭을 낭비하지 않을 수 있음

|      헤더       | 설명                              |
| :-------------: | :-------------------------------- |
|     Accept      | 서버가 보내도 되는 미디어 종류    |
| Accept-Charset  | 서버가 보내도 되는 문자집합       |
| Accept-Encoding | 서버가 보내도 되는 인코딩         |
| Accept-Language | 서버가 보내도 되는 언어           |
|       TE        | 서버가 보내도 되는 확장 전송 코딩 |

**조건부 요청 헤더**

- 클라이언트가 요청에 몇몇 제약을 넣을 때 사용
- 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있음

|        헤더         | 설명                                                                           |
| :-----------------: | :----------------------------------------------------------------------------- |
|       Expect        | 요청에 필요한 서버의 행동 열거                                                 |
|      If-Match       | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하는 경우에만 문서를 가져옴      |
|  If-Modified-Since  | 주어진 날짜 이후에 리소스가 변경되었을 때 문서를 가져옴                        |
|    If-None-Match    | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하지 않는 경우에만 문서를 가져옴 |
|      If-Range       | 문서의 특정 범위에 대한 요청                                                   |
| If-Unmodified-Since | 주어진 날짜 이후 리소스가 변경되었다면 요청을 제한                             |
|        Range        | 서버가 범위 요청을 지원한다면 리소스의 특정 범위 요청                          |

**요청 보안 헤더**

- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있음
- 클라이언트가 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 안전하게

|     헤더      | 설명                                                                             |
| :-----------: | :------------------------------------------------------------------------------- |
| Authorization | 서버에 제공하는 인증 그 자체에 대한 정보                                         |
|    Cookie     | 서버에 토큰 전달<br>진짜 보안 헤더는 아니지만 보안에 영향을 줄 수 있는 것은 확실 |
|    Cookie2    | 지원하는 쿠키의 버전을 알려줌                                                    |

**프락시 요청 헤더**

|        헤더         | 설명                                                                                                             |
| :-----------------: | :--------------------------------------------------------------------------------------------------------------- |
|    Max-Forwards     | 요청이 원 서버로 향하는 과정에서 프락시 혹은 게이트웨이를 전달될 수 있는 최대 횟수<br>TRACE 메소드와 함께 사용됨 |
| Proxy-Authorization | Authorization의 프락시 인증 버전                                                                                 |
|  Proxy-Connection   | Connection의 프락시 연결 버전                                                                                    |

### 5.3 응답 헤더

- 누가 응답을 보내는지, 응답자의 능력은 어떻게 되는지, 응답에 대한 특별한 설명이 있는지
- 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 하도록 도와줌

|    헤더     | 설명                                                             |
| :---------: | :--------------------------------------------------------------- |
|     Age     | 응답이 얼마나 오래되었는지<br>응답이 중개자를 통해서 왔음을 암시 |
|   Public    | 서버가 특정 리소스에 대해 지원하는 요청 메소드의 목록            |
| Retry-After | 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지         |
|   Server    | 서버 애플리케이션의 이름과 버전                                  |
|    Title    | HTML 문서에도 주어지는 제목                                      |
|   Warning   | 사유 구절에 있는 것보다 더 자세한 경고 메시지                    |

**협상 헤더**

- HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할지 협상을 할 수 있음
- 서버가 협상 가능한 리소스에 대한 정보를 운반하는 몇 가지 헤더들이 있음

|     헤더      | 설명                                                      |
| :-----------: | :-------------------------------------------------------- |
| Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태           |
|     Vary      | 서버 확인이 필요해서 응답에 영향이 갈 수도 있는 헤더 목록 |

**응답 보안 헤더**

|        헤더        | 설명                                       |
| :----------------: | :----------------------------------------- |
| Proxy-Authenticate | 프락시에서 클라이언트로 보낸 인증요구 목록 |
|     Set-Cookie     | 클라이언트 측에 토큰을 설정하기 위한 용도  |
|    Set-Cookie2     | RFC 2965로 정의된 쿠키 저장                |
|  WWW-Authenticate  | 서버에서 클라이언트로 보낸 인증요구 목록   |

### 5.4 엔티티 헤더

- 엔티티에 대해 설명하는 헤더들은 많음
- 요청과 응답 모두 엔티티를 포함할 수 있기에 엔티티 헤더도 양쪽 모두에 사용 가능
- 개체의 타입, 유효 메소드 등 광범위한 정보를 제공함
- 일반적으로는 메시지의 수신자에게 자신이 다루고 있는 것이 무엇인지 말해줌

|   헤더   | 설명                                                                           |
| :------: | :----------------------------------------------------------------------------- |
|  Allow   | 엔티티에 수행될 수 있는 요청 메소드 나열                                       |
| Location | 엔티티가 실제로 어디에 위치하고 있는지<br>리소스에 대한 URL을 알려줄 때 사용됨 |

**컨텐츠 헤더**

- 엔티티의 컨텐츠에 대한 구체적인 정보 제공
- 컨텐츠의 종류, 크기 등 컨텐츠 처리에 유용하게 활용될 수 있는 것들

|       헤더       | 설명                                                           |
| :--------------: | :------------------------------------------------------------- |
|   Content-Base   | 본문에 사용된 상대 URL을 계산하기 위한 base URL                |
| Content-Encoding | 본문에 적용된 인코딩                                           |
| Content-Language | 본문을 이해하는데 가장 적절한 자연어                           |
|  Content-Length  | 본문의 길이나 크기                                             |
| Content-Location | 리소스의 실제 위치                                             |
|   Content-MD5    | 본문의 MD5 checksum                                            |
|  Content-Range   | 전체 리소스에서 해당 엔티티가 해당하는 범위를 bite 단위로 표현 |
|   Content-Type   | 본문이 어떤 종류의 객체인지                                    |

**엔티티 캐싱 헤더**

- 언제 어떻게 캐시되어야 하는지에 대한 지시자 제공
- 리소스에 대해 캐시된 사본이 유효한지, 캐시된 리소스가 언제 유효하지 않게 되는지 등

|     헤더      | 설명                                                    |
| :-----------: | :------------------------------------------------------ |
|     ETag      | 엔티티에 대한 엔티티 태그                               |
|    Expires    | 엔티티가 유효하지 않아서 원본을 다시 받아와야 하는 일시 |
| Last-Modified | 최근 이 엔티티가 변경된 일시                            |

※ ETag는 기본적으로 리소스의 특정 버전에 대한 식별자 역할 수행
