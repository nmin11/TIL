- HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같음
- 이번 장에서는 HTTP 메시지를 어떻게 만들고 이해하는지 학습하게 될 것

<br>

## 1. 메시지의 흐름

- HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들
  - 데이터 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작
  - 그 다음에 선택적으로 데이터가 존재할 수 있음
- HTTP 메시지는 클라이언트, 서버, 프락시 사이를 흐름
  - '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어

### 1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- 인바운드와 아웃바운드는 트랜잭션 방향을 표현하기 위해 사용됨
  - 인바운드: 메시지가 원 서버로 향하는 것
  - 아웃바운드: 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것

### 1.2 다운스트림으로 흐르는 메시지

![http downstream](https://user-images.githubusercontent.com/75058239/196015297-4b1b1d87-2e5d-42a4-818b-0a8ef8dc9f16.png)

- HTTP 메시지는 강물과 같이 요청과 응답에 관계 없이 다운스트림으로 흐름
- 메시지 발송자는 수신자의 업스트림

<br>

## 2. 메시지의 각 부분

(이미지 첨부 - http message)

- 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함
- 시작줄, 헤더 블록, 본문 이렇게 3부분으로 이루어짐
  - 시작줄: 어떤 메시지인지 서술
  - 헤더 블록: 속성을 정의
  - 본문: 데이터를 담고 있음
- 시작줄과 헤더는 그냥 줄 단위로 분리된 ASCII 문자열
  - 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 2글자의 줄바꿈 문자열로 끝남
  - 줄바꿈 문자열은 **CRLF**라고 씀
- 본문은 선택적 데이터 덩어리
  - 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있음

### 2.1 메시지 문법

- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류됨
- 어떤 메시지인지에 따라서 메시지의 형식이 달라짐

※ 요청 메시지 형식

```
<method> <request URL> <version>
<header>

<body>
```

※ 응답 메시지 형식

```
<version> <status code> <reason phrase>
<header>

<body>
```

**method**

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있음

**request URL**

- 요청 대상이 되는 리소스를 지칭하는 URL
- 완전한 URL이 아니더라도 클라이언트와 서버가 직접 대화하고 있으면 대체로 문제가 없음
  - 서버는 URL에 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 수 있음

**version**

```
HTTP/<major>.<minor>
```

- 메시지에서 사용 중인 HTTP 버전
- 메이저와 마이너는 모두 정수

**status code**

- 요청 중에 무슨 일이 일어났는지 설명하는 3자리 숫자
- 첫 번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타냄

**reason phrase**

- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
- 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절
- 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재함
  - 예를 들어, 'HTTP/1.0 200 NOT OK'와 'HTTP/1.0 200 OK'는 동등하게 성공을 의미하는 것으로 처리되어야 함

**headers**

- 이름, `:`, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
- 헤더 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시함
- HTTP/1.1 같은 몇몇 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야만 유효한 것으로 간주

**entity body**

- 임의의 데이터 블록을 포함
- 모든 메시지가 엔티티 본문을 갖는 것은 아니므로, 그냥 CRLF로 끝나게 되는 경우도 있음

### 2.2 시작줄

- 요청 메시지의 시작줄: 무엇을 해야 하는지
- 응답 메시지의 시작줄: 무슨 일이 일어났는지

**요청줄**

- 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁함
- 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메소드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있음
- 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 알려주기 위해 HTTP 버전도 포함
- 위의 모든 필드들은 공백으로 구분됨

**응답줄**

- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
- HTTP 버전, 상태 코드, 사유 구절이 들어있음
- 위의 모든 필드들은 공백으로 구분됨

**method**

- 요청 시작줄은 메소드로 시작하면서, 서버에게 무엇을 해야 하는지 말해줌

※ 대표적인 HTTP 메소드들

| method  | description                                        | has body? |
| :-----: | :------------------------------------------------- | :-------: |
|   GET   | 서버에서 어떤 문서를 가져옴                        |     X     |
|  HEAD   | 서버에서 어떤 문서에 대한 헤더만 가져옴            |     X     |
|  POST   | 서버가 처리해야 할 데이터 전송                     |     O     |
|   PUT   | 서버에 요청 메시지의 본문 저장                     |     O     |
|  TRACE  | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적 |     X     |
| OPTIONS | 서버가 어떤 메소드를 수행할 수 있는지 확인         |     X     |
| DELETE  | 서버에서 문서를 제거                               |     X     |

- 위의 표는 모든 메소드들을 담은 것이 아니며,<br>HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에 해당 서버만의 메소드를 추가로 구현했을 수도 있음
  - 자기 서버만의 HTTP 메소드를 갖는 것은 HTTP 명세를 확장하는 것이기에 **확장 메소드**라고 부름

**status code**

- 메소드가 서버에게 무엇을 해야 할지 말해주듯, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해줌
- 응답의 시작줄에 위치함
  - 숫자로 된 코드와 문자열로 된 사유 구절을 함께 주기 때문에 이해하기 쉬움
- 클라이언트가 HTTP 서버에게 요청 메시지를 보낼 때 많은 일이 발생함
  - 운이 좋다면 요청은 완전히 성공할 것
  - 서버에서 요청한 리소스가 발견되지 않거나, 리소스 접근 권한이 없거나, 리소스가 옮겨졌다고 알려올 수도 있음

| 전체 범위 | 정의된 범위 |      분류       |
| :-------: | :---------: | :-------------: |
|  100-199  |   100-101   |      정보       |
|  200-299  |   200-206   |      성공       |
|  300-399  |   300-305   |   리다이렉션    |
|  400-499  |   400-415   | 클라이언트 에러 |
|  500-599  |   500-505   |    서버 에러    |

- 현재 HTTP 버전에서는 각 상태 분류에 대해 적은 수의 코드만을 정의했음
  - 프로토콜이 진화함에 따라 더 많은 상태 코드가 HTTP 명세에 공식적으로 정의될 것
- 누군가 프로토콜 확장으로 정의한 상태 코드를 받게 되는 경우도 있을 수 있음
  - 예를 들어, 상태 코드 515를 받게 되었다면 다른 5XX와 마찬가지로 서버 에러로 간주하고 다루어야 할 것

**reason phrase**

- 응답 시작줄의 마지막 구성요소
- 상태 코드에 대한 글로 된 설명을 제공하며, 상태 코드와 1:1로 대응됨
- HTTP 명세에는 사유 구절이 어때야 한다는 엄격한 규칙이 없음

**version**

- 요청과 응답 메시지 양쪽 모두에 기술됨
- HTTP 애플리케이션들이 자신의 프로토콜 버전을 상대방에게 말해주기 위한 수단이 됨
- HTTP로 대화하는 애플리케이션들에게 대화 상대의 능력과 메시지 형식에 대한 단서를 제공해주기 위한 용도
- 해당 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킴
- 버전 번호는 분수로 다루어지지 않고, 각각 분리된 숫자로 다루어짐
  - 예를 들어, HTTP/2.22는 HTTP/2.3보다 높은 버전

### 2.3 헤더

- 시작줄 다음에는 0개 이상의 HTTP 헤더가 옴
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더함
- 이름/값 쌍의 목록으로 이루어짐

```
Content-length: 19
```

- HTTP 헤더 명세는 여러 헤더 필드를 정의하며, 또한 자유롭게 자신만의 헤더를 만들어낼 수도 있음

**일반 헤더**

- 요청과 응답 양쪽에 모두 나타날 수 있음

**요청 헤더**

- 요청에 대한 부가 정보 제공

**응답 헤더**

- 응답에 대한 부가 정보 제공

**Entity 헤더**

- 본문 크기와 컨텐츠, 혹은 리소스 그 자체에 대해 서술

**확장 헤더**

- 명세에 정의되지 않은 새로운 헤더

※ 흔히 쓰이는 헤더 예시

| 예시                                     | 설명                                           |
| :--------------------------------------- | :--------------------------------------------- |
| Date: Tue, 3 Oct 1997 02:16:03 GMT       | 서버가 응답을 만들어낸 시각                    |
| Content-length: 15040                    | 15,040 Byte의 데이터를 포함한 엔티티 본문      |
| Content-type: image/gif                  | 엔티티 본문은 GIF 이미지                       |
| Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지와 HTML 수용 가능 |

**헤더를 여러 줄로 나누기**

- 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있음
- 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자가 와야 함

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
    Version 1.0
```

- 위 예에서 Server 헤더의 완전한 값은 `Test Server Version 1.0`

### 2.4 엔티티 본문

- HTTP 메시지의 세 번째 부분은 Optional한 엔티티 본문
- HTTP 메시지의 화물이라고 할 수 있음
  - 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등<br>여러 종류의 디지털 데이터를 실어 나를 수 있음

### 2.5 버전 0.9 메시지

- 오늘날 HTTP가 가지는 요청과 응답 메시지의 시초이지만 훨씬 단순한 프로토콜로 되어 있음
- 요청은 그저 메소드와 요청 URL을 가지며, 응답은 오직 엔티티로만 되어 있음
- 여전히 HTTP/0.9를 사용하는 클라이언트, 서버, 기타 애플리케이션들이 있기 때문에 이러한 제약에 대해 알고 있어야 함
