- 거의 모든 서버 및 프록시는 처리한 HTTP 트랜잭션을 요약해서 기록함
- 사용 추적, 보안, 청구, 에러 탐지 등을 위해서
- 이 장에서 배울 것들
  - 로깅
  - 어떤 HTTP 트랜잭션 정보를 기록하는지
  - 로그 포맷들

<br>

## 1. 로그란 무엇인가?

- 일반적으로 로깅을 하는 2가지 이유
  - 서버나 프록시의 문제 찾기
  - 웹 사이트 접근 통계
- 통계는 마케팅, 청구, 장비 조달 계획을 세우는 데 유용
- HTTP 트랜잭션의 모든 헤더를 로깅할 수도 있지만 감당해야 하는 트랜잭션이 장난이 아닐 수도 있음
- 일반적으로 로깅하는 필드들
  - HTTP 메소드
  - 요청받은 리소스의 URL
  - 클라이언트와 서버의 HTTP 버전
  - 응답의 HTTP 상태 코드
  - 요청과 응답 메시지의 크기
  - 트랜잭션이 일어난 시간
  - Referer와 User-Agent 헤더 값
- HTTP 메소드와 URL은 어떤 요청이 어떤 일을 하려고 했는지 가리킴
- 버전 정보는 문제가 생겼을 때 클라이언트와 서버에 관한 정보를 토대로 디버깅할 수 있게 함
- 요청/응답의 크기와 타임스탬프는 주로 계측을 위해 사용됨
  - 얼마나 많은 byte를 애플리케이션 안팎으로 송수신하는지

<br>

## 2. 로그 포맷

- 이 장에서는 가장 일반적인 몇 가지 포맷만 다룰 것
- 상용 및 오픈 소스 HTTP 애플리케이션은 대부분 표준 로그 포맷을 1개 이상 지원
- 애플리케이션 대부분이 로그 포맷을 설정할 수 있는 기능 제공

### 2.1 Common Log Format

- NCSA가 정의했으며, 대부분의 서버가 이 로그 포맷을 기본으로 사용
- 일반 로그 포맷 파일을 구문 분석하는 수많은 상용 혹은 무료 소프트웨어 도구들이 있음

※ Common Log Format의 필드들

|     필드      | 설명                                               |
| :-----------: | :------------------------------------------------- |
|  remotehost   | 요청한 컴퓨터의 호스트 명 혹은 IP 주소             |
|   username    | ident 검색을 수행했다면, 인증된 요청자 이름이 있음 |
| auth-username | 인증을 수행했다면, 인증된 요청자 이름이 있음       |
|   timestamp   | 요청 날짜와 시간                                   |
| request-line  | HTTP 요청 행을 그대로 기술                         |
| response-code | 응답으로 보내는 HTTP 상태 코드                     |
| response-size | 응답 엔티티의 Content-Length                       |

※ Common Log Format 엔트리의 몇 가지 예

```
209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024
http-guide.com - dg [03/Oct/1999:14:16:32 -0400] "GET / HTTP/1.0" 200 477
http-guide.com - dg [03/Oct/1999:14:16:32 -0400] "GET /foo HTTP/1.0" 404 0
```

### 2.2 Combined Log Format

- 아파치 같은 서버들이 지원하는, 역시 많이들 사용하는 로그 포맷
- Common Log Format과 매우 유사
  - 사실, 추가된 필드 2개를 제외하면 똑같음

|    필드    | 설명                            |
| :--------: | :------------------------------ |
|  Referer   | Referer HTTP 헤더 값            |
| User-Agent | User-Agent Referer HTTP 헤더 값 |

```
209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024 "http://www.joes-hardware.com/" "5.0: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)"
```

### 2.3 Netscape Extended Log Format

- 넷스케이프는 상용 HTTP 애플리케이션이 되면서 서버의 여러 로그 포맷을 도입했음
- NCSA 일반 로그 포맷 바탕으로, 프록시나 웹 캐시 등 HTTP 애플리케이션과 연관된 여러 환경을 지원하고자 확장
- 넷스케이프 확장 로그 포맷의 앞부분 7개 필드는 Common Log Format과 동일

※ 넷스케이프 확장 로그 포맷에서 추가된 필드들

|           필드           | 설명                                                                |
| :----------------------: | :------------------------------------------------------------------ |
|   proxy-response-code    | 프록시를 거쳤을 때, 서버에서 프록시로의 HTTP 응답 코드              |
|   proxy-response-size    | 프록시를 거쳤을 때, 서버에서 프록시로의 Content-Length              |
|   client-request-size    | 클라이언트가 프록시로 보내는 Content-Length                         |
|    proxy-request-size    | 프록시를 거쳤을 때, 프록시에서 서버로의 Content-Length              |
| client-request-hdr-size  | 클라이언트 요청 헤더의 byte 길이                                    |
| proxy-response-hdr-size  | 프록시를 거쳤을 때, 프록시에서 클라이언트로의 응답 헤더 byte 길이   |
|  proxy-request-hdr-size  | 프록시를 거쳤을 때, 프록시에서 서버로의 요청 헤더 byte 길이         |
| server-response-hdr-size | 서버 응답 헤더 byte 길이                                            |
|     proxy-timestamp      | 프록시를 거쳤을 때, 요청과 응답이 프록시를 통해 오가는 총 시간(sec) |

```
209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024 200 1024 0 0 215 260 279 254 3
```

### 2.4 Netscape Extended-2 Log Format

- HTTP 프록시와 웹 캐시 애플리케이션과 관련된 더 많은 정보 포함
- 추가된 필드들을 통해 HTTP 클라이언트와 HTTP 프록시 애플리케이션 간의 통신 설계에 도움을 줌

|           필드            | 설명                                                        |
| :-----------------------: | :---------------------------------------------------------- |
|           route           | 프록시가 클라이언트에 요청을 만들기 위해 사용하는 경로      |
| client-finish-status-code | 클라이언트의 종료 상태 코드<br>완료 - FIN / 인터럽트 - INTR |
| proxy-finish-status-code  | 프록시의 종료 상태 코드<br>완료 - FIN / 인터럽트 - INTR     |
|     cache-result-code     | 캐시 결과 코드                                              |

```
209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024 200 1024 0 0 215 260 279 254 3 DIRECT FIN FIN WRITTEN
```

※ Netscape Extended-2 Log Format 필드들이 사용하는 코드들

- route 코드
  - `DIRECT` : 리소스를 서버에서 바로 가져왔음
  - `PROXY(host:port)` : 리소스를 host라는 프록시를 통해 가져왔음
  - `SOCKS(socks:port)` : 리소스를 socks라는 SOCKS 서버를 통해 가져왔음
- 넷스케이프 종료 코드
  - `-` : 요청이 시작되지 않았음
  - `FIN` : 요청이 성공적으로 완료되었음
  - `INTR` : 요청이 클라이언트에 의해 중단되었거나 프록시/서버에 의해 종료되었음
  - `TIMEOUT` : 요청이 프록시/서버의 타임아웃에 걸렸음
- 넷스케이프 캐시 코드
  - `-` : 캐시할 수 없는 리소스
  - `WRITTEN` : 리소스를 캐시에 저장했음
  - `REFRESHED` : 리소스를 캐시했고 갱신했음
  - `NO-CHECK` : 캐시된 리소스를 반환했고 신선도 검사를 하지 않았음
  - `UP-TO-DATE` : 캐시된 리소스를 반환했고 신선도 검사를 완료했음
  - `HOST-NOT-AVAILABLE` : 캐시된 리소스를 반환했고 원 서버에 이상이 있어서 신선도 검사를 하지 않았음
  - `CL-MISMATCH` : Content-Length가 리소스 크기와 맞지 않아서 캐시 저장을 중단했음
  - `ERROR` : 어떠한 에러로 인해 리소스를 캐시에 저장하지 못했음

<br>

- 넷스케이프 애플리케이션은 **Flexible Log Format**을 가지고 있음
  - 관리자는 추가적인 설정으로 로그를 최적화할 수 있음

### 2.5 Squid 프록시 로그 포맷

- [스퀴드 프록시 캐시](http://www.squid-cache.org)는 웹 분야에서 권위 있는 프로젝트
  - 수년간 오픈 소스 커뮤니티를 통해 확장 및 개선되어 왔음
  - 애플리케이션 관리에 도움이 되는 수많은 도구들이 개발되어 온 바 있음
  - 이에 따라 수많은 차세대 프록시 캐시들이 자체 로그 포맷으로 스퀴드 포맷을 적용했음

※ 스퀴드 로그 엔트리 포맷

|        필드        | 설명                                                                                                      |
| :----------------: | :-------------------------------------------------------------------------------------------------------- |
|     timestamp      | 요청 도착 시간을 GMT 1970년 1월 1일 이후 초 단위로 기술                                                   |
|    time-elapsed    | 요청과 응답이 프록시를 통해 오고간 총 시간(ms)                                                            |
|      host-ip       | 클라이언트의 호스트 장비 IP 주소                                                                          |
| result-code/status | 프록시가 어떤 일을 했는지 스퀴드 방식으로 기술                                                            |
|        size        | 프록시에서 클라이언트로의 응답 헤더 및 본문 길이(byte)                                                    |
|       method       | 클라이언트 요청 HTTP 메소드                                                                               |
|        url         | 클라이언트 요청 URL                                                                                       |
|    rfc931-ident    | 클라이언트에 인증된 사용자 이름                                                                           |
|   hierarchy/form   | 프록시가 클라이언트로 요청을 보내면서 거친 경로<br>from 필드에는 프록시가 요청을 만들게 한 서버 이름 기술 |
|    content-type    | 프록시 응답 엔티티의 Content-Type                                                                         |

```
99823414 3001 209.1.32.44 TCP_MISS/200 4087 GET http://www.joes-hardware.com - DIRECT/proxy.com text/html
```

※ 스퀴드 결과 코드

- `TCP_HIT` : 리소스의 유효한 복제본이 캐시에서 전달되었음
- `TCP_MISS` : 리소스가 캐시에 없음
- `TCP_REFRESH_HIT` : 리소스가 캐시에 있지만 신선도 검사 필요 → 프록시는 서버와 함께 리소스의 신선도 재검사
- `TCP_REF_FAIL_HIT` : 리소스가 캐시에 있지만 신선도 검사 필요 → 재검사에 실패해서 신선하지 않은 리소스 반환
- `TCP_REFRESH_MISS` : 리소스가 캐시에 있지만 신선도 검사 필요 → 재검사 결과 신선하지 않았으므로 새 버전을 받음
- `TCP_CLIENT_REFRESH_MISS` : 클라이언트가 Pragma: no-cache 혹은 Cache-Control 지시자를 보냈음<br>→ 프록시는 리소스를 강제로 다시 가져옴
- `TCP_IMS_HIT` : 클라이언트가 리소스의 캐시된 복제본을 재검사해 달라는 조건부 요청을 했음
- `TCP_SWAPFAIL_MISS` : 프록시는 리소스가 캐시에 있다고 생각했는데, 어떠한 이유로 접근하지 못했음
- `TCP_NEGATIVE_HIT` : 캐시된 응답이 반환되었는데, 응답이 제대로 캐시되어 있지 않음<br>→ 리소스에 대한 캐싱 에러 처리
- `TCP_MEM_HIT` : 캐시에 리소스의 유효한 복사본 전달 → 리소스는 프록시 캐시의 메모리에 저장됨
- `TCP_DENIED` : 리소스에 대한 요청 거부 (대개 클라이언트가 권한이 없기 때문)
- `TCP_OFFLINE_HIT` : 캐시가 오프라인 상태에서 요청받은 리소스를 전달했음 → 스퀴드가 오프라인이면 리소스가 유효하지 않음
- `UDP_*` : 요청이 프록시에 UDP 인터페이스를 통해서 도착했음 (HTTP 규약을 사용하지 않았음)
- `UDP_HIT` : 캐시가 유효한 복사본을 전송했음
- `UDP_MISS` : 리소스가 캐시에 없음
- `UDP_DENIED` : 리소스에 대한 요청 거부 (대개 클라이언트가 권한이 없기 때문)
- `UDP_INVALID` : 프록시가 받은 요청에 문제가 있음
- `UDP_MISS_NOFETCH` : 스퀴드에서 특정 동작 모드이거나 캐시가 자주 실패할 때 사용<br>캐시 부적중 응답을 반환하고 리소스는 전송하지 않음
- `NONE` : 종종 에러와 함께 기록
- `TCP_CLIENT_REFRESH`
- `TCP_SWAPFAIL`
- `UDP_RELOADING`

<br>

## 3. 적중 계량하기

- 클라이언트와 서버 사이에 캐시가 있기 때문에, 원 서버는 언제나 직접 로그 데이터를 작성할 수 없음
- 프록시 캐시에서 자체 로그를 유지하면 이 문제를 해결할 수 있을 것
- **Hit Metering** 규약은 HTTP의 확장으로, 캐시가 정기적으로 캐시 접근 통계를 원 서버에 보고하도록 함

### 3.1 개요

- 캐시와 서버가 접근 정보를 공유하고, 캐시 리소스의 양을 제어하는 몇 가지 기초적인 HTTP 확장 기능 정의
- 완벽한 해결책이 아니며, 널리 사용되고 있지는 않음
- 그럼에도 불구하고 접근 통계 정보를 취합할 수 있고, 캐시의 이점을 유지할 수 있음

### 3.2 Meter 헤더

- 캐시 및 서버는 Meter 헤더에 사용량이나 보고에 관한 지시자들을 기술할 수 있음

|        지시자         | 약어 | 주체 | 설명                                                  |
| :-------------------: | :--: | :--: | :---------------------------------------------------- |
| will-report-and-limit |  w   | 캐시 | 캐시는 사용량을 보고하고 모든 사용 제한에 복종        |
|      wont-report      |  x   | 캐시 | 캐시는 사용 제한에 복종하지만 사용량 보고는 하지 않음 |
|      wont-limit       |  y   | 캐시 | 캐시는 사용량 보고를 하지만 사용 제한은 없음          |
|         count         |  c   | 캐시 | "사용횟수/재사용횟수" 보고 지시자                     |
|       max-uses        |  u   | 서버 | 서버가 캐시를 사용해서 응답할 수 있는 최대 횟수       |
|      max-reuses       |  r   | 서버 | 서버가 캐시를 재사용해서 응답할 수 있는 최대 횟수     |
|       do-report       |  d   | 서버 | 서버가 프록시에게 사용량 보고 요구                    |
|      dont-report      |  e   | 서버 | 서버가 사용량 보고를 원치 않음                        |
|        timeout        |  t   | 서버 | 리소스 계량에 시간 제한을 둠                          |
|       wont-ask        |  n   | 서버 | 서버가 계량 정보를 원치 않음                          |

※ 적중 계량에서 '재사용 횟수'는 클라이언트 요청을 재검증한 횟수, '사용 횟수'는 요청에 응답한 횟수

- Meter 헤더는 프록시의 요청과 서버의 응답에 담김
- 프록시는 적중 계량을 할 수 있다고 서버에게 알리고, 서버는 프록시에게 적중 횟수를 요구

<br>

## 4. 개인 정보 보호에 대해

- 많은 사용자들이 자신의 HTTP 트랜잭션이 로깅되고 있다는 것을 모를 수 있음
- 그러므로 로깅하는 웹 서버와 프록시는 최종 사용자의 개인 정보 보호에 힘써야 함
- 로깅은 사용자들의 인지나 허가가 없으면 사생활 침해가 된다는 것을 유념할 것
