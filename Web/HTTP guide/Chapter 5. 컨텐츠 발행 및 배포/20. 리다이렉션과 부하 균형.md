- HTTP는 오직 출발지와 목적지를 고려하지만 미러링된 서버, 웹 프록시, 캐시를 거쳐야 하기 때문에 단순하지 않음
- 리다이렉션 기술 → HTTP 메시지의 최종 목적지를 결정하는 네트워크 도구, 기법, 프로토콜
- 리다이렉션 기술은 보통 메시지가 프록시, 캐시, 서버 팜의 특정 웹 서버 중 어디에서 끝났는지 판별하기 위해 사용
- 리다이렉션 기술은 클라이언트의 메시지를 명시적으로 요청하지 않은 곳으로 보낼 수 있음
- 이번 장에서 배울 키워드들
  - HTTP 리다이렉션
  - DNS 리다이렉션
  - 임의 캐스트 라우팅
  - 정책 라우팅
  - IP 맥 포워딩
  - IP 주소 포워딩
  - WCCP (웹 캐시 조직 프로토콜)
  - ICP (인터캐시 커뮤니케이션 프로토콜)
  - HTCP (하이퍼텍스트 캐싱 프로토콜)
  - NECP (네트워크 요소 제어 프로토콜)
  - CARP (캐시 배열 라우팅 프로토콜)
  - WPAD (웹 프록시 자동발견 프로토콜)

<br>

## 1. 왜 리다이렉트인가?

- HTTP 애플리케이션이 언제나 원하는 3가지
  - 신뢰할 수 있는 HTTP 트랜잭션 수행
  - 지연 최소화
  - 네트워크 대역폭 절약
- 이를 보장하기 위해 흔히 웹 컨텐츠는 여러 장소에 배포됨
  - 한 곳의 장애에도 대응 가능
  - 보다 가까운 리소스에 접근 가능
  - 네트워크 혼잡도 줄어듦
- 리다이렉션: 최적의 분산된 컨텐츠 탐색을 도와주는 기법의 집합
- 리다이렉션 구현에는 부하 균형 과제가 함께 딸려옴
  - 대부분의 리다이렉션 장치들은 몇 가지 방식의 부하 균형을 포함
  - 마찬가지로 부하 균형 또한 어떤 식으로든 부하를 공유하는 서버들 중 하나에 리다이렉션되어야 함

<br>

## 2. 리다이렉트 할 곳

- 서버, 프록시, 캐시, 게이트웨이는 모두 공통적으로 서버의 특성을 갖고 있음
  - 많은 리다이렉션 기법이 이들 모두에서 동작
- 그러나 특정 종류의 종단만을 위해 특별히 설계된 기법들이 따로 있음 (나중 배울 내용)
- 웹 서버는 IP별로 요청을 다룸
  - 요청을 분산한다는 것은 같은 URL에 대한 각 요청을 최적의 웹 서버로 보내겠다는 뜻
- 프록시는 프로토콜별로 요청을 다룸
  - 이상적으로 프록시 이웃의 모든 HTTP 트래픽은 프록시를 거쳐야 함 (통신 비용 절약)
  - 프록시로의 리다이렉트는 주 진입로의 트래픽을 지름길로 빨아들이는 것

<br>

## 3. 리다이렉션 프로토콜의 개요

- 리다이렉션의 목표: HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것
  - 메시지가 오가는 라우팅 장치에 영향을 받게 됨
- 메시지를 리다이렉트하는 메커니즘들: 브라우저 설정, DNS, TCP/IP 라우팅, HTTP

|                메커니즘                 | 작동 방식                                                   | 재 라우팅 근거                                           | 제약사항                                                |
| :-------------------------------------: | :---------------------------------------------------------- | :------------------------------------------------------- | :------------------------------------------------------ |
|             HTTP 리다이렉션             | 첫 번째 웹 서버에서 리다이렉트를 선택하게 함                | 라운드 로빈 부하 균형, latency 최소화, 최단 거리 선정 등 | 모든 트랜잭션이 추가 리다이렉트를 포함할 수 있음        |
|             DNS 리다이렉션              | DNS 서버가 어떤 IP 주소를 사용할지 결정                     | 라운드 로빈 부하 균형, latency 최소화, 최단 거리 선정 등 | DNS 서버 설정 필요                                      |
|          임의 캐스트 어드레싱           | 여러 서버가 같은 IP 주소 사용                               | 라우터들은 내장된 최단거리 라우팅 기능 사용              | 라우터 설정 필요, 주소 충돌 위험                        |
|              IP MAC 포워딩              | 스위치, 라우터 등 네트워크 요소가 패킷의 목적지 주소를 읽음 | 대역폭 절약, QOS(Quality of Service) 개선                | 서버나 프록시는 반드시 한 홉 거리에 있을 것             |
|             IP 주소 포워딩              | 스위치가 패킷의 목적지 포트 평가                            | 대역폭 절약, QOS 개선                                    | 서버나 프록시가 클라이언트의 IP 주소를 잃어버릴 수 있음 |
|          명시적 브라우저 설정           | 웹 브라우저가 가까운 프록시에게 HTTP 메시지를 보내도록 설정 | 대역폭 절약, QOC 개선                                    | 브라우저 설정 능력에 의존                               |
|     PAC (Proxy Auto-Configuration)      | 웹 브라우저가 설정 서버로부터 PAC 파일 검색                 | 대역폭 절약, QOC 개선                                    | 브라우저가 설정 서버에 질의를 보낼 수 있을 것           |
| WPAD (Web Proxy Autodiscovery Protocol) | 웹 브라우저가 설정 서버에게 PAC 파일에 대한 URL 질의        | 설정 서버가 URL 결정                                     |                                                         |
| WCCP (Web Cache Coordination Protocol)  | 라우터가 패킷의 목적지 주소를 평가                          | 대역폭 절약, QOC 개선                                    | 브라우저가 반드시 WCCP를 지원해야 함                    |
|      ICP (Internet Cache Protocol)      | 프록시 캐시가 형제 캐시에게 요청 받는 컨텐츠에 대해 질의    | 캐시를 통해 원 서버보다 빠르게 얻어냄                    | 캐시 적중이 아닐 수도 있게 됨                           |
|   CARP (Cache Array Routing Protocol)   | 캐시 컨텐츠 분산                                            | 캐시를 통해 원 서버보다 빠르게 얻어냄                    | CARP 설정에 동의할 것                                   |
|   HTCP (Hyper Text Caching Protocol)    | 프록시 캐시가 형제 캐시에게 요청 받는 컨텐츠에 대해 질의    | 캐시를 통해 원 서버보다 빠르게 얻어냄                    |                                                         |

<br>

## 4. 일반적인 리다이렉션 방법

### 4.1 HTTP 리다이렉션

- 몇몇 웹 사이트는 HTTP 리다이렉션을 이용해서 간단하게 부하를 분산
- 서버가 직접 가용한 것들 중 부하가 가장 적은 컨텐츠 서버를 찾아서 리다이렉트
- 웹 서버가 광범위하게 분산되어 있다면 '최선의' 가용 서버를 결정하는 것이 까다로움
  - 서버 부하
  - 인터넷 상에서의 브라우저와 서버 간의 거리도 계산해야 함
- 장점
  - 리다이렉트하는 서버가 클라이언트의 IP 주소를 알고 있어서, 정보에 근거한 판단을 내릴 수 있음
- 단점
  - 어떤 서버로 리다이렉트할지 결정하기 위해 원 서버는 상당히 많은 처리를 하게 됨
  - 사용자는 페이지에 접근할 때마다 2번의 왕복 필요
  - 리다이렉트 서버가 고장나면 사이트도 고장남
- 이러한 약점 때문에 HTTP 리다이렉션은 보통 몇몇 다른 리다이렉션 기법과 함께 조합해서 사용됨

### 4.2 DNS 리다이렉션

- DNS 분석자가 될 수 있는 것들
  - 클라이언트의 운영체제
  - 클라이언트의 네트워크에 있는 DNS 서버
- DNS는 하나의 도메인에 여러 IP 주소가 결부되는 것을 허용
- DNS 분석자는 여러 IP 주소를 반환하도록 설정하거나 프로그래밍할 수 있음

※ 라운드 로빈 - 가장 쉬운 DNS 결정 알고리듬

![DNS 기반 리다이렉션](https://user-images.githubusercontent.com/75058239/210125469-25d085bb-9041-4f51-bad9-0653a24849fe.png)

**_DNS 라운드 로빈_**

- 웹 서버 팜 전체에 대한 부하 균형 유지를 위해 DNS 호스트 명 분석 기능 사용
- 클라이언트의 상대적 위치나 서버의 스트레스 상태를 고려하지 않음

**_다중 주소와 라운드 로빈 주소 순환_**

- 대부분의 DNS 클라이언트는 그냥 다중 주소 집합의 첫 번째 주소 사용
- 부하 균형을 위해서 룩업이 끝날 때마다 주소를 순환

**_DNS 캐싱의 효과_**

- 하지만 DNS 룩업의 결과는 애플리케이션, 운영체제 등 자식 DNS 서버에 의해 기억되고 재사용될 수 있음
  - 한 번의 DNS 룩업을 하고, 그 주소를 몇 번이고 다시 사용
  - DNS 룩업 비용을 줄일 수 있기 때문
  - 같은 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있기 때문
- 그렇기 때문에 DNS 라운드 로빈은 일반적으로 하나의 클라이언트로 인한 부하를 제대로 분산하지 못함
- 그래도 나름 여러 클라이언트의 부하 총량을 분산하는 적절한 작업은 수행
  - 클라이언트 수가 어느 정도 이상만 되면, 부하는 모든 서버에 걸쳐 나름대로 잘 분산될 것

**_다른 DNS 기반 리다이렉션 알고리듬_**

- 부하 균형 알고리듬: 웹 서버 로드를 추적해서 가장 로드가 적은 웹 서버를 목록 최상위에 둠
- 근접 라우팅 알고리듬: 서버 팜이 지리적으로 분산되어 있을 때, 사용자를 근처의 웹 서버로 보냄
- 결함 마스킹 알고리듬: 네트워크 건강 상태를 모니터링해서 장애를 피하는 라우팅

※ authoritative server

<img width="607" alt="권위 있는 DNS 서버" src="https://user-images.githubusercontent.com/75058239/210125471-d4adf985-ea3c-43a2-8da7-49104c11511f.png">

- 컨텐츠 제공자의 통제하에 있는 권위 있는 서버를 사용하는 방식
- 인접한 서버를 찾는 서비스들을 위한 모델
- 단점: 권위 있는 서버가 결정을 내리기 위해 사용하는 유일한 정보가 클라이언트의 IP 주소가 아닌 로컬 DNS 서버의 IP 주소

### 4.3 임의 캐스트 어드레싱

- 지리적으로 흩어져 있는 웹 서버들이 동일한 IP 주소를 가짐
- 클라이언트의 요청을 가장 가까운 서버로 보내주기 위해 백본 라우터의 '최단거리' 라우팅 능력에 의존
- 방식 중 하나: 라우터 스스로가 웹 서버에게 인접한 백본 라우터를 향하는 라우터라고 광고하게 하는 것
  - 백본 라우터는 패킷을 받고 해당 IP 주소와 가장 가까운 라우터를 탐색
  - 라우터는 스스로 어떤 주소를 위한 라우터인지 광고한 상태이기 때문에, 백본 라우터는 해당 라우터에게 패킷을 전송
- 임의 캐스트 어드레싱은 여전히 실험적인 기법
  - 서버는 반드시 '라우터의 언어'로 말해야 함
  - 인터넷 주소는 기본적으로 한 서버에 하나임을 가정하기 때문에 주소 충돌을 반드시 다룰 수 있어야 함
    - route leaks로 알려진 심각한 문제를 유발할 수 있는 요인
- 백본 네트워크를 제어하는 컨텐츠 제공자들을 위한 하나의 솔루션 정도로 기억해둘 것

### 4.4 IP MAC 포워딩

- 이더넷 네트워크에서, HTTP 메시지는 주소가 붙은 데이터 패킷 형식
- 각 패킷은 출발지, 목적지, IP 주소, TCP 포트번호로 이루어진 Layer 4 구조
- 각 패킷은 또한 Layer 2 장비가 주목하는 주소인 MAC(Media Access Control) 주소도 가짐
  - Layer 2 장비는 특정 MAC 주소의 패킷을 받아서 특정 MAC 주소로 포워딩하는 것
- 스위치는 Layer 4 주소를 검사해서 라우팅할 수 있음
  - 예시: 80번 포트로 향하는 모든 웹 트래픽을 프록시로 보낼 수 있음
    - 여기에서 캐시 신선도를 검사하고 요청을 원 서버에 보내야 할지 결정할 수도 있는 것
- MAC 포워딩을 지원하는 Layer 4 스위치는 보통 여러 프록시 캐시를 활용해서 부하 균형을 유지
- hop-by-hop 만 가능하기 때문에 서버나 프록시는 스위치와 한 홉 거리에 있어야 함

### 4.5 IP 주소 포워딩

- Layer 4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱 검증 후 목적지 IP 주소 변경에 따라 라우팅
  - MAC 포워딩보다 좋은 점: 목적지 서버가 한 홉 거리에 있을 필요 X
- 그저 스위치에서 업스트림 위치 판별이 가능하면 일반적인 Layer 3 end-to-end 라우팅이 됨
- NAT(Network Address Translation)라고도 불림
- 그러나 **라우팅 대칭성** 문제가 있음
  - TCP 커넥션을 받는 스위치는 커넥션을 통해 반드시 응답을 돌려주어야 함
  - 그러므로 모든 응답은 반드시 스위치에게 돌아가야 함
- 응답의 귀환 경로 제어 방법
  - 패킷의 출발지 IP 주소를 스위치의 IP 주소로 변경
    - 스위치와 서버 사이 네트워크 설정과 무관하게 응답 패킷을 스위치로 전송
    - 출발지와 목적지 IP 주소 양쪽을 번역해주는 IP 전달 장치를 완전 NAT라고 부름
    - 클라이언트의 IP 주소를 웹 서버가 알 수 없게 할 수 있음
  - 출발지 IP 주소를 클라이언트 IP 주소로 그대로 남겨둠
    - 서버에서 스위치를 거치지 않고 클라이언트로 바로 가는 경로가 없어야 함
    - half NAT라고도 불림
    - 장점: 서버가 클라이언트의 IP 주소를 얻을 수 있음
    - 단점: 클라이언트와 서버 사이 네트워크 전체에 약간의 통제 필요

### 4.6 NECP (Network Element Control Protocol)

- 라우터, 스위치 등 NE(Network Elements)가 웹 서버, 프록시 캐시 등 SE(Server Elements)와 대화할 수 있게 해줌
- 부하 균형을 명시적으로 지원하지는 않음
  - 다만 SE는 NE에게 부하 균형 정보를 제공하여, SE가 적합하다고 판단한 대로 NE가 부하 균형을 유지할 수 있도록 함
- MAC forwarding, GRE encapsulation, NAT 등 패킷을 전달하는 여러 방법 제공
- 예외 개념 지원
  - SE는 특정 출발지 IP 주소의 서비스 가능 여부 판단 가능
  - 해당 주소들을 NE로 보낼 수 있음
  - 그러면 NE는 해당 IP 주소로부터의 요청을 원 서버에 전달 가능

**_NECP 메시지_**

|          메시지          | 전송 주체 | 의미                                            |
| :----------------------: | :-------: | :---------------------------------------------- |
|        NECP_NOOP         |           | 작업 없음                                       |
|        NECP_INIT         |    SE     | NE와 통신 개시, 반드시 NE 포트를 알고 있어야 함 |
|      NECP_INIT_ACK       |    NE     | 확인했음                                        |
|      NECP_KEEPALIVE      |  NE / SE  | peer가 살아있는지 확인                          |
|    NECP_KEEPALIVE_ACK    |  NE / SE  | keep-alive에 대답                               |
|        NECP_START        |    SE     | 트래픽 받을 준비 완료, 포트 지정 가능           |
|      NECP_START_ACK      |    NE     | 확인했음                                        |
|        NECP_STOP         |    SE     | 트래픽 전송 중단 요청                           |
|      NECP_STOP_ACK       |    NE     | 전송 중단을 알림                                |
|    NECP_EXCEPTION_ADD    |    SE     | NE가 가진 목록에 하나 이상의 예외 추가 요청     |
|  NECP_EXCEPTION_ADD_ACK  |    NE     | 예외 추가 요청 승인                             |
|    NECP_EXCEPTION_DEL    |    SE     | NE가 가진 목록에서 하나 이상의 예외 삭제 요청   |
|  NECP_EXCEPTION_DEL_ACK  |    NE     | 예외 삭제 요청 승인                             |
|   NECP_EXCEPTION_RESET   |    SE     | NE의 예외 목록 전체 삭제 요청                   |
| NECP_EXCEPTION_RESET_ACK |    NE     | 예외 전체 삭제 요청 승인                        |
|   NECP_EXCEPTION_QUERY   |    SE     | NE가 가진 전체 예외 목록 문의                   |
|   NECP_EXCEPTION_RESP    |    NE     | 예외 목록 응답                                  |

<br>

## 5. 프록시 리다이렉션 방법

- 네트워크 상의 프록시 캐시를 이용하면 훨씬 빠르게 컨텐츠를 전달할 수 있음
- **클라이언트들이 어떻게 프록시로 가는 길을 아는가?**
  - 명시적인 브라우저 설정
  - 동적인 자동 설정
  - 자연스러운 가로채기
- 프록시 캐시는 클라이언트의 요청을 다른 프록시로 리다이렉트 가능
- 피어 프록시 캐시 리다이렉션을 위해 사용되는 프로토콜들인 ICP, CARP, HTCP에 대해 논의할 것

### 5.1 명시적 브라우저 설정

- 대부분의 브라우저에는 프록시 서버에 접촉하기 위해 프록시 이름, IP 주소, 포트번호를 설정할 수 있는 풀다운 메뉴 존재
- 사용자 설정에 따라 모든 요청에 대해 프록시에 접촉하게끔 설정 가능
- 요즘에는 미리 설정이 되어 있는 브라우저를 다운로드받게끔 되어 있음
- 2가지 단점
  - 프록시가 응답하지 않더라도 원 서버와 접촉하지 않음
  - 네트워크 아키텍처 변경 시, 모든 최종사용자에게 변경사항을 전파하기 까다로움

### 5.2 PAC (Proxy Auto-Configuration)

- 브라우저들이 URL 별로 접촉해야 할 프록시를 지정한 PAC 파일을 찾도록 함
- 브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어야 함

```js
function FindProxyForURL(url, host)
```

- PAC 파일은 위 함수를 반드시 정의해야 하는 JS 파일
  - 브라우저는 위 함수를 요청된 URL마다 호출
  - 함수 반환값은 브라우저가 어디서 URL을 요청해야 하는지 지정한 문자열
    - 프록시 목록 혹은 원 서버로 직통해야 함을 뜻하는 "DIRECT"
  - DNS 주소, 서브넷, 심지어 요일 및 시각 같은 호스트 명 관련 여러 매개변수에 근거해서 프록시를 선택하도록 요구할 수 있음
- 오늘날 PAC는 미리 설정된 브라우저 같이 몇몇 주요 ISP들에 의해 사용되고 있음

### 5.3 WPAD (Web Proxy Autodiscovery Protocol)

- 목적: 웹 브라우저가 근처의 프록시를 찾아내서 사용할 수 있도록 하는 것
- 일반적인 문제점
  - 선택할 수 있는 발견 프로토콜이 여러 개
  - 프록시 사용에 대한 설정이 브라우저들마다 다름

**_PAC 파일 자동발견_**

- HTTP 클라이언트가 PAC 파일의 위치를 알아내고 해당 파일을 통해 적절한 프록시 서버 이름을 알아낼 수 있게 해줌
- PAC 파일이 제공하는 추가 기능들을 위해, WPAD는 프록시 서버 이름을 직접적으로 알아내지는 않음
  - PAC 파일 추가 기능들: 부하 균형, 서버들의 배열을 활용한 라우팅, 자동화된 장애 대응 등
- WPAD 프로토콜은 PAC 파일 URL을 찾아냄
  - PAC 파일 URL은 설정 URL(CURL)이라고도 알려져 있음
- WPAD 프로토콜을 구현한 HTTP 클라이언트가 하는 일
  - WPAD를 통해 PAC 파일 CURL 탐색
  - URL에 해당하는 PAC 파일(CFILE)을 가져옴
  - PAC 파일 실행
  - PAC 파일이 반환해준 프록시 서버에 HTTP 요청 전송

**_WPAD 알고리듬_**

- PAC 파일 CURL 결정을 위해 여러 리소스 발견 기법들이 사용됨
- 모든 조직이 모든 기법을 사용할 수 있는 것은 아니고, 여러 발견 기법을 지정해야 함
- WPAD 클라이언트는 CURL을 얻는 작업에 성공할 때까지 각각의 기법을 하나씩 시도
- 오늘날 WPAD 명세에서 정한, 순서대로 실행할 기법들
  - DHCP(Dynamic Host Configuration Protocol)
  - SLP(Service Location Protocol)
  - DNS에게 잘 알려진 호스트 명
  - DNS의 SRV 레코드
  - TXT 레코드의 DNS 서비스 URL들
- 위 5가지 메커니즘 중, WPAD 클라이언트에게는 오직 DHCP와 DNS에 잘 알려진 호스트 명 기법만 요구됨
  - 만약 DHCP 발견이 실패했다면 클라이언트는 SLP를 직접할 수 없으므로 DNS 기반 메커니즘으로 옮겨가야 함
  - 다음 절에서 계속...
- 만약 PAC 파일이 CURL에서 성공적으로 발견되지 못한 경우
  - 클라이언트는 정의되어 있던 리소스 발견 요청의 연쇄가 중단되었던 시점부터 다시 시작
- 모든 발견 메커니즘을 시도한 후에도 PAC 파일을 찾지 못한 경우
  - WPAD 프로토콜 실패 → 프록시 서버를 사용하지 않기로
- 클라이언트가 WPAD 기법 실행 순서들을 하나씩 거쳐갈수록, DNS 쿼리 QNAME은 점점 덜 구체적이게 됨
  - 클라이언트는 가능한 한 구체적인 설정 정보를 찾되, 찾지 못한 경우 덜 구체적인 정보라도 취함
- 모든 DNS 룩업은 `wpad` 접두어가 붙은 QNAME을 가짐
  - wpad 접두어: 요청 받은 리소스 종류를 가리킴

※ 'johns-desktop.development.foo.com'이라는 호스트 명을 찾는 과정

- DHCP
- SLP
- "QNAME=wpad.development.foo.com"에 대한 DNS A 룩업
- "QNAME=wpad.development.foo.com"에 대한 DNS SRV 룩업
- "QNAME=wpad.development.foo.com"에 대한 DNS TXT 룩업
- "QNAME=wpad.foo.com"에 대한 DNS A 룩업
- "QNAME=wpad.foo.com"에 대한 DNS SRV 룩업
- "QNAME=wpad.foo.com"에 대한 DNS TXT 룩업

**_DHCP를 이용한 CURL 발견_**

- 이 메커니즘 동작을 위해, DHCP 서버는 반드시 CURL을 저장하고 있어야 함
- WPAD 클라이언트는 DHCP 질의를 DHCP 서버에 보냄으로써 CURL을 얻어냄
- CURL은 DHCP 옵션 코드 252에 들어있음
  - DHCP 옵션 코드 252는 임의 길이의 문자열
  - 이 문자열은 적절한 PAC 파일을 가리키는 URL을 포함
  - `http://server.domain/proxyconfig.pac`
- DHCP 프로토콜은 RFC 2131에 자세히 나와 있음
- WPAD 클라이언트는 스스로 초기화 과정을 통해 이미 DHCP 질의를 했고, DHCP 서버에서도 이미 그 값을 제공했을 수 있음
- 클라이언트가 OS의 API를 통해 그 값을 얻을 수 없다면 DHCPINFORM 메시지를 DHCP 서버에 질의하여 그 값을 얻어냄

**_DNS A 레코드 룩업_**

※ DNS 별칭들에 대한 설명은 [RFC 2219](https://datatracker.ietf.org/doc/html/rfc2219) 참조

- 이 메커니즘 동작을 위해, DNS 서버는 반드시 알맞은 프록시 서버 IP 주소들을 저장하고 있어야 함
- WPAD 클라이언트는 A 레코드 룩업을 DNS 서버로 보냄으로써 CURL을 얻어냄
  - 룩업이 성공하면 적절한 프록시 서버의 IP 주소 획득
- WPAD 클라이언트의 구현체는 이 메커니즘을 '구현'해야 함
  - A 레코드에 대한 기초적인 DNS 룩업만을 수행할 정도로 단순해야 함

```
QNAME=wpad.TGTDOM., QCLASS=IN, QTYPE=A
```

- 룩업에 성공하면 WPAD 클라이언트가 구축한 URL의 IP 주소 획득

**_PAC 파일 가져오기_**

- 후보 CURL 생성 후, WPAD 클라이언트는 보통 해당 CURL에 대한 GET 요청을 만듦
  - 이 때 자신이 다룰 수 있는 적절한 CFILE 포맷 정보가 담긴 Accept 헤더를 포함해야 함

```http
Accept: application/x-ns-proxy-autoconfig
```

- 만약 CURL 결과가 리다이렉트라면, 리다이렉트가 향하는 곳이 클라이언트의 최종 목적지

**_언제 WPAD를 실행하는가_**

- 적어도 다음 중 하나의 상황에서는 수행되어야 함
  - 웹 클라이언트가 시작될 때마다
    - WPAD는 오직 첫 인스턴스 시작 때만 수행 → 이후 인스턴스는 설정을 물려받음
  - 클라이언트 호스트의 IP 주소가 변경된 네트워킹 스택으로부터 어떤 언급을 받을 때마다
- 웹 클라이언트는 스스로의 환경에서 어느 쪽이 타당한지에 따라 둘 중 하나를 선택하면 됨
- 클라이언트는 이전에 받아둔 PAC 파일이 HTTP 만료 규칙에 따라 만료되었을 때 반드시 발견 사이클을 시도해봐야 함
  - PAC 파일이 만료될 때마다 WPAD 프로세스를 재시작!
- 클라이언트는 PAC 파일에서 프록시를 찾을 수 없거나, 설정된 프록시가 작동하지 않을 때에도 WPAD 프로세스를 재시작할 수 있음
- 클라이언트가 현재 PAC 파일을 무효화하기로 했을 때는 반드시 전체 WPAD 프로토콜을 재실행해야 함
  - 이 프로토콜은 If-Modified-Since 조건부 요청으로 PAC 파일 가져오기를 지원하지 않음!
- WPAD protocol broadcast 혹은 multicast communication 과정에서 몇 차례 네트워크 왕복이 필요할 수 있음
  - 이런 때에도 WPAD 프로토콜이 앞서 명시한 빈도보다 더 자주 동작해서는 안됨

**_타임아웃_**

- WPAD의 여러 발견 단계를 거칠 때, 클라이언트는 각 단계가 일정 시간 내에 끝나는지 반드시 확인해야 함
- 가급적 각 단계를 10초 이내로 제한하는 것이 합리적
  - 네트워크 특성에 맞는 더 적절한 값을 선택할 수 있음

**_관리자를 위한 고려사항_**

- 클라이언트 호환을 위해 반드시 구현해야 하는 것은 DHCP와 DNS A 레코드 검색
- 관리자들 역시 이 둘 중 하나를 설정해야 함
- 모든 것은 클라이언트가 근처에 있는 프록시 서버를 찾도록 돕기 위함
- WPAD 프레임워크에서 '근접성'을 결정할 때 고려할 사항들
  - DHCP 서버들은 서브넷에 따라 다른 답을 돌려줄 수 있음
    - 그 답들은 또한 클라이언트의 `cipaddr` 필드나 식별자 옵션에 대한 결정에도 근거함
  - DNS 서버는 도메인 접미사에 따라 SRV/A/TXT 리소스 레코드(RRs)를 반환하도록 설정될 수 있음
  - CURL 요청을 다루는 웹 서버는 User-Agent 헤더, Accept 헤더,<br>클라이언트의 IP/subnet/hostname, 인근 프록시 서버들의 위상기하학적 배치 등에 근거하여 결정을 내릴 수 있음
    - 이는 CURL을 다루기 위해 생성된 CGI 실행프로그램 안에서 일어날 수 있음
    - 이는 프록시 서버 안에서 일어날 수 있음
  - PAC 파일은 클라이언트가 대안 중 하나를 실시간으로 선택할 수 있을 때 충분한 표현력을 지니게 될 수 있음
    - CARP의 경우, 이 전제를 바탕으로 캐시 배열 지원

<br>

## 6. 캐시 리다이렉션 방법

- 캐싱 프록시 서버를 위해 사용되는 리다이렉션 기법은 보다 복잡함
  - 신뢰성, 고성능, content-aware-dispatching

### 6.1 WCCP(Web Cache Coordination Protocol) 리다이렉션

- 시스코 시스템즈에서 웹 라우터들이 웹 트래픽을 프록시 캐시로 리다이렉트하기 위해 개발
- 라우터들과 캐시 사이의 대화를 관리해서, 라우터가 캐시를 검사하고 특정 트래픽을 특정 캐시로 보낼 수 있게 함
- WCCP2 버전은 개방된 프로토콜이므로, 이에 대해 이야기할 것

**_WCCP 리다이렉션 동작_**

- WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통할 수 있는 캐시가 포함된, _네트워크_ 필요
- 라우터들의 집합과 대상이 되는 캐시들이 WCCP 서비스 그룹 구성
  - 서비스 그룹의 설정은 어떤 트래픽이 어디로 어떻게 보내지며, 부하가 캐시들 사이에서 어떻게 분산되어야 하는지 명시
- 만약 서비스 그룹이 HTTP 트래픽 리다이렉션 설정이 되어 있으면, 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보냄
- HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 라우터는 요청 처리를 위해 서비스 그룹의 캐시 중 하나 선택
  - 요청 IP 주소의 해시값이나 마스크/값 집합 pairing 스킴 중 하나에 근거
- 라우터는 요청 패킷을 캐시 IP 주소와 함께 캡슐화하거나 IP MAC 포워딩하여 캐시로 보냄
- 만약 캐시가 요청을 처리할 수 없다면, 패킷은 평범하게 포워딩되기 위해 라우터로 돌아옴
- 서비스 그룹 구성원들은 지속적으로 다른 구성원들의 가용성 확인을 위해 heartbeat 메시지 교환

**_WCCP2 메시지들_**

|      메시지 이름      |                      전송 주체                       | 포맷                                                                                                                                                                                  | 전달 정보                                                                                                                                                             |
| :-------------------: | :--------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    WCCP2_HERE_I_AM    |                   cache to router                    | WCCP 메시지 헤더<br>보안 정보 구성요소<br>서비스 정보 구성요소<br>웹 캐시 식별 구성요소<br>웹 캐시 뷰 정보 구성요소<br>능력 정보 구성요소 (optional)<br>명령 확장 구성요소 (optional) | 캐시가 트래픽을 받을 수 있다고 말해줌<br>메시지는 캐시 서비스 그룹 정보 전체를 담음<br>캐시는 서비스 그룹 가입 후<br>바로 메시지를 서비스 그룹의 모든 라우터에게 보냄 |
|    WCCP2_I_SEE_YOU    |                   router to cache                    | WCCP 메시지 헤더<br>보안 정보 구성요소<br>서비스 정보 구성요소<br>웹 캐시 식별 구성요소<br>웹 캐시 뷰 정보 구성요소<br>능력 정보 구성요소 (optional)<br>명령 확장 구성요소 (optional) | 위 메시지에 응답하는 메시지<br>패킷 포워딩 방법, 할당 방법,<br>패킷 반환 방법, 보안 협상                                                                              |
| WCCP2_REDIRECT_ASSIGN |              designated cache to router              | WCCP 메시지 헤더<br>보안 정보 구성요소<br>서비스 정보 구성요소<br>할당 정보 구성요소 or<br>대체 할당 구성요소                                                                         | 부하 균형을 위한 할당<br>버킷 정보, 마스크/값 집합 pairing 정보 전송                                                                                                  |
|  WCCP2_REMOVAL_QUERY  | router to cache<br>(after 2.5 X HERE_I_AM_T seconds) | WCCP 메시지 헤더<br>보안 정보 구성요소<br>서비스 정보 구성요소<br>라우터 질의 구성요소                                                                                                | 메시지를 정기적으로 받지 못했을 경우 전송<br>캐시 서비스 그룹 제거 여부 확인 용도<br>캐시는 HERE_I_AM_T/10초 간격으로<br>3번 동일한 메시지를 보내야 함                |

**_메시지 구성요소_**

- WCCP2 메시지 → 헤더 + 구성요소
- 헤더 정보
  - 메시지 종류
  - WCCP 버전
  - 메시지 길이(헤더 미포함)
- 구성요소
  - 종류와 길이를 서술하는 4 byte 헤더로 시작
    - 구성요소 길이는 헤더 미포함

※ 메시지 구성요소

|     구성요소      | 설명                                                                                                             |
| :---------------: | :--------------------------------------------------------------------------------------------------------------- |
|     보안 정보     | `WCCP2_NO_SECURITY (0)`<br>`WCCP2_MD5_SECURITY (1)`                                                              |
|    서비스 정보    | `WCCP2_SERVICE_STANDARD (0)`<br>`WCCP2_SERVICE_DYNAMIC (1)`                                                      |
| 라우터 식별 정보  | 라우터의 IP 주소와 ID,<br>라우터가 의사소통하고자 하는 모든 웹 캐시를 IP 주소순으로 나열                         |
| 웹 캐시 식별 정보 | 웹 캐시 IP 주소 및 리다이렉션 해시 테이블 매핑                                                                   |
|  라우터 뷰 정보   | 서비스 그룹에 대한 라우터 시각                                                                                   |
|  웹 캐시 뷰 정도  | 서비스 그룹에 대한 웹 캐시 시각                                                                                  |
|     할당 정보     | 특정 해싱 버켓에 대한 웹 캐시 할당                                                                               |
| 라우터 질의 정보  | 라우터 IP 주소, 질의를 받은 웹 캐시 주소,<br>웹 캐시로부터 확인 메시지를 받은 마지막 라우터 ID                   |
|     능력 정보     | 지원하는 패킷 포워딩, 부하 균형, 패킷 반환 방법<br>라우터에게 웹 캐시가 선호하는 방법을 알려주기 위해서도 사용됨 |
|     대체 할당     | 부하 균형을 위한 해시 테이블 할당 정보                                                                           |
|      할당 맵      | 서비스 그룹을 위한 마스크/값 집합 요소                                                                           |
|     명령 확장     | 캐시들이 라우터에게 정지 상태를 알리기 위해 사용<br>라우터가 캐시 정지 인지를 알리기 위해서도 사용               |

**_서비스 그룹_**

- WCCP 메시지를 교환할 수 있는 라우터와 캐시들의 집합
- 라우터들은 웹 트래픽을 서비스 그룹의 캐시로 보냄
- 서비스 그룹의 설정은 어떻게 트래픽이 서비스 그룹의 캐시들로 분산되는지 결정
- 라우터와 캐시는 Here I Am과 I See You 메시지를 통해 서비스 그룹 설정 정보 교환

**_GRE 패킷 캡슐화_**

- WCCP 지원 라우터들은 HTTP 패킷을 특정 서버 IP 주소와 함께 캡슐화해서 해당 서버로 리다이렉트
- 패킷 캡슐화는 GRE(Generic Router Encapsulation)임을 나타내는 IP 헤더 proto 필드 포함
- proto 필드의 존재는 수신 측 프록시에게 패킷이 캡슐화된 패킷을 가지고 있음을 말해줌
- 패킷의 캡슐화 덕에 클라이언트 IP 주소를 잃어버리지 않음

**_WCCP 부하 균형_**

- WCCP 라우터는 라우팅 뿐만 아니라 부하 균형 유지에도 사용됨
- WCCP 라우터와 수신 장비들은 hearbeat 메시지를 서로 교환
- 만약 특정 수신 장비가 heartbeat 메시지를 보내지 않으면 라우터는 해당 장비로 리다이렉트하는 대신 바로 서버로 전송

<br>

## 7. Internet Cache Protocol (ICP)

- 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있게 함
  - 캐시가 요청 받은 컨텐츠를 갖고 있지 않다면, 근처의 형제 캐시 중에서 해당 컨텐츠를 찾아봄
- 일종의 **캐시 클러스터링 프로토콜**이라 할 수 있음
- 한 차례 이상의 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정할 수 있으므로, **리다이렉션 프로토콜**이기도 함
- ICP는 객체 발견 프로토콜
  - 캐시는 이 프로토콜을 사용해서 근처의 캐시 모두에게 특정 URL을 갖고 있는지 한번에 물어봄
  - 근처 캐시들은 "HIT" 또는 "MISS"라고 응답
  - 물어봤던 캐시는 객체(URL)를 갖고 있는 이웃 캐시에 대한 HTTP 커넥션을 열 수 있음
- ICP는 단순하고 가벼움
  - ICP 메시지는 파싱하기 쉽도록 byte 순서에 따라 32 bit 크기로 맞춰진 구조체
  - 메시지들은 효율을 위해 UDP 다이어그램으로 전송
    - UDP는 신뢰할 수 없는 프로토콜이며, 데이터 전송 중 파괴 위험이 있음
    - 그러므로 ICP 프로그램은 데이터 손실을 감지할 수 있도록 타임아웃이 설정되어야 함

**OP 코드**

- ICP 메시지의 의미를 서술하는 8 bit 값
- `ICP_OP_QUERY` : 요청 메시지
- `ICP_OP_HIT` `ICP_OP_MISS` : 응답 메시지

**버전**

- ICP 프로토콜의 버전 번호를 서술하는 8 bit 값
- Squid에서 사용하는 ICP 버전은 버전 2 → RFC 2186에 서술되어 있음

**메시지 길이**

- ICP 메시지 총 길이를 byte 단위로 나타낸 것
- 이 값을 저장할 공간이 16 bit
  - 따라서 ICP 메시지 크기는 16,383 byte를 넘을 수 없음
  - URL은 보통 16KB보다 짧음

**요청 번호**

- ICP 지원 캐시는 동시에 여러 요청 및 응답을 추적하기 위해 요청 번호 사용
- ICP 응답 메시지는 항상 응답을 유발한 ICP 요청 메시지와 같은 요청 번호를 담고 있어야만 함

**옵션**

- 32 bit로 된 ICP 동작을 변경하는 플래그를 담은 비트 백터
- ICPv2에서 정의하는 2개의 플래그
  - 둘 다 `ICP_OP_QUERY` 요청을 수정
  - `ICP_FLAG_HIT_OBJ` : 문서 데이터가 ICP 응답으로 돌아오는 것을 가능하게 할 것인지 여부 결정
  - `ICP_FLAG_SRC_RTT` : 형제 캐시가 측정한 원 서버로의 왕복 시간에 대한 추정 요청

**옵션 데이터**

- 옵션 기능을 위해 예약된 32 bit 값
- ICPv2는 옵션 데이터의 하위 16 bit를 형제와 원 서버 간의 왕복 시간 측정값을 담아놓는데 사용
  - 이 측정값은 optional

**발송자 호스트 주서**

- 메시지 발송자의 IP 주소를 담은 32 bit 값
- 역사적인 이유로 존재하며 실제로 사용되지 않음

**페이로드**

- 페이로드 컨텐츠는 메시지 형태에 따라 달라짐
  - `ICP_OP_QUERY` : 원래 요청자의 호스트 주소와 `NUL`로 끝나는 URL이 순서대로 들어있음
  - `ICP_OP_HIT_OBJ` : `NUL`로 끝나는 URL, 16 bit 객체 크기, 객체 데이터가 순서대로 들어있음

※ ICP는 RFC 2186과 RFC 2187에서도 정보를 찾아볼 수 있음  
※ 미 국립 응용 네트워크 연구소(http://www.nlanr.net/Squid) 에서 ICP와 피어링에 대한 자료들을 열람할 수 있음

<br>

## 8. Cache Array Routing Protocol (CARP)

- 프록시 서버는 사용자의 요청을 가로채고 웹 객체의 캐시 사본을 제공함으로써 트래픽을 대폭 줄여줌
- 하지만 대량의 트래픽은 프록시 서버에게도 과도한 부하를 줄 수 있음
- 해결책 중 하나 → 프록시 서버를 여러 대로 늘리는 것
- CARP: 프록시 서버 배열이 클라이언트 시점에서는 하나의 논리적인 캐시로 보이게 관리해주는 MS와 넷스케이프 커뮤니케이션이 제안한 표준
- CARP는 ICP의 대안
  - 둘 다 관리자가 여러 프록시 서버를 사용해서 성능을 개선
- ICP는 "HIT"나 "MISS"에 따라 객체를 받아올 가장 적절한 위치를 선택
  - 비적중은 부모에게 상향 전파
  - 각 프록시 서버들은 웹 객체에 대한 중복된 엔트리를 허용하는 독립적 캐시
- 반면 CARP는 서버가 전체 캐시 문서의 일부만 갖고 있는 하나의 큰 서버처럼 동작
  - 웹 객체의 URL에 해시 함수를 적용해서 특정 프록시 서버에 매핑
  - 하나의 웹 객체는 하나의 프록시 서버에만 속함
  - 따라서 프록시 서버 각각을 폴링하지 않고 한 번의 검색으로 객체의 위치를 결정할 수 있음
- 캐싱 프록시가 중개자로서 트래픽을 분산할 수도 있지만, 크롬 등의 브라우저에서도 해시 함수를 계산하는 플러그인 설정 가능
- CARP에서 프록시 서버 분석은 _deterministic_
  - 질의를 모든 이웃에게 보낼 필요가 없다는 뜻
  - 캐시가 주고받아야 할 메시지가 더 적다는 뜻
- 그러나 프록시 서버 중 하나를 사용할 수 없게 되면, 해시 함수를 수정해야 하고, 프록시 서버들에게 퍼져 있는 컨텐츠들도 재배치해야 함
  - 프록시 서버 고장이 잦다면 수리 비용이 상당히 비쌀 수 있음
  - 이 문제는 ICP의 경우, 각 프록시 서버에 컨텐츠가 중복으로 존재하고 있었으므로 재배치가 필요 없음
- 또 하나 잠재적인 문제점: ICP 프로토콜만을 수행하는 기존의 프록시 서버는 CARP 무리에 쉽게 포함될 수 없음

**CARP 리다이렉션 방법**

- 참여하는 프록시 서버 테이블 유지
  - 각 프록시 서버들은 살아 있는지 확인하기 위해 주기적으로 폴링됨
- 각 참여 프록시 서버들에 대한 해시 함수 계산
  - 해시 함수 반환값: 이 프록시가 처리할 수 있는 부하량
- 요청된 웹 객체 URL에 근거한 숫자값을 반환하는 분리된 해시 함수 정의
- URL의 해시 함수와 프록시 서버의 해시 함수의 합계로 값의 배열을 얻음
  - 값들에 대한 최대값이 URL을 위해 사용할 프록시 서버 결정
  - 계산값은 결정적 → 동일 웹 객체에 대한 요청은 동일 프록시로 포워딩

<br>

- 4개의 리다이렉션 작업들은 플러그인을 통해 브라우저가 수행할 수 있고, 중간 서버가 계산할 수 있음
- 프록시 서버 테이블
  - 각 엔트리에 포함되는 전역 매개변수들: 부하 인자 정보, TTL 카운트다운 값, 폴링을 얼마나 자주 할 것인지
  - 부하 인자: 장비가 얼마나 큰 부하를 다룰 수 있는지 → CPU 속도와 HDD 용량에 의해 결정
  - 테이블은 RPC 인터페이스를 통해 원격으로 관리될 수 있음
  - 테이블의 필드들이 RPC에 의해 갱신되면, 해당 필드들은 바로 사용할 수 있게 되거나, 다운스트림 클라이언트들에게 배포됨
  - 이 배포는 HTTP에 의해 수행되므로 클라이언트나 프록시 서버는 다른 프록시 프로토콜 도입 없이 테이블 정보 사용 가능
  - 클라이언트와 프록시 서버는 테이블 조회를 위해 단순하게 잘 알려진 URL 사용
- 해시 함수
  - 웹 객체가 참여하는 프록시 서버들 전체에 걸쳐 정적으로 분산되었음을 반드시 보장해야 함
- 부하 인자
  - 프록시에게 할당된 웹 객체의 통계적 확률 결정을 위해 사용되어야 함
- Summary
  - 프록시 서버 그룹을 하나의 캐시 집단으로 보이게 함
  - 결정론적인 요청 분석 경로는 한 hop 안에 있는 특정 웹 객체의 거처를 찾아냄
    - 이는 ICP에서 발생하던 트래픽 부하를 줄여줌
  - 웹 캐시에 대한 중복된 사본을 만들지 않음
    - 캐시 시스템이 집합적으로 웹 객체를 더 많이 보관할 수 있음
  - 대신 프록시 하나가 고장나면 상당량의 캐시 컨텐츠를 재배치해야 함
