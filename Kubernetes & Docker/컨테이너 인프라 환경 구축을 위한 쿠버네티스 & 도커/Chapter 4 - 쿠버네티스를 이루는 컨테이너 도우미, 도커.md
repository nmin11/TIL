# 도커를 알아야 하는 이유

- 쿠버네티스를 말할 때 Docker를 자주 이야기하곤 함
- 쿠버네티스를 이루는 기본 오브젝트가 파드고, 파드는 컨테이너로 이루어져 있으며,<br>컨테이너를 만들고 관리하는 도구가 도커이기 때문
- 그래서 시중의 다른 책들과 같이 도커를 배우고 나서 쿠버네티스를 배우는 것이 흐름에 맞음
- 그러나 최근에는 도커를 몰라도 쿠버네티스를 사용하는 것이 가능해짐
  - 여러 공급사에서 만든 컨테이너 이미지로 쿠버네티스에 컨테이너 인프라 서비스를 만들 수 있다는 뜻
  - 컨테이너 관리 기술이 발전했고 여러 애플리케이션이 이미 도커 이미지로 배포되고 있어서<br>배포된 이미지를 사용하면 도커를 몰라도 쿠버네티스 환경을 만들고 사용할 수 있음
- 하지만 쿠버네티스를 이루고 있는 기술 자체는 컨테이너를 벗어날 수 없음
- 따라서 트러블슈팅을 제대로 하려면 컨테이너를 잘 알아야 함
- 그리고 상황에 따라 직접 만든 소스 코드를 빌드해 컨테이너로 만들고 이를 쿠버네티스에서 사용할 수도 있음
- 다음 장에서 배울 CI와 CD, 그리고 모니터링도 모두 컨테이너로 관리됨
- 따라서 컨테이너와 이를 다루는 도커를 자세히 알면 인프라 환경을 한층 더 깊게 이해할 수 있음

<br>
<br>

## 파드, 컨테이너, 도커, 쿠버네티스의 관계

- 현재 쿠버네티스 시스템
  - 파드들은 워커 노드라는 노드 단위로 관리하며, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됨
  - 파드는 1개 이상의 컨테이너로 이루어져 있음
- 파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공함<br>그리고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 함
  - 파드가 이러한 환경을 만들기 때문에 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 작동 가능
- 정리하면, 컨테이너를 돌보는 것이 파드고, 파드를 돌보는 것이 쿠버네티스 워커 노드이며,<br>워커 노드를 돌보는 것이 쿠버네티스 마스터
  - 그런데 쿠버네티스 마스터 역시 파드(컨테이너)로 이루어져 있음
- **컨테이너** : 이 구조를 이루는 가장 기본, 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간
- **개별적인 실행 환경** : CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경
  - 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리되어 관리됨
  - 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있음
- 각 컨테이너가 독립적으로 작동하기 때문에 여러 컨테이너를 효과적으로 다룰 방법이 필요해졌는데,<br>이런 과정을 쉽게 만들어 주는 도구로 등장한 것이 도커
  - 도커는 컨테이너를 사용하는 방법을 명령어로 정리한 것으로 보면 됨
  - 도커를 사용하면 사용자가 따로 신경쓰지 않아도 컨테이너를 생성할 때 개별적인 실행 환경을 분리하고 자원을 할당함

<br>
<br>

## 다양한 컨테이너 관리 도구

- Containerd
  - Docker사에서 컨테이너 런타임 부분을 분리하여 만든 오픈 소스 컨테이너 관리 도구
  - 쿠버네티스와의 통신에 필요한 CRI 규격에 맞춰 구현한 플러그인을 사용해 쿠버네티스와 통합 가능
  - 다른 시스템을 통합해 컨테이너를 관리하는 기능을 제공하므로 컨테이너 관리 도구를 직접 개발하려는 개발자에게 적합
- CRI-O
  - 레드햇에서 개발해 클라우드 2019년 네이티브 컴퓨팅 재단에 기부한 오픈 소스 프로젝트로, 현재 Incubating 단계에 있음
  - 범용적인 컨테이너 관리 도구들과 달리 쿠버네티스와 통합하는 것을 주목적으로 함
  - 다른 도구보다 가볍고 단순하며, CRI 규격을 자체적으로 구현하고 있어서<br>별도의 구성 요소나 플러그인 없이 쿠버네티스와 통합 가능
  - 역사가 짧고 많이 사용되지도 않아서 관리와 구성에 관한 자료가 부족함
- Kata Containers
  - Openstack foundation에서 후원하는 오픈 소스 컨테이너 관리 도구
  - 컨테이너마다 독립적인 커널 제공
    - 개별 컨테이너를 위한 가벼운 가상 머신을 생성하고 그 위에서 컨테이너가 작동
    - 기술적으로 보면 기존 컨테이너 방식과 가상화 방식의 중간 영역에 있음
  - 보안이 강하지만 CPU 및 메모리 크기가 기존 방식보다 크게 소요됨
  - 사용자 층이 넓지 않아 자료가 부족함
- Docker
  - Docker사에서 2013년에 만든 컨테이너 관리 도구
  - 컨테이너 관리 기능 외에도 컨테이너를 실행하는 데 필요한 이미지 생성 및 공유 등 다양한 기능 제공
  - 명령어 도구 CLI와 명령을 받아들이는 도커 데몬으로 구성되어 있음
  - 1.11 버전 이후로 별도의 컨테이너디를 포함하고 있음
  - 네트워크를 통한 호출로 작동하므로 구조적으로는 다소 복잡하지만 이를 모두 도커에서 관리함

|     구분      | Containerd |    CRI-O     | Kata Containers |  Docker   |
| :-----------: | :--------: | :----------: | :-------------: | :-------: |
|  명령어 도구  | 별도 지원  | 타 도구 사용 |    자체 지원    | 자체 지원 |
|   내부 구조   |    단순    |  매우 단순   |      복잡       |   복잡    |
|    확장성     |    좋음    |  좋지 못함   |    좋지 못함    | 매우 좋음 |
| 컨테이너 관리 |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|  이미지 관리  |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|    보안성     |    좋음    |     좋음     |    매우 좋음    |   좋음    |
|  자원 사용량  | 매우 좋음  |  매우 좋음   |    좋지 못함    |   좋음    |
|    정보량     |    적음    |  거의 없음   |    거의 없음    | 매우 많음 |

<br>
<br>

# 도커로 컨테이너 다루기

**컨테이너 이미지와 컨테이너의 관계**

- 컨테이너 이미지는 베이그런트 이미지와 유사
- 베이그런트 이미지가 베이그런트 없이 사용할 수 없듯, 컨테이너 이미지도 도커와 같은 CRI로 불러와야만 실행 가능
- 따라서 컨테이너를 삭제할 때는 이미지와 이미 실행된 컨테이너를 모두 삭제해야 디스크 용량 확보 가능

<br>
<br>

## 컨테이너 이미지 알아보기

### 이미지 검색하고 내려받기

- 이미지는 registry라고 하는 저장소에 모여 있음
- registry는 도커 허브처럼 공개된 유명 registry일 수도 있고, 내부에 구축한 registry일 수도 있음
- 이미지는 레지스트리 웹 사이트에서 직접 검색해도 되고,<br>슈퍼푸티 명령 창에서 쿠버네티스 마스터 노드에 접속해서 검색할 수도 있음
- 슈퍼푸티에서의 검색 명령어 : `docker search <검색어>`
  - 검색어를 포함하는 이미지가 있는지 찾아냄
  - INDEX : 이미지가 저장된 레지스트리의 이름
  - NAME : 검색된 이미지 이름, 공식 이미지가 아니라면 `레지스트리 주소/저장소 소유자/이미지 이름`의 형태
  - DESCRIPTION : 이미지에 대한 설명
  - STARS : 해당 이미지를 내려받은 사용자에게 받은 평가 횟수
  - OFFICIAL : `[OK]`가 있으면 해당 이미지에 포함된 애플리케이션, 미들웨어 등을<br>개발한 업체에서 공식적으로 제공한 이미지라는 의미
  - AUTOMATED : `[OK]`가 있으면 도커 허브에서 자체적으로 제공하는<br>이미지 빌드 자동화 기능을 활용해서 생성한 이미지라는 의미
- 이미지 내려받기 명령어 : `docker pull <이름>`
  - Tag : 이미지를 내려받을 때 사용한 태그를 알려줌<br>조건을 주지 않고 pull하면 기본으로 latest 태그 적용
  - Layer : pull을 수행해서 내려받은 레이어들 표시<br>하나의 이미지는 여러 개의 레이어로 이루어져 있어서 각 레이어마다 Pull complete 메시지가 발생함
  - Digest : 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경 식별할 수 있게 함<br>식별자는 hash 함수로 생성되며 이미지가 동일한지 검증하는 데 사용됨
  - Status : `레지스트리 이름/이미지 이름:태그`

<br>

### 이미지 태그

- 태그 : 이름이 동일한 이미지에 추가하는 식별자
- 이름이 동일해도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하는 데에 사용됨
- 관련 정보는 도커 허브(https://hub.docker.com/)에서 해당 이미지를 검색하고 Tags 탭에 가면 확인 가능
- 태그 적용 예시 : `docker pull nginx:stable`

<br>

### 이미지의 레이어 구조

- 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP 같은 압축 파일에 더 가까움
  - 압축 파일은 파일 개수에 따라 용량이 증가하지만<br>이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유하므로 전체 용량이 감소함
- 이미지 조회 명령어 : `docker images <이미지 이름>`
- 이미지의 생성 과정 조회 명령어 : `docker history <이미지 이름>`
  - `docker history`는 도커 컨테이너 이미지 자체를 만드는 명령어를 보여줌

<br>
<br>

## 컨테이너 실행하기

- 컨테이너 실행 명령어 : `docker run [옵션] <이미지 이름>[:태그 | @다이제스트]`
- 실행 예시 : `docker run -d --restart always nginx`
  - 실행 시 결과값으로 16진수 문자열이 나오는데 이는 컨테이너를 식별할 고유 ID이므로 따로 기억해둘 것
  - -d(--detach) : 컨테이너를 백그라운드에서 구동한다는 의미<br>이 옵션을 생략할 경우 컨테이너 내부에서 실행되는 애플리케이션 상태가 화면에 계속 표시됨
  - --restart always : 컨테이너 재시작과 관련된 정책을 의미하는 옵션<br>오류가 발생하거나 중지되었을 때 컨테이너도 작동이 중지되는데, 이런 때에 어떻게 할지 설정하는 옵션<br>always 옵션은 가상 머신을 중지한 후 다시 실행해도 자동으로 컨테이너가 기존 상태를 이어 갈 수 있게 함

※ --restart 옵션 값에 따른 컨테이너 시작 방법

|       값       | 컨테이너 비정상 종료 시  |             도커 서비스 시작 시             |
| :------------: | :----------------------: | :-----------------------------------------: |
|  no (기본값)   | 컨테이너 재시작하지 않음 |           컨테이너 시작하지 않음            |
|   on-failure   |     컨테이너 재시작      |                컨테이너 시작                |
|     always     |     컨테이너 재시작      |                컨테이너 시작                |
| unless-stopped |     컨테이너 재시작      | 사용자가 직접 정지하지 않은 컨테이너만 시작 |

- 컨테이너 상태 확인 명령어 : `docker ps`
  - ps는 process status를 의미함
  - CONTAINER ID : 컨테이너 식별을 위한 고유 ID
  - IMAGE : 컨테이너를 만드는 데 사용한 이미지
  - COMMAND : 컨테이너 생성 시 내부에서 작동할 실행 명령어
  - CREATED : 컨테이너 생성 시각
  - STATUS : 컨테이너 작동 시작 시각, 컨테이너 재시작 시 초기화됨
  - PORTS : 컨테이너가 사용하는 포트와 프로토콜
  - NAMES : 컨테이너 이름, 컨테이너 생성 시 `docker run --name <이름>` 옵션으로 직접 지정 가능
- 컨테이너 지정 검색 : `docker ps -f id=<컨테이너 고유 ID>`
  - -f(--filter) \<필터링 대상> : 검색 결과 필터링, 필터링 대상은 key=value 형식으로 입력<br>value와 정확하게 일치하지 않더라도 value에 해당하는 문자열을 포함하는 경우를 필터링함

※ 자주 사용하는 필터링 키

- id : 컨테이너 아이디
- name : 컨테이너 이름
- label : 컨테이너 레이블
- exited : 컨테이너 종료 시 반환하는 숫자 코드
- status : 컨테이너 작동 상태
- ancestor : 컨테이너가 사용하는 이미지

=> 이외에도 도커 공식 문서(https://docs.docker.com/engine/reference/commandline/ps/#filtering) 에서 더 많은 키 확인 가능

<br>

⭐ 컨테이너의 PORTS에 표시되는 80/tcp와 같은 부분은 컨테이너 내부에서 해당 포트를 사용하는 것이지,<br>로컬호스트의 포트를 사용하는 것이 아님!

⭐ 컨테이너는 **immutable infrastructure**를 지향하기 때문에 변경이 불가능<br>설정 변경이 필요할 경우 새로운 컨테이너를 생성해야 함<br>이러한 특성 덕분에 컨테이너로 배포된 인프라는 배포된 상태를 유지한다는 장점이 있음

- 컨테이너 외부에서도 컨테이너 내부에서 접속할 수 있게 실행하기
  - 명령어 : `docker run -d -p 8080:80 --name nginx-exposed --restart always nginx`
    - -p(--publish) \<요청 받을 호스트 포트>:<연결할 컨테이너 포트><br>외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션

<br>
<br>

## 컨테이너 내부 파일 변경하기

도커는 컨테이너 내부에서 외부의 파일을 사용할 수 있는 방법으로 크게 4가지를 제공함

- docker cp \<호스트 경로> \<컨테이너 이름>:<컨테이너 내부 경로> <br>호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사<br>컨테이너에 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해서 사용<br>또는 컨테이너에 저장되어 있는 설정 및 로그를 추출해서 확인하는 목적으로도 사용
- Dockerfile ADD : 이미지는 Dockerfile을 기반으로 만들어짐<br>Dockerfile ADD로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사됨<br>이후 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있음<br>하지만 사용자가 원하는 파일을 선택해서 사용할 수 없다는 약점이 존재함
- 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽의 작업이 양쪽에 적용되도록 하는 방법<br>새로운 컨테이너를 구동할 때도 호스트와 연결할 경로만 지정하면 서로 연동할 수 있음<br>DB 데이터 디렉토리나 서버 첨부 파일 디렉토리처럼 컨테이너가 바뀌어도 없어지면 안 되는 자료들 보존 가능
- 볼륨 : 도커가 관리하는 볼륨을 컨테이너와 연결<br>호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일<br>도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉토리에 생성하면<br>다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용 가능

|      구분      |   docker cp   |        Dockerfile ADD        |     바인드 마운트     |          볼륨          |
| :------------: | :-----------: | :--------------------------: | :-------------------: | :--------------------: |
| 컨테이너 적용  | 구동 중 복사  |     이미지 생성 시 복사      | 구동 시 디렉토리 연결 | 구동 시 도커 볼륨 연결 |
| 파일 보관 위치 | 컨테이너 내부 |        컨테이너 내부         |   호스트(디렉토리)    |   호스트(도커 볼륨)    |
|  주 활용 용도  |   임시 파일   | 컨테이너 생성 시 필요한 파일 |  보존이 필요한 파일   |   보존이 필요한 파일   |
|  관리 편의성   |   좋지 못함   |             좋음             |         좋음          |       매우 좋음        |
|  파일 보존성   |   좋지 못함   |             좋음             |       매우 좋음       |       매우 좋음        |

- 바인드 마운트 실행 코드 예시 :<br>`docker run -d -p 8081:80 \-v /root/html:/usr/share/nginx --restart always --name nginx-bind-mounts nginx`
  - nginx-bind-mounts라는 이름의 컨테이너 구동
  - 컨테이너의 /usr/share/nginx/html/ 디렉토리와 호스트의 /root/html 디렉토리 연결
  - -v(--volume) \<호스트 디렉토리 경로>:[컨테이너 디렉토리 경로]<br>호스트 디렉토리와 컨테이너 디렉토리 연결
  - 유의점 : 바인드 마운트는 호스트 디렉토리의 내용을 그대로 컨테이너 디렉토리에 덮어쓰므로<br>컨테이너 디렉토리에 어떠한 내용이 있더라고 해당 내용은 삭제됨
- docker 컨테이너 조회 명령어 예시 : `docker ps -f name=nginx-bind-mounts`
- docker의 많은 기능과 명령이 kubectl과 동일하거나 비슷함

<br>

- volume : 도커가 직접 관리하며 컨테이너에 제공하는 호스트의 공간
- 생성 명령어 예시 : `docker volume create nginx-volume`
- 조회 명령어 예시 : `docker volume inspect nginx-volume`
  - 볼륨에 적용된 드라이버 종류와 실제 호스트에 연결된 디렉토리, 볼륨 이름 등을 조회할 수 있음
- 볼륨 실행 예시 :<br>`docker run -d -v nginx-volume:/usr/share/nginx/html \-p 8082:80 --restart always --name nginx-volume nginx`
- 볼륨은 바인드 마운트와 다르게 덮어쓰지 않고 서로 동기화하기 때문에 컨테이너 디렉토리의 파일이 보존됨<br>하지만 볼륨 컨테이너 디렉토리와 동일한 파일이 존재한 상태로 연결하면 덮어쓰게 됨
- 볼륨을 사용하면 `docker volume ls`로 조회하거나 `docker volume rm`으로 삭제할 수 있어서 바인드 마운트보다 간편함
- 실습에서 볼륨 경로는 /var/lib/docker/volumes/ 디렉토리 안에 생성되었는데,<br>var 디렉토리는 로그, 캐시, 상태 정보 등을 저장함<br>이 기본 디렉토리를 그대로 사용하면 다른 기능이 사용하는 용량까지 차지하는 문제가 발생할 수 있음<br>따라서 충분한 용량이 확보된 디렉토리로 설정할 필요가 있으며,<br>이 때 --data-root 옵션이나 --mount 옵션을 활용할 수 있음

<br>
<br>

## 사용하지 않는 컨테이너 정리하기

- 컨테이너나 이미지를 삭제하기 전에 먼저 컨테이너를 정지해야 함
- 컨테이너 정지 명령어 : `docker stop <컨테이너 이름 | ID>`
  - 이름으로 정지할 수도 있고, ID 중 앞 글자 일부를 적어서 정지할 수도 있음
- 조회 명령어에 옵션을 넣어서 조회된 컨테이너들을 정지할 수도 있음
  - 조회 명령어 예시 : `docker ps -q -f ancestor=nginx`
    - -q(--quite) 옵션은 ID만 출력하는 옵션
  - 조회된 것들을 정지하는 명령어 예시 : `docker stop $(docker ps -q -f ancestor=nginx)`

⭐ 정지된 컨테이너는 삭제된 것이 아님

- `docker ps -a` 옵션을 통해 정지된 컨테이너까지 모두 조회 가능
- 정지된 컨테이너 시작 명령어 : `docker start <컨테이너 이름 | ID>`
- 컨테이너 삭제 명령어 : `docker rm <컨테이너 이름 | ID>`
  - 실습에서 사용한 일괄 삭제 예시 : `docker rm $(docker ps -aq -f ancestor=nginx)`
- 컨테이너를 삭제해도 내려받은 이미지는 아직도 남아 있음
  - 실습에서 사용한 이미지 일괄 삭제 예시 : `docker rmi $(docker images -q nginx)`
  - rmi : remove image
  - 이미지는 컨테이너가 정지 상태가 아닌 삭제 상태일 때 삭제 가능
