# 도커를 알아야 하는 이유

- 쿠버네티스를 말할 때 Docker를 자주 이야기하곤 함
- 쿠버네티스를 이루는 기본 오브젝트가 파드고, 파드는 컨테이너로 이루어져 있으며,<br>컨테이너를 만들고 관리하는 도구가 도커이기 때문
- 그래서 시중의 다른 책들과 같이 도커를 배우고 나서 쿠버네티스를 배우는 것이 흐름에 맞음
- 그러나 최근에는 도커를 몰라도 쿠버네티스를 사용하는 것이 가능해짐
  - 여러 공급사에서 만든 컨테이너 이미지로 쿠버네티스에 컨테이너 인프라 서비스를 만들 수 있다는 뜻
  - 컨테이너 관리 기술이 발전했고 여러 애플리케이션이 이미 도커 이미지로 배포되고 있어서<br>배포된 이미지를 사용하면 도커를 몰라도 쿠버네티스 환경을 만들고 사용할 수 있음
- 하지만 쿠버네티스를 이루고 있는 기술 자체는 컨테이너를 벗어날 수 없음
- 따라서 트러블슈팅을 제대로 하려면 컨테이너를 잘 알아야 함
- 그리고 상황에 따라 직접 만든 소스 코드를 빌드해 컨테이너로 만들고 이를 쿠버네티스에서 사용할 수도 있음
- 다음 장에서 배울 CI와 CD, 그리고 모니터링도 모두 컨테이너로 관리됨
- 따라서 컨테이너와 이를 다루는 도커를 자세히 알면 인프라 환경을 한층 더 깊게 이해할 수 있음

<br>
<br>

## 파드, 컨테이너, 도커, 쿠버네티스의 관계

- 현재 쿠버네티스 시스템
  - 파드들은 워커 노드라는 노드 단위로 관리하며, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됨
  - 파드는 1개 이상의 컨테이너로 이루어져 있음
- 파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공함<br>그리고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 함
  - 파드가 이러한 환경을 만들기 때문에 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 작동 가능
- 정리하면, 컨테이너를 돌보는 것이 파드고, 파드를 돌보는 것이 쿠버네티스 워커 노드이며,<br>워커 노드를 돌보는 것이 쿠버네티스 마스터
  - 그런데 쿠버네티스 마스터 역시 파드(컨테이너)로 이루어져 있음
- **컨테이너** : 이 구조를 이루는 가장 기본, 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간
- **개별적인 실행 환경** : CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경
  - 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리되어 관리됨
  - 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있음
- 각 컨테이너가 독립적으로 작동하기 때문에 여러 컨테이너를 효과적으로 다룰 방법이 필요해졌는데,<br>이런 과정을 쉽게 만들어 주는 도구로 등장한 것이 도커
  - 도커는 컨테이너를 사용하는 방법을 명령어로 정리한 것으로 보면 됨
  - 도커를 사용하면 사용자가 따로 신경쓰지 않아도 컨테이너를 생성할 때 개별적인 실행 환경을 분리하고 자원을 할당함

<br>
<br>

## 다양한 컨테이너 관리 도구

- Containerd
  - Docker사에서 컨테이너 런타임 부분을 분리하여 만든 오픈 소스 컨테이너 관리 도구
  - 쿠버네티스와의 통신에 필요한 CRI 규격에 맞춰 구현한 플러그인을 사용해 쿠버네티스와 통합 가능
  - 다른 시스템을 통합해 컨테이너를 관리하는 기능을 제공하므로 컨테이너 관리 도구를 직접 개발하려는 개발자에게 적합
- CRI-O
  - 레드햇에서 개발해 클라우드 2019년 네이티브 컴퓨팅 재단에 기부한 오픈 소스 프로젝트로, 현재 Incubating 단계에 있음
  - 범용적인 컨테이너 관리 도구들과 달리 쿠버네티스와 통합하는 것을 주목적으로 함
  - 다른 도구보다 가볍고 단순하며, CRI 규격을 자체적으로 구현하고 있어서<br>별도의 구성 요소나 플러그인 없이 쿠버네티스와 통합 가능
  - 역사가 짧고 많이 사용되지도 않아서 관리와 구성에 관한 자료가 부족함
- Kata Containers
  - Openstack foundation에서 후원하는 오픈 소스 컨테이너 관리 도구
  - 컨테이너마다 독립적인 커널 제공
    - 개별 컨테이너를 위한 가벼운 가상 머신을 생성하고 그 위에서 컨테이너가 작동
    - 기술적으로 보면 기존 컨테이너 방식과 가상화 방식의 중간 영역에 있음
  - 보안이 강하지만 CPU 및 메모리 크기가 기존 방식보다 크게 소요됨
  - 사용자 층이 넓지 않아 자료가 부족함
- Docker
  - Docker사에서 2013년에 만든 컨테이너 관리 도구
  - 컨테이너 관리 기능 외에도 컨테이너를 실행하는 데 필요한 이미지 생성 및 공유 등 다양한 기능 제공
  - 명령어 도구 CLI와 명령을 받아들이는 도커 데몬으로 구성되어 있음
  - 1.11 버전 이후로 별도의 컨테이너디를 포함하고 있음
  - 네트워크를 통한 호출로 작동하므로 구조적으로는 다소 복잡하지만 이를 모두 도커에서 관리함

|     구분      | Containerd |    CRI-O     | Kata Containers |  Docker   |
| :-----------: | :--------: | :----------: | :-------------: | :-------: |
|  명령어 도구  | 별도 지원  | 타 도구 사용 |    자체 지원    | 자체 지원 |
|   내부 구조   |    단순    |  매우 단순   |      복잡       |   복잡    |
|    확장성     |    좋음    |  좋지 못함   |    좋지 못함    | 매우 좋음 |
| 컨테이너 관리 |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|  이미지 관리  |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|    보안성     |    좋음    |     좋음     |    매우 좋음    |   좋음    |
|  자원 사용량  | 매우 좋음  |  매우 좋음   |    좋지 못함    |   좋음    |
|    정보량     |    적음    |  거의 없음   |    거의 없음    | 매우 많음 |

<br>
<br>

# 도커로 컨테이너 다루기

**컨테이너 이미지와 컨테이너의 관계**

- 컨테이너 이미지는 베이그런트 이미지와 유사
- 베이그런트 이미지가 베이그런트 없이 사용할 수 없듯, 컨테이너 이미지도 도커와 같은 CRI로 불러와야만 실행 가능
- 따라서 컨테이너를 삭제할 때는 이미지와 이미 실행된 컨테이너를 모두 삭제해야 디스크 용량 확보 가능

<br>
<br>

## 컨테이너 이미지 알아보기

### 이미지 검색하고 내려받기

- 이미지는 registry라고 하는 저장소에 모여 있음
- registry는 도커 허브처럼 공개된 유명 registry일 수도 있고, 내부에 구축한 registry일 수도 있음
- 이미지는 레지스트리 웹 사이트에서 직접 검색해도 되고,<br>슈퍼푸티 명령 창에서 쿠버네티스 마스터 노드에 접속해서 검색할 수도 있음
- 슈퍼푸티에서의 검색 명령어 : `docker search <검색어>`
  - 검색어를 포함하는 이미지가 있는지 찾아냄
  - INDEX : 이미지가 저장된 레지스트리의 이름
  - NAME : 검색된 이미지 이름, 공식 이미지가 아니라면 `레지스트리 주소/저장소 소유자/이미지 이름`의 형태
  - DESCRIPTION : 이미지에 대한 설명
  - STARS : 해당 이미지를 내려받은 사용자에게 받은 평가 횟수
  - OFFICIAL : `[OK]`가 있으면 해당 이미지에 포함된 애플리케이션, 미들웨어 등을<br>개발한 업체에서 공식적으로 제공한 이미지라는 의미
  - AUTOMATED : `[OK]`가 있으면 도커 허브에서 자체적으로 제공하는<br>이미지 빌드 자동화 기능을 활용해서 생성한 이미지라는 의미
- 이미지 내려받기 명령어 : `docker pull <이름>`
  - Tag : 이미지를 내려받을 때 사용한 태그를 알려줌<br>조건을 주지 않고 pull하면 기본으로 latest 태그 적용
  - Layer : pull을 수행해서 내려받은 레이어들 표시<br>하나의 이미지는 여러 개의 레이어로 이루어져 있어서 각 레이어마다 Pull complete 메시지가 발생함
  - Digest : 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경 식별할 수 있게 함<br>식별자는 hash 함수로 생성되며 이미지가 동일한지 검증하는 데 사용됨
  - Status : `레지스트리 이름/이미지 이름:태그`

<br>

### 이미지 태그

- 태그 : 이름이 동일한 이미지에 추가하는 식별자
- 이름이 동일해도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하는 데에 사용됨
- 관련 정보는 도커 허브(https://hub.docker.com/)에서 해당 이미지를 검색하고 Tags 탭에 가면 확인 가능
- 태그 적용 예시 : `docker pull nginx:stable`

<br>

### 이미지의 레이어 구조

- 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP 같은 압축 파일에 더 가까움
  - 압축 파일은 파일 개수에 따라 용량이 증가하지만<br>이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유하므로 전체 용량이 감소함
- 이미지 조회 명령어 : `docker images <이미지 이름>`
- 이미지의 생성 과정 조회 명령어 : `docker history <이미지 이름>`
  - `docker history`는 도커 컨테이너 이미지 자체를 만드는 명령어를 보여줌

<br>
<br>

## 컨테이너 실행하기

- 컨테이너 실행 명령어 : `docker run [옵션] <이미지 이름>[:태그 | @다이제스트]`
- 실행 예시 : `docker run -d --restart always nginx`
  - 실행 시 결과값으로 16진수 문자열이 나오는데 이는 컨테이너를 식별할 고유 ID이므로 따로 기억해둘 것
  - -d(--detach) : 컨테이너를 백그라운드에서 구동한다는 의미<br>이 옵션을 생략할 경우 컨테이너 내부에서 실행되는 애플리케이션 상태가 화면에 계속 표시됨
  - --restart always : 컨테이너 재시작과 관련된 정책을 의미하는 옵션<br>오류가 발생하거나 중지되었을 때 컨테이너도 작동이 중지되는데, 이런 때에 어떻게 할지 설정하는 옵션<br>always 옵션은 가상 머신을 중지한 후 다시 실행해도 자동으로 컨테이너가 기존 상태를 이어 갈 수 있게 함

※ --restart 옵션 값에 따른 컨테이너 시작 방법

|       값       | 컨테이너 비정상 종료 시  |             도커 서비스 시작 시             |
| :------------: | :----------------------: | :-----------------------------------------: |
|  no (기본값)   | 컨테이너 재시작하지 않음 |           컨테이너 시작하지 않음            |
|   on-failure   |     컨테이너 재시작      |                컨테이너 시작                |
|     always     |     컨테이너 재시작      |                컨테이너 시작                |
| unless-stopped |     컨테이너 재시작      | 사용자가 직접 정지하지 않은 컨테이너만 시작 |

- 컨테이너 상태 확인 명령어 : `docker ps`
  - ps는 process status를 의미함
  - CONTAINER ID : 컨테이너 식별을 위한 고유 ID
  - IMAGE : 컨테이너를 만드는 데 사용한 이미지
  - COMMAND : 컨테이너 생성 시 내부에서 작동할 실행 명령어
  - CREATED : 컨테이너 생성 시각
  - STATUS : 컨테이너 작동 시작 시각, 컨테이너 재시작 시 초기화됨
  - PORTS : 컨테이너가 사용하는 포트와 프로토콜
  - NAMES : 컨테이너 이름, 컨테이너 생성 시 `docker run --name <이름>` 옵션으로 직접 지정 가능
- 컨테이너 지정 검색 : `docker ps -f id=<컨테이너 고유 ID>`
  - -f(--filter) \<필터링 대상> : 검색 결과 필터링, 필터링 대상은 key=value 형식으로 입력<br>value와 정확하게 일치하지 않더라도 value에 해당하는 문자열을 포함하는 경우를 필터링함

※ 자주 사용하는 필터링 키

- id : 컨테이너 아이디
- name : 컨테이너 이름
- label : 컨테이너 레이블
- exited : 컨테이너 종료 시 반환하는 숫자 코드
- status : 컨테이너 작동 상태
- ancestor : 컨테이너가 사용하는 이미지

=> 이외에도 도커 공식 문서(https://docs.docker.com/engine/reference/commandline/ps/#filtering) 에서 더 많은 키 확인 가능

<br>

⭐ 컨테이너의 PORTS에 표시되는 80/tcp와 같은 부분은 컨테이너 내부에서 해당 포트를 사용하는 것이지,<br>로컬호스트의 포트를 사용하는 것이 아님!

⭐ 컨테이너는 **immutable infrastructure**를 지향하기 때문에 변경이 불가능<br>설정 변경이 필요할 경우 새로운 컨테이너를 생성해야 함<br>이러한 특성 덕분에 컨테이너로 배포된 인프라는 배포된 상태를 유지한다는 장점이 있음

- 컨테이너 외부에서도 컨테이너 내부에서 접속할 수 있게 실행하기
  - 명령어 : `docker run -d -p 8080:80 --name nginx-exposed --restart always nginx`
    - -p(--publish) \<요청 받을 호스트 포트>:<연결할 컨테이너 포트><br>외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션

<br>
<br>

## 컨테이너 내부 파일 변경하기

도커는 컨테이너 내부에서 외부의 파일을 사용할 수 있는 방법으로 크게 4가지를 제공함

- docker cp \<호스트 경로> \<컨테이너 이름>:<컨테이너 내부 경로> <br>호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사<br>컨테이너에 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해서 사용<br>또는 컨테이너에 저장되어 있는 설정 및 로그를 추출해서 확인하는 목적으로도 사용
- Dockerfile ADD : 이미지는 Dockerfile을 기반으로 만들어짐<br>Dockerfile ADD로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사됨<br>이후 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있음<br>하지만 사용자가 원하는 파일을 선택해서 사용할 수 없다는 약점이 존재함
- 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽의 작업이 양쪽에 적용되도록 하는 방법<br>새로운 컨테이너를 구동할 때도 호스트와 연결할 경로만 지정하면 서로 연동할 수 있음<br>DB 데이터 디렉토리나 서버 첨부 파일 디렉토리처럼 컨테이너가 바뀌어도 없어지면 안 되는 자료들 보존 가능
- 볼륨 : 도커가 관리하는 볼륨을 컨테이너와 연결<br>호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일<br>도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉토리에 생성하면<br>다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용 가능

|      구분      |   docker cp   |        Dockerfile ADD        |     바인드 마운트     |          볼륨          |
| :------------: | :-----------: | :--------------------------: | :-------------------: | :--------------------: |
| 컨테이너 적용  | 구동 중 복사  |     이미지 생성 시 복사      | 구동 시 디렉토리 연결 | 구동 시 도커 볼륨 연결 |
| 파일 보관 위치 | 컨테이너 내부 |        컨테이너 내부         |   호스트(디렉토리)    |   호스트(도커 볼륨)    |
|  주 활용 용도  |   임시 파일   | 컨테이너 생성 시 필요한 파일 |  보존이 필요한 파일   |   보존이 필요한 파일   |
|  관리 편의성   |   좋지 못함   |             좋음             |         좋음          |       매우 좋음        |
|  파일 보존성   |   좋지 못함   |             좋음             |       매우 좋음       |       매우 좋음        |

- 바인드 마운트 실행 코드 예시 :<br>`docker run -d -p 8081:80 \-v /root/html:/usr/share/nginx --restart always --name nginx-bind-mounts nginx`
  - nginx-bind-mounts라는 이름의 컨테이너 구동
  - 컨테이너의 /usr/share/nginx/html/ 디렉토리와 호스트의 /root/html 디렉토리 연결
  - -v(--volume) \<호스트 디렉토리 경로>:[컨테이너 디렉토리 경로]<br>호스트 디렉토리와 컨테이너 디렉토리 연결
  - 유의점 : 바인드 마운트는 호스트 디렉토리의 내용을 그대로 컨테이너 디렉토리에 덮어쓰므로<br>컨테이너 디렉토리에 어떠한 내용이 있더라고 해당 내용은 삭제됨
- docker 컨테이너 조회 명령어 예시 : `docker ps -f name=nginx-bind-mounts`
- docker의 많은 기능과 명령이 kubectl과 동일하거나 비슷함

<br>

- volume : 도커가 직접 관리하며 컨테이너에 제공하는 호스트의 공간
- 생성 명령어 예시 : `docker volume create nginx-volume`
- 조회 명령어 예시 : `docker volume inspect nginx-volume`
  - 볼륨에 적용된 드라이버 종류와 실제 호스트에 연결된 디렉토리, 볼륨 이름 등을 조회할 수 있음
- 볼륨 실행 예시 :<br>`docker run -d -v nginx-volume:/usr/share/nginx/html \-p 8082:80 --restart always --name nginx-volume nginx`
- 볼륨은 바인드 마운트와 다르게 덮어쓰지 않고 서로 동기화하기 때문에 컨테이너 디렉토리의 파일이 보존됨<br>하지만 볼륨 컨테이너 디렉토리와 동일한 파일이 존재한 상태로 연결하면 덮어쓰게 됨
- 볼륨을 사용하면 `docker volume ls`로 조회하거나 `docker volume rm`으로 삭제할 수 있어서 바인드 마운트보다 간편함
- 실습에서 볼륨 경로는 /var/lib/docker/volumes/ 디렉토리 안에 생성되었는데,<br>var 디렉토리는 로그, 캐시, 상태 정보 등을 저장함<br>이 기본 디렉토리를 그대로 사용하면 다른 기능이 사용하는 용량까지 차지하는 문제가 발생할 수 있음<br>따라서 충분한 용량이 확보된 디렉토리로 설정할 필요가 있으며,<br>이 때 --data-root 옵션이나 --mount 옵션을 활용할 수 있음

<br>
<br>

## 사용하지 않는 컨테이너 정리하기

- 컨테이너나 이미지를 삭제하기 전에 먼저 컨테이너를 정지해야 함
- 컨테이너 정지 명령어 : `docker stop <컨테이너 이름 | ID>`
  - 이름으로 정지할 수도 있고, ID 중 앞 글자 일부를 적어서 정지할 수도 있음
- 조회 명령어에 옵션을 넣어서 조회된 컨테이너들을 정지할 수도 있음
  - 조회 명령어 예시 : `docker ps -q -f ancestor=nginx`
    - -q(--quite) 옵션은 ID만 출력하는 옵션
  - 조회된 것들을 정지하는 명령어 예시 : `docker stop $(docker ps -q -f ancestor=nginx)`

⭐ 정지된 컨테이너는 삭제된 것이 아님

- `docker ps -a` 옵션을 통해 정지된 컨테이너까지 모두 조회 가능
- 정지된 컨테이너 시작 명령어 : `docker start <컨테이너 이름 | ID>`
- 컨테이너 삭제 명령어 : `docker rm <컨테이너 이름 | ID>`
  - 실습에서 사용한 일괄 삭제 예시 : `docker rm $(docker ps -aq -f ancestor=nginx)`
- 컨테이너를 삭제해도 내려받은 이미지는 아직도 남아 있음
  - 실습에서 사용한 이미지 일괄 삭제 예시 : `docker rmi $(docker images -q nginx)`
  - rmi : remove image
  - 이미지는 컨테이너가 정지 상태가 아닌 삭제 상태일 때 삭제 가능

<br>
<br>

# 4가지 방법으로 컨테이너 이미지 만들기

- 컨테이너 인프라 환경을 구성할 때 이미 제공된 이미지를 사용하는 경우도 있지만<br>직접 만든 애플리케이션으로 컨테이너를 만들 수도 있음
- 여기서는 저자가 제공하는 소스 코드로 Java 실행 파일을 빌드하고 이를 다시 도커 빌드를 사용해 컨테이너 이미지로 만들 것임

<br>
<br>

## 기본 방법으로 빌드하기

- Java 소스 빌드 → Dockerfile 작성 → Dockerfile 빌드 → 빌드 완료
- OpenJDK 1.8 설치 및 `mvnw clean package` 명령을 통한 JAR 생성
- `docker build -t basic-img .` 명령어로 컨테이너 이미지 빌드
  - `-t(tag)`는 만들어질 이미지, `.`은 작업 공간을 현재 디렉토리로 지정
- 위 빌드 과정을 이해하기 위해 Dockerfile을 살펴봐야 함

```bash
FROM openjdk:8
LABEL description="Echo IP Java Application"
EXPOSE 60431
COPY ./target/app-in-host.jar /opt/app-in-image.jar
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

- Dockerfile은 빌드용 DSL(Domain-Specific Languages)로 작성된 파일
- 좀 더 이해하기 쉽도록 bash 명령어로 유사 해석하면 다음과 같음

| Dockerfile                                          | bash 유사 명령어                                                 |
| :-------------------------------------------------- | :--------------------------------------------------------------- |
| FROM openjdk:8                                      | import openjdk:8 image                                           |
| LABEL description="Echo IP Java Application"        | Label_desc="Echo IP Java Application"                            |
| EXPOSE 60431                                        | EXPOSE=60431                                                     |
| COPY ./target/app-in-host.jar /opt/app-in-image.jar | scp \<HOST>/target/app-in-host.jar \<IMAGE>/opt/app-in-image.jar |
| WORKDIR /opt                                        | cd /opt                                                          |
| ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]   | ./java -jar app-in-image.jar                                     |

- line 1 : 이미지를 가져오고, 가져온 이미지 내부에서 컨테이너 이미지를 빌드<br>누군가 만들어 놓은 이미지에 필요한 부분을 추가한다고 보면 됨<br>기초 이미지를 어떤 것을 선택하냐에 따라 다양한 환경의 컨테이너 빌드 가능
- line 2 : 이미지에 부가적인 설명을 위한 레이블을 추가할 때 사용
- line 3 : 생성된 이미지로 컨테이너를 구동할 때 어떤 포트를 사용할지 알려줌<br>외부와 연결하려면 지정한 포트를 호스트 포트로 연결해야 한다고 알려줄 뿐 자동 연결은 아님<br>외부에서 접속하려면 `docker run`에 `-p` 옵션을 넣어야 함
- line 4 : 호스트에서 새로 생성한 컨테이너 이미지로 필요한 파일 복사
- line 5 : 이미지의 현재 작업 위치를 변경
- line 6 : \["명령어", "옵션" ... "옵션"]의 형식<br>컨테이너 구동 시 안의 명령어에 옵션들을 붙여서 실행

<br>
<br>

## 컨테이너 용량 줄이기

- 불필요한 공간을 점유하면 비용 낭비가 되고 성능 저하가 될 수 있음
- 기초 이미지를 openjdk에서 GCR(Google Container Registry)에서 제공하는 distroless로 변경
  - distroless는 Java 실행을 위해 경량화된 이미지
- 왜 openjdk를 호스트에 설치해서 빌드하고 COPY로 넘기는 번거로운 작업을 해야 할까?

<br>
<br>

## 컨테이너 내부에서 컨테이너 빌드하기

- openjdk 이미지를 기초 이미지로 컨테이너 내부에서 Java 소스를 빌드하면 가장 큰 컨테이너를 얻게 됨
- 컨테이너 이미지는 커지면 커질수록 비효율적
- 하지만 Dockerfile 하나만 빌드하면 컨테이너가 바로 생성되는 편리함을 포기할 순 없으니 이를 위한 마지막 방법이 따로 있음

<br>
<br>

## 최적화해 컨테이너 빌드하기

**Multi-Stage Build**

- 최종 이미지의 용량을 줄일 수 있고 호스트에 어떠한 빌드 도구도 설치할 필요가 없음
- 멀티 스테이지는 docker-ce 17.06 버전부터 지원됨
  - 도커 버전 확인 방법 : `kubectl get nodes -o wide` 명령어 입력 후 CONTAINER_RUNTIME 확인
- 핵심은 빌드하는 위치와 최종 이미지를 '분리'하는 것
  - 그래서 최종 이미지는 빌드된 JAR를 가지고 있지만 용량을 줄일 수 있음

※ Dockerfile

```bash
# 1단계 : Java 소스를 빌드해서 JAR로 만듦
FROM openjdk:8 AS int-build # 기초 이미지에 int-build라는 별칭을 붙임
LABEL description="Java Application builder"
RUN git clone https://github.com/iac-source/inbuilder.git
WORKDIR inbuilder
RUN chmod 700 mvnw
RUN ./mvnw clean package

# 2단계 : 빌드된 JAR를 경량화 이미지에 복사
FROM gcr.io/distroless/java:8
LABEL description="Echo IP Java Application"
EXPOSE 60434
# int-build에서 빌드가 완성된 JAR 파일을 distroless에 지정된 디렉토리로 복사
COPY --from=int-build inbuilder/target/app-in-host.jar /opt/app-in-image.jar
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

- `docker images | head -n 3` 명령어로 확인해보면 이름이 없는 `<none>` 이미지가 있는데,<br>이는 dangling 이미지이며, 멀테 스테이지 과정에서 Java 소스를 빌드하는 과정에서 생성된 이미지
  - 공간을 적게 사용하기 위해선 `docker rmi $(docker images -f dangling=true -q)` 같은 명령어로 삭제해야 함

<br>
<br>

# 쿠버네티스에서 직접 만든 컨테이너 사용하기

- 앞에서 컨테이너 이미지를 빌드하는 방법을 다양하게 소개한 최종 목적은<br>직접 만든 컨테이너 이미지를 쿠버네티스에서 사용하는 것
- 쿠버네티스에서 이미지를 사용하려면 쿠버네티스가<br>이미지를 불러올 수 있는 공간에 이미지를 넣어두어야 함

<br>
<br>

## 쿠버네티스에서 도커 이미지 구동하기

- 이미지가 이미 docker 환경으로 호스트에 존재하면<br>기본 설정에 따라 이미지를 외부(도커 허브)에서 받으려고 시도하게 됨
  - yaml 파일에서 `imagePullPolicy: Never` 설정 필요
  - 위 옵션을 통해 외부 이미지를 가져오지 않고 호스트에 존재하는 이미지를 사용하도록 설정
- 그러나 위 방법으로는 이미지가 모든 워커 노드에 있어야 함
- 이를 해결하는 방법은 크게 2가지
  - 기본적으로 사용하는 도커 허브에 올려 놓고 다시 받기
  - 쿠버네티스 클러스터가 접근할 수 있는 곳에 이미지 레지스트리를 만들고 그곳에서 받아오기
- 이 책에서는 도커 허브의 방법은 너무 쉬우니 어려운 길을 갈 것

<br>
<br>

## 레지스트리 구성하기

- 호스트에서 생성한 이미지를 쿠버네티스에서 사용하려면 모든 노드에서 공통으로 접근하는 레지스트리가 필요함
- 도커나 쿠버네티스는 도커 허브라는 레지스트리에서 이미지를 내려받을 수 있음
- 때로는 직접 만든 이미지를 private하게 할 필요가 있음
  - 도커 허브에서도 private repository를 제공하지만 무료 사용자에게는 1개 밖에 허용되지 않음
  - 도커 허브 무료 사용자는 이미지를 내려받는 횟수에도 제약이 있음
- 제약 없이 사용하기 위해 레지스트리를 직접 구축하는 방법이 있음
  - 인터넷 연결이 필요 없으므로 내부 전산망에서도 구현 가능
- 책에서는 Docker Registry 이미지를 사용해서 사설 도커 레지스트리를 만듦
  - 사설 도커 레지스트리는 기능은 부족하지만 컨테이너를 하나만 구동하면 되기에 설치가 간편하고<br>내부에서 테스트 목적으로 사용하기에 적합

<br>

※ 레지스트리 종류

- Quay
  - 레드햇에서 제공하는 이미지 레지스트리
  - 오픈 소스 무료 버전과 서버에 직접 설치하는 유료 버전, 클라우드 비용을 지불하는 서비스형 상품이 있음
  - 유료로 사용하면 신뢰성 보증과 기술 지원 서비스를 받을 수 있으므로 안정적으로 사용하고 싶은 분들에게 추천
- Harbor
  - 클라우드 네이티브 컴퓨팅 재단의 지원을 받는 Project Harbor에서 오픈 소스로 제공하는 레지스트리
  - 도커 이미지 외에 헬름 차트도 저장 가능
  - 이미지와 헬름 차트를 모두 사용하는 유저에게 적합
- Nexus Repository
  - Sonatype에서 만든 레지스트리
  - 오픈 소스 무료 버전과 유료 버전이 있음
  - 도커 이미지 외에도 리눅스 설치 패키지, 자바 라이브러리, 파이썬 라이브러리 등 다양한 형식의 파일 저장 가능
  - 여러 형식의 패키지를 하나의 저장소에 관리하려는 유저에게 적합
  - 다양한 형식 지원 덕분에 레지스트리 중 가장 많은 사용자를 보유하고 있음
- Docker Registry
  - 도커 허브에서 제공하는 레지스트리 전용 컨테이너 이미지
  - 무료로 사용할 수 있고 도커 이미지만 저장 가능
  - 기능이 매우 간단해서 개인용이나 테스트용으로 적합

|   구분    |        Quay         |      Harbor       | Nexus Repository | Docker Registry |
| :-------: | :-----------------: | :---------------: | :--------------: | :-------------: |
|   가격    |       유/무료       |       무료        |     유/무료      |      무료       |
| 저장 형식 |  도커 이미지, 헬름  | 도커 이미지, 헬름 |      다양함      |   도커 이미지   |
| 설치 방법 | 직접 설치, 클라우드 |     직접 설치     |    직접 설치     |    직접 설치    |
|   기능    |   부가 기능 있음    |  부가 기능 있음   |    매우 많음     |      최소       |
| 관련 자료 |        적음         |       보통        |       많음       |      많음       |

<br>

**실습 - 사설 도커 레지스트리 만들기**

※ tls.csr

- 인증서 생성을 위한 서명 요청서
- CSR : Certificate Signing Request
- 인증서를 생성하는 개인이나 기관의 정보와 인증서를 생성하는 데 필요한 추가 정보들 기록
- 이 파일을 기반으로 인증서와 개인키를 생성함
- 도커는 이미지를 올리거나 내려받으려고 레지스트리에 접속하는 과정에서 SAN을 검증함
  - SAN : Subject Alternative Name

```
[req]
distinguished_name = private_registry_cert_req
x509_extensions = v3_req
prompt = no

[private_registry_cert_req]
C = KR
ST = SEOUL
L = SEOUL
O = gilbut
OU = Book_k8sInfra
CN = 192.168.1.10

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.0 = m-k8s
IP.0 = 192.168.1.10
```

- \[private_registry_cert_req]<br>인증서 요청자의 국가, 도시, 소속, 이름, 인증서를 설치하는 서버의 주소 등의 정보
- \[v3_req] : 키의 사용 목적 기입, alt_names의 정보를 주체 대체 이름(SAN)으로 이용
- \[alt_names] : 도메인 이름과 사이트가 일치하는지 확인할 때 사용하는 추가적인 정보

<br>

※ create-registry.sh

- 실제로 레지스트리를 생성하고 구동하는 과정이 담긴 스크립트
- 인증서 생성과 배포, 레지스트리 생성과 구동의 순서로 이루어져 있음

```sh
#!/usr/bin/env bash
certs=/etc/docker/certs.d/192.168.1.10:8443
mkdir /registry-image
mkdir /etc/docker/certs
mkdir -p $certs
openssl req -x509 -config $(dirname "$0")/tls.csr -nodes -newkey rsa:4096 \
-keyout tls.key -out tls.crt -days 365 -extensions v3_req

yum install sshpass -y
for i in {1..3}
  do
    sshpass -p vagrant ssh -o StrictHostKeyChecking=no root@192.168.1.10$i mkdir -p $certs
    sshpass -p vagrant scp tls.crt 192.168.1.10$i:$certs
  done

cp tls.crt $certs
mv tls.* /etc/docker/certs

docker run -d \
  --restart=always \
  --name registry \
  -v /etc/docker/certs:/docker-in-certs:ro \
  -v /registry-image:/var/lib/registry \
  -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/docker-in-certs/tls.crt \
  -e REGISTRY_HTTP_TLS_KEY=/docker-in-certs/tls.key \
  -p 8443:443 \
  registry:2
```

- certs 변수 : 도커가 지정된 변수 경로에서 레지스트리 주소와 일치하는 디렉토리에<br>위치한 인증서를 찾아 레지스트리에 HTTPS로 접속함<br>마스터 노드와 워커 노드에 인증서 디렉토리를 생성할 때 변수 certs를 찾게 됨
- openssl 부분 : HTTPS 접속을 하려면 서버의 정보가 담긴 인증서와 주고 받는 데이터 암호화 및 복호화에 사용할 키가 필요함<br>요청서가 담긴 tls.csr 파일로 HTTPS 인증서인 tls.crt와 키에 사용할 tls.key 파일 생성<br>`$(dirname "$0")`은 현재 shell 파일이 실행되는 경로로 치환해줌
- sshpass : SSH 접속을 위한 비밀번호를 자동으로 입력해주는 도구<br>이게 없으면 직접 입력해야 하는데, 그럴 경우 자동화 과정이 힘듦
- for문 부분 : 각 워커 노드에 대한 인증서 디렉토리 생성 및 복사를 위한 반복 작업
- cp 부분 : tls.crt를 certs 변수로 지정한 디렉토리로 복사
- mv 부분 : tls.crt와 tls.key를 /etc/docker/certs/ 디렉토리로 이동
  - 레지스트리 컨테이너에 들어오는 요청을 인증하고, 인증서가 설치된 호스트에서만 레지스트리에 접근할 수 있게 함
- docker run
  - -d : 컨테이너 백그라운에서 데몬으로 실행
  - --restart=always : 정지되면 자동으로 재실행
  - --name registry : 이름은 registry
  - -v : 인증서 디렉토리를 컨테이너 내부의 docker-in-certs 디렉토리와 연결 및 ro(readonly) 설정<br>호스트 저장 공간 registry-image 디렉토리를 컨테이너 내부의 /var/lib/registry 디렉토리와 연결
  - -e : 레지스트리가 요청을 받아들이는 포트로 443번 포트를 설정<br>레지스트리가 사용할 HTTPS 인증서의 경로 설정<br>HTTPS로 데이터를 주고받을 때 데이터 암호화 및 복호화를 위한 키로 사용할 파일의 경로를 설정
  - -p : 호스트 컴퓨터의 8443번 포트와 컨테이너 내부의 443번 포트를 연결
  - 마지막 줄 : 도커 허브에 있는 registry 이미지로 2.\*의 최신 버전을 사용함

<br>

- 배포 시 `docker tag` 사용
  - 레지스트리가 서비스되는 주소와 제공되는 이미지 이름을 레지스트리에 등록될 이름으로 지정해야 하기 때문
  - docker tag : 이미지의 레이어를 공유하는 사본을 만듦, 윈도우의 바로가기와 유사
- 배포 확인 방법 : `curl <레지스트리 주소>/v2/_catalog`
  - 예시 : `curl https://192.168.1.10:8443/v2/_catalog -k`
  - 레지스트리에 등록된 이미지의 목록을 보여줌
  - 자체 서명 인증서를 쓰는 사이트이기 때문에 -k(--insecure) 옵션으로 보안 검증 생략
- 이미지를 삭제하려면 ID를 `docker images | grep <이름>` 명령어로 알아내서 삭제
  - 삭제 예시 : `docker rmi -f aa23`
