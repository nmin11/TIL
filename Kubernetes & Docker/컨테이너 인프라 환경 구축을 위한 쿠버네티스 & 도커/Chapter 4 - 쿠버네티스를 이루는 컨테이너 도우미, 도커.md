# 도커를 알아야 하는 이유

- 쿠버네티스를 말할 때 Docker를 자주 이야기하곤 함
- 쿠버네티스를 이루는 기본 오브젝트가 파드고, 파드는 컨테이너로 이루어져 있으며,<br>컨테이너를 만들고 관리하는 도구가 도커이기 때문
- 그래서 시중의 다른 책들과 같이 도커를 배우고 나서 쿠버네티스를 배우는 것이 흐름에 맞음
- 그러나 최근에는 도커를 몰라도 쿠버네티스를 사용하는 것이 가능해짐
  - 여러 공급사에서 만든 컨테이너 이미지로 쿠버네티스에 컨테이너 인프라 서비스를 만들 수 있다는 뜻
  - 컨테이너 관리 기술이 발전했고 여러 애플리케이션이 이미 도커 이미지로 배포되고 있어서<br>배포된 이미지를 사용하면 도커를 몰라도 쿠버네티스 환경을 만들고 사용할 수 있음
- 하지만 쿠버네티스를 이루고 있는 기술 자체는 컨테이너를 벗어날 수 없음
- 따라서 트러블슈팅을 제대로 하려면 컨테이너를 잘 알아야 함
- 그리고 상황에 따라 직접 만든 소스 코드를 빌드해 컨테이너로 만들고 이를 쿠버네티스에서 사용할 수도 있음
- 다음 장에서 배울 CI와 CD, 그리고 모니터링도 모두 컨테이너로 관리됨
- 따라서 컨테이너와 이를 다루는 도커를 자세히 알면 인프라 환경을 한층 더 깊게 이해할 수 있음

<br>
<br>

## 파드, 컨테이너, 도커, 쿠버네티스의 관계

- 현재 쿠버네티스 시스템
  - 파드들은 워커 노드라는 노드 단위로 관리하며, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됨
  - 파드는 1개 이상의 컨테이너로 이루어져 있음
- 파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공함<br>그리고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 함
  - 파드가 이러한 환경을 만들기 때문에 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 작동 가능
- 정리하면, 컨테이너를 돌보는 것이 파드고, 파드를 돌보는 것이 쿠버네티스 워커 노드이며,<br>워커 노드를 돌보는 것이 쿠버네티스 마스터
  - 그런데 쿠버네티스 마스터 역시 파드(컨테이너)로 이루어져 있음
- **컨테이너** : 이 구조를 이루는 가장 기본, 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간
- **개별적인 실행 환경** : CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경
  - 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리되어 관리됨
  - 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있음
- 각 컨테이너가 독립적으로 작동하기 때문에 여러 컨테이너를 효과적으로 다룰 방법이 필요해졌는데,<br>이런 과정을 쉽게 만들어 주는 도구로 등장한 것이 도커
  - 도커는 컨테이너를 사용하는 방법을 명령어로 정리한 것으로 보면 됨
  - 도커를 사용하면 사용자가 따로 신경쓰지 않아도 컨테이너를 생성할 때 개별적인 실행 환경을 분리하고 자원을 할당함

<br>
<br>

## 다양한 컨테이너 관리 도구

- Containerd
  - Docker사에서 컨테이너 런타임 부분을 분리하여 만든 오픈 소스 컨테이너 관리 도구
  - 쿠버네티스와의 통신에 필요한 CRI 규격에 맞춰 구현한 플러그인을 사용해 쿠버네티스와 통합 가능
  - 다른 시스템을 통합해 컨테이너를 관리하는 기능을 제공하므로 컨테이너 관리 도구를 직접 개발하려는 개발자에게 적합
- CRI-O
  - 레드햇에서 개발해 클라우드 2019년 네이티브 컴퓨팅 재단에 기부한 오픈 소스 프로젝트로, 현재 Incubating 단계에 있음
  - 범용적인 컨테이너 관리 도구들과 달리 쿠버네티스와 통합하는 것을 주목적으로 함
  - 다른 도구보다 가볍고 단순하며, CRI 규격을 자체적으로 구현하고 있어서<br>별도의 구성 요소나 플러그인 없이 쿠버네티스와 통합 가능
  - 역사가 짧고 많이 사용되지도 않아서 관리와 구성에 관한 자료가 부족함
- Kata Containers
  - Openstack foundation에서 후원하는 오픈 소스 컨테이너 관리 도구
  - 컨테이너마다 독립적인 커널 제공
    - 개별 컨테이너를 위한 가벼운 가상 머신을 생성하고 그 위에서 컨테이너가 작동
    - 기술적으로 보면 기존 컨테이너 방식과 가상화 방식의 중간 영역에 있음
  - 보안이 강하지만 CPU 및 메모리 크기가 기존 방식보다 크게 소요됨
  - 사용자 층이 넓지 않아 자료가 부족함
- Docker
  - Docker사에서 2013년에 만든 컨테이너 관리 도구
  - 컨테이너 관리 기능 외에도 컨테이너를 실행하는 데 필요한 이미지 생성 및 공유 등 다양한 기능 제공
  - 명령어 도구 CLI와 명령을 받아들이는 도커 데몬으로 구성되어 있음
  - 1.11 버전 이후로 별도의 컨테이너디를 포함하고 있음
  - 네트워크를 통한 호출로 작동하므로 구조적으로는 다소 복잡하지만 이를 모두 도커에서 관리함

|     구분      | Containerd |    CRI-O     | Kata Containers |  Docker   |
| :-----------: | :--------: | :----------: | :-------------: | :-------: |
|  명령어 도구  | 별도 지원  | 타 도구 사용 |    자체 지원    | 자체 지원 |
|   내부 구조   |    단순    |  매우 단순   |      복잡       |   복잡    |
|    확장성     |    좋음    |  좋지 못함   |    좋지 못함    | 매우 좋음 |
| 컨테이너 관리 |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|  이미지 관리  |    좋음    |     좋음     |      좋음       | 매우 좋음 |
|    보안성     |    좋음    |     좋음     |    매우 좋음    |   좋음    |
|  자원 사용량  | 매우 좋음  |  매우 좋음   |    좋지 못함    |   좋음    |
|    정보량     |    적음    |  거의 없음   |    거의 없음    | 매우 많음 |

<br>
<br>

# 도커로 컨테이너 다루기

**컨테이너 이미지와 컨테이너의 관계**

- 컨테이너 이미지는 베이그런트 이미지와 유사
- 베이그런트 이미지가 베이그런트 없이 사용할 수 없듯, 컨테이너 이미지도 도커와 같은 CRI로 불러와야만 실행 가능
- 따라서 컨테이너를 삭제할 때는 이미지와 이미 실행된 컨테이너를 모두 삭제해야 디스크 용량 확보 가능

<br>
<br>

## 컨테이너 이미지 알아보기

### 이미지 검색하고 내려받기

- 이미지는 registry라고 하는 저장소에 모여 있음
- registry는 도커 허브처럼 공개된 유명 registry일 수도 있고, 내부에 구축한 registry일 수도 있음
- 이미지는 레지스트리 웹 사이트에서 직접 검색해도 되고,<br>슈퍼푸티 명령 창에서 쿠버네티스 마스터 노드에 접속해서 검색할 수도 있음
- 슈퍼푸티에서의 검색 명령어 : `docker search <검색어>`
  - 검색어를 포함하는 이미지가 있는지 찾아냄
  - INDEX : 이미지가 저장된 레지스트리의 이름
  - NAME : 검색된 이미지 이름, 공식 이미지가 아니라면 `레지스트리 주소/저장소 소유자/이미지 이름`의 형태
  - DESCRIPTION : 이미지에 대한 설명
  - STARS : 해당 이미지를 내려받은 사용자에게 받은 평가 횟수
  - OFFICIAL : `[OK]`가 있으면 해당 이미지에 포함된 애플리케이션, 미들웨어 등을<br>개발한 업체에서 공식적으로 제공한 이미지라는 의미
  - AUTOMATED : `[OK]`가 있으면 도커 허브에서 자체적으로 제공하는<br>이미지 빌드 자동화 기능을 활용해서 생성한 이미지라는 의미
- 이미지 내려받기 명령어 : `docker pull <이름>`
  - Tag : 이미지를 내려받을 때 사용한 태그를 알려줌<br>조건을 주지 않고 pull하면 기본으로 latest 태그 적용
  - Layer : pull을 수행해서 내려받은 레이어들 표시<br>하나의 이미지는 여러 개의 레이어로 이루어져 있어서 각 레이어마다 Pull complete 메시지가 발생함
  - Digest : 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경 식별할 수 있게 함<br>식별자는 hash 함수로 생성되며 이미지가 동일한지 검증하는 데 사용됨
  - Status : `레지스트리 이름/이미지 이름:태그`

<br>

### 이미지 태그

- 태그 : 이름이 동일한 이미지에 추가하는 식별자
- 이름이 동일해도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하는 데에 사용됨
- 관련 정보는 도커 허브(https://hub.docker.com/)에서 해당 이미지를 검색하고 Tags 탭에 가면 확인 가능
- 태그 적용 예시 : `docker pull nginx:stable`

<br>

### 이미지의 레이어 구조

- 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP 같은 압축 파일에 더 가까움
  - 압축 파일은 파일 개수에 따라 용량이 증가하지만<br>이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유하므로 전체 용량이 감소함
- 이미지 조회 명령어 : `docker images <이미지 이름>`
- 이미지의 생성 과정 조회 명령어 : `docker history <이미지 이름>`
  - `docker history`는 도커 컨테이너 이미지 자체를 만드는 명령어를 보여줌
