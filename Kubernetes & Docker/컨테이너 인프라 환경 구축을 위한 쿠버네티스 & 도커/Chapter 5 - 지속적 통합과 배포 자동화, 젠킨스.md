**※ Pipeline**

1. Github 등의 저장소에 저장해 둔 애플리케이션 소스 코드를 내려받아 도커 컨테이너 이미지로 빌드
2. 빌드한 컨테이너 이미지를 쿠버네티스에서 사용할 수 있도록 레지스트리에 등록
3. 레지스트리에 등록된 이미지를 기반으로 쿠버네티스 오브젝트 생성
4. 생성한 오브젝트(Pod/Deployment)를 외부에서 접속할 수 있도록 서비스 형태로 노출

- 기존에는 이러한 파이프라인을 수작업으로 진행했지만 이제는 도구를 사용해서 자동화할 수 있음
- 자동화는 크게 CI(Continuous Integration), CD(Continuous Deployment) 2가지로 정의되며<br>일반적으로 둘을 합쳐서 CI/CD라고 함

<br>
<br>

# 컨테이너 인프라 환경에서 CI/CD

- CI : 코드를 커밋하고 빌드했을 때 정상적으로 작동하는지 반복적으로 검증해서<br>애플리케이션의 신뢰성을 높이는 작업
- CD : CI 과정에서 생성된 신뢰할 수 있는 애플리케이션을 실제 상용 환경에 자동으로 배포하는 것
- 애플리케이션 배포 시 고려 사항들을 CD에 미리 정의하면 실수를 줄이고 적용 시간도 최소화할 수 있음

※ 컨테이너 인프라 관점에서의 CI/CD

1. 개발자가 소스를 커밋하고 푸시하면 CI 단계 진입
2. 애플리케이션 자동 빌드 및 테스트를 통해 배포할 수 있는 애플리케이션인지 확인하고,<br>통과하면 CD 단계 진입
3. 애플리케이션을 컨테이너 이미지로 만들어서 Pod, Deployment, StatefulSet 등<br>다양한 오브젝트 조건에 맞춰 미리 설정한 파일을 통해 배포

<br>
<br>

## CI/CD 도구 비교

- Teamcity
  - Jetbrains에서 만들었으며, Kotlin을 기반으로 만든 Kotlin DSL이라는 스크립트 언어로 작업 구성
  - 빌드 작업을 수행하는 에이전트 3개와 빌드 작업 100개를 무료로 사용 가능
  - 더 많은 에이전트를 사용하려면 유료 결제를 해야 함
- Github Action
  - Github에서 지원하는 Workflow 기반의 CI/CD 도구
  - Github에 저장한 소스 코드를 자동 분석한 결과를 기반으로<br>Github Action이 추천하는 방식에 따라 Workflow를 구성하거나<br>사용자가 직접 Workflow를 정의하는 파일을 작성한 후 Github 저장소에 넣어 사용할 수 있음
  - Github 저장소가 public하면 무료로 사용 가능하지만 한 달에 2,000분이라는 제한 시간이 있음
  - 추가로 사용할 경우 분 단위의 요금이 별도로 부과됨
- Bamboo
  - Atlassian에서 만든 도구
  - 유료이며 사용자의 서버에 설치해서 사용함
  - Atalssian에서 만든 다른 협업 도구와 연계해서 사용하기에 좋음
- Jenkins
  - 오픈 소스 CI/CD 도구
  - 사용자가 직접 UI에서 작업을 구성하거나 작업 순서를 코드로 정의할 수 있음
  - 역사, 인지도, 사용자 수에서 CI/CD 도구의 대명사라 해도 될 정도로 널리 알려져 있음
  - 그만큼 필요한 정보를 찾기 쉽고 플러그인 개발 관련 커뮤니티 활동도 활발하여,<br>다양한 사용 환경, 언어 및 빌드 도구와 연계할 플러그인을 쉽게 찾을 수 있음
  - 특정 언어나 환경에 구애받지 않고 범용적인 목적으로 무난하게 쓸 수 있음

|   구분    | Teamcity  | Github Action |  Bamboo   |   Jenkins   |
| :-------: | :-------: | :-----------: | :-------: | :---------: |
| 설치 방식 | 직접 설치 |  Github 연동  | 직접 설치 |  직접 설치  |
| 연계 기능 |   보통    |     보통      |   부족    |  매우 많음  |
|   가격    | 무료/유료 |   무료/유료   |   유료    |    무료     |
| 기능 추가 |   보통    |  매우 다양함  |   보통    | 매우 다양함 |
|  범용성   |   보통    |    매우 큼    |   보통    |   매우 큼   |
|  정보량   |  부족함   |     많음      |   많음    |  매우 많음  |

<br>

- 이외에도 퍼블릭 클라우드 기반의 시스템일 때는<br>클라우드 서비스 제공 업체에서 배포하는 CI/CD 도구를 사용해볼 수도 있음
  - AWS CodeBuild, CodePipeline, CodeDeploy, GCP CloudBuild, Azure Pipelines
- 배포가 중요한 환경에서는 CD 기능에 중점을 둔 Spinnaker나 Argo CD를 선택적으로 도입할 수도 있음

<br>

**About Jenkins**

- 거의 모든 환경에서 사용할 수 있도록 다양한 플러그인을 추가해 원하는 형태를 만드는 블록 방식
- CI/CD를 처음 해볼 때는 가장 대중적인 젠킨스로 하는 것이 좋음

<br>
<br>

## 젠킨스로 쿠버네티스 운영 환경 개선하기

- 애플리케이션 배포 영역에 쿠버네티스를 사용하면 개발자는 애플리케이션 개발에만 집중할 수 있게 됨
- 모든 배포 환경을 컨테이너 인프라로 일원화하고, CI/CD 도구를 사용하면<br>애플리케이션에 맞는 환경을 적용해 자동으로 배포할 수 있음

※ 대략적인 과정

1. 개발자가 소스 코드를 저장소에 push
2. 쿠버네티스 내부에 설치된 젠킨스는 코드를 빌드하고 레지스트리에 push
3. 쿠버네티스에서 사용 가능한 형태로 배포

<br>

- 젠킨스는 작업 내용을 Item 단위로 정의하고 조건에 따라<br>자동으로 작업을 수행해서 효율을 높이고 실수를 줄임
- 컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는<br>애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위해서
- 그러기 위해 단순히 젠킨스용 파드만을 배포해서는 만들어지지 않음
- 젠킨스는 컨트롤러와 에이전트 형태로 구성한 다음 배포애야 하며 여기에 필요한 설정을 모두 넣어야 함
- 이러한 환경을 하나하나 구성하는 것은 복잡하고 번거롭기 때문에 동적으로 변경할 수 있게 해주는<br>kustomize나 Helm의 도움을 받으면 좋음

<br>
<br>

# 젠킨스 설치를 위한 간편화 도구 살펴보기

- 필요에 따라 다수의 오브젝트를 사용해야 하는데, 이미 3장에서 매니페스트를 실행한 적이 있음
  - MetalLB 구동을 위해 수많은 오브젝트를 미리 정의된 하나의 매니페스트에 넣고 바로 실행했음
- 오브젝트를 단순히 정의한 대로만 사용한다면 젠킨스나 커스터마이즈, 헬름 등은 알 필요가 없음
- 쿠버네티스 클러스터 환경에서는 이러한 배포 도구들이 이미 준비되어 있음

<br>
<br>

## 배포 간편화 도구 비교하기

- kubectl
  - 쿠버네티스에 기본으로 포함된 커맨드라인 도구로, 추가 설치 없이 바로 사용 가능
  - 오브젝트 생성과 쿠버네티스 클러스터에 존재하는 오브젝트, 이벤트 등의 정보를 확인하는 데 사용됨
  - 오브젝트의 명세가 정의된 yaml 파일을 인자로 입력받아서 오브젝트를 배포할 수도 있음
  - 정의된 매니페스트 파일을 그대로 배포하기 때문에 개별적인 오브젝트를 관리하거나 배포할 때 좋음
- kustomize
  - 오브젝트를 사용자의 의도에 따라 유동적으로 배포할 수 있음
  - 별도의 커스터마이즈 실행 파일을 활용해서 커스터마이즈 명세를 따르는 yaml 파일 생성 가능
  - yaml 파일이 이미 존재한다면 kubectl로 -k 옵션을 활용해서 배포 가능
    - 그만큼 kubectl과 매우 밀접하게 동작
  - yaml 파일에 변수나 템플릿을 사용하지는 않지만<br>명령어로 배포 대상 오브젝트의 이미지 태그와 레이블 같은 명세를 변경하거나<br>일반 파일을 이용해 ConfigMap과 시크릿을 생성하는 기능을 지원함
  - 그렇기에 운영 중인 환경에서 배포 시 가변적인 요소를 적용하는 데 적합
- Helm
  - 쿠버네티스 사용자의 70% 이상이 사용하고 있을 정도로 널리 알려진 도구
  - 오브젝트 배포에 필요한 사양이 이미 정의되어 있는 Chart라는 패키지 활용
    - 헬름 차트 저장소가 온라인에 있기에 패키지를 검색하고 내려받아 사용하기가 매우 간편
    - 헬름 차트는 자체적인 템플릿 문법을 사용하므로 가변적인 인자를 배포할 때<br>다양한 배포 환경에 맞추거나 원하는 조건을 적용할 수 있음
  - 오브젝트를 묶어서 패키지 단위로 관리하므로 1개의 명령어로 애플리케이션에 필요한 오브젝트들 구성 가능

|    구분     |        kubectl        |              kustomize              |               Helm                |
| :---------: | :-------------------: | :---------------------------------: | :-------------------------------: |
|  설치 방법  | 쿠버네티스 기본 포함  | 별도 실행 파일 또는 쿠버네티스 통합 |             별도 설치             |
|  배포 대상  |       yaml 파일       |          커스터마이즈 파일          |           패키지(차트)            |
|   주 용도   | 오브젝트 관리 및 배포 |        오브젝트 가변적 배포         | 패키지 단위 오브젝트 배포 및 관리 |
| 가변적 환경 |       대응 힘듦       |          간단한 대응 가능           |         복잡한 대응 가능          |
| 기능 복잡도 |        단순함         |                보통                 |              복잡함               |

<br>
<br>

## 커스터마이즈로 배포 간편화하기

- 커스터마이즈를 활용하면 kubectl이 매니페스트를 고정적으로 이용했던 방식에 비해 유연해짐

<br>

### 커스터마이즈 작동 원리

- 커스터마이즈는 yaml 파일에 정의된 값을 사용자가 원하는 값으로 변경 가능
- 사용자가 직접 yaml 파일을 편집기를 통해 수정할 경우 문제가 발생하진 않지만<br>수정해야 하는 yaml 파일이 많거나, 여러 개의 쿠버네티스 클러스터가 있어서<br>LABEL이나 NAME 같은 항목들을 일일이 수정해야 한다면 많은 노력이 드는데,<br>이를 위해 커스터마이즈는 `kustomize` 명령을 제공함
- `kustomize` 명령과 `create` 옵션으로 **kustomization.yaml** 이라는 기본 매니페스트를 제작하고<br>이 파일에 변경해야 하는 값들을 적용함
- `build` 옵션으로 변경할 내용이 적용된 최종 yaml 파일을 저장하거나 변경된 내용이 바로 실행되도록 지정함

<br>

### 실습: 커스터마이즈로 MetalLB 한 번에 만들기

- 커스터마이즈를 사용해서 MetalLB를 만든다는 것은 사실상 명세서인 kustomization.yaml을 만드는 과정
- 그리고 만들어진 yaml 파일을 통해서 MetalLB 매니페스트를 생성하고, 이 매니페스트를 통해서 배포하는 것
- 즉, 커스터마이즈는 단순히 최종 매니페스트 생성을 도와주는 도구인 셈
- 이미지 태그 변경 명령어 : `kustomize edit set image`
  - 예시 : `kustomize edit set image metallb/controller:v0.8.2`
- 매니페스트 생성 명령어 : `kustomize build`
- 빌드 및 배포 명령어 : `kustomize build | kubectl apply -f -`
  - 빌드한 결과가 바로 `kubectl apply`에 인자로 전달되어 배포되도록 함
- 빌드 삭제 명령어 : `kustomize build | kubectl delete -f -`
- 커스터마이즈는 여러 변경 부분을 사용자가 직접 추가하고 최종적으로 필요한 매니페스트를 만들어서 배포해야 함
- 이러한 수동적 방식 말고 선언적으로 필요한 내용을 제공하기 위해서는 헬름을 사용해야 함

<br>

## 헬름으로 배포 간편화하기

### 헬름 작동 원리

- 헬름은 쿠버네티스에 패키지를 손쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저
- 일반적으로 패키지는 실행 파일뿐만 아니라 실행 환경에 필요한 의존성 파일과 환경 정보들의 묶음
- 패키지 매니저는 외부에 있는 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구
- 패키지 매니저의 다양한 목적들 중의 핵심 : 설치에 필요한 의존성 파일들을 관리하고 간편하게 설치하도록 돕는 것

※ 플랫폼별 패키지 매니저

|   플랫폼   | 패키지 매니저 |      저장소       |          사용 목적          |
| :--------: | :-----------: | :---------------: | :-------------------------: |
|   Linux    |   yum, apt    |   배포판 저장소   |   소프트웨어 의존성 관리    |
|   Python   |      pip      |     pypi.org      |   파이썬 모듈 의존성 관리   |
|    Java    |     maven     | mvnrepository.com | 자바 라이브러리 의존성 관리 |
| Kubernetes |     helm      |  artifacthub.io   |   쿠버네티스 패키지 관리    |

- 패키지 매니저의 역할 : 손쉬운 설치와 관리
  - 패키지 검색 : 설정한 저장소에서 패키지를 검색하는 기능
  - 패키지 관리 : 저장소에서 패키지 정보 확인, 사용자 시스템에 설치, 삭제, 업그레이드, 되돌리기 등
  - 패키지 의존성 관리 : 패키지를 설치할 때 의존하는 소프트웨어를 같이 설치하거나 같이 삭제
  - 패키지 보안 관리 : 디지털 인증서와 패키지에 고유하게 발행되는 Checksum이라는 값으로<br>해당 패키지의 소프트웨어나 의존성이 변조됐는지 검사
- 배포 구성에 필요한 모든 쿠버네티스 오브젝트를 위해 주소 할당을 하려 할 때 헬름을 사용할 수 있음

<br>

### 헬름의 장점

- 다수의 오브젝트 배포 yaml은 파일 구분자 `---`로 묶어 단일 yaml로서 배포 가능
  - 하지만 여러 사람이 동시에 작업한 단일 yaml은 충돌이 일어날 가능성이 있음
  - 이럴 때 헬름을 사용하면 요구 조건별로 리소스를 편집하거나 변수를 넘겨서 처리하는 패키지를 만들 수 있음
- 다양한 요구 조건을 처리할 수 있는 패키지를 Chart라고 함
  - 차트는 헬름 저장소에 공개해서 여러 사용자와 공유
  - 각 사용자는 공개된 저장소에 등록된 차트를 이용해서 애플리케이션을 원하는 형태로 쿠버네티스에 배포 가능
- 배포한 애플리케이션 업그레이드, 되돌리기, 삭제 기능 제공
- 헬름 기본 저장소는 아티펙트허브(artifacthub.io)로, 다른 패키지 매니저처럼 외부에 있음
  - 다른 저장소와 달리 설치할 패키지에 대한 경로만 제공

<br>

### 헬름의 전반적인 흐름

- 생산자 영역
  - 생산자가 헬름 명령으로 작업 공간을 생성하면 templates 디렉토리로<br>애플리케이션 배포에 필요한 여러가지 yaml 파일과 구성 파일 작성 가능
  - templates 디렉토리에 조건별 분기, 값 전달 등을 처리할 수 있도록 values.yaml에 설정된 키 사용<br>값이 전달되지 않으면 기본값으로 처리하도록 values.yaml에 설정 가능<br>필요한 패키지의 여러 분기 처리나 배포에 대한 구성을 values.yaml에서 진행
  - 차트의 이름, 목적, 배포되는 애플리케이션 버전과 같은 패키지 정보를 Charts.yaml에 채워 넣음
  - 차트 구성이 완료되면 생산자가 생산자 저장소에 업로드
  - 업로드한 생산자 저장소를 아티펙트허브에 등록하면 사용자는 아티펙트허브에서 찾을 수 있게 됨
- 아티펙트허브 영역
  - 아티펙트허브 검색을 통해 사용자는 패키지 저장 주소를 확인할 수 있음
  - 이렇게 확인된 주소는 각 애플리케이션을 개발하는 주체가 관리
- 사용자 영역
  - 아티펙트허브에서 얻은 차트 저장소 주소를 헬름을 통해서 등록
  - 그리고 최신 업데이트 후 차트를 내려받고 설치
  - 이렇게 헬름을 통해 쿠버네티스에 설치된 애플리케이션 패키지를 Release라고 함
  - 헬름을 통해 배포된 릴리스를 다시 차트를 사용해 업그레이드할 수 있고 원래대로 복구할 수 있음<br>또한 사용하지 않는 헬름 릴리스를 제거할 수 있음

<br>

### 헬름 명렁어들

- 헬름 차트 저장소 등록 : `helm repo add <이름> <저장소 위치>`
- 헬름 차트 저장소 목록 확인 : `helm repo list`
- 최신 차트 정보 동기화 : `helm repo update`
- 헬름 차트 설치 : `helm install`
  - --namespace : 생성될 애플리케이션이 위치할 네임스페이스 지정
  - --create-namespace : 위 옵션으로 지정된 네임스페이스가 없을 때 네임스페이스 생성
  - --set : 헬름에서 사용할 변수를 명령 인자로 전달

<br>

=> 여기까지 젠킨스 설치를 위한 도구들을 살펴봤고, 다음에는 본격적으로 젠킨스를 설치하고 살펴볼 것

<br>
<br>

# 젠킨스 설치 및 설정하기

## 헬름으로 젠킨스 설치하기

- 헬름으로 설치되는 젠킨스는 파드에서 동작하는 애플리케이션이기 때문에<br>PV를 마운트하지 않으면 파드 재실행 시 내부 볼륨의 모든 데이터가 삭제됨
  - PV가 NFS를 통해 프로비저닝될 수 있게 해야 함
- 젠킨스를 헬름 차트로 설치해 애플리케이션을 사용하게 되면<br>젠킨스의 여러 설정 파일과 구성 파일들이 PVC를 통해 PV에 파일로 저장됨
  - 이 때 PV에 적절한 접근 ID를 부여하지 않으면 PVC를 사용해 파일을 읽고 쓰는 기능에 문제가 발생할 수 있음
  - `chown 1000:1000 /nfs_shared/jenkins` 명령어를 통해<br>젠킨스 PV가 사용할 NFS 디렉토리에 대한 접근 ID를 1000번으로 설정
    - 젠킨스 컨트롤러 이미지에서 기본적으로 사용하는 유저 ID와 그룹 ID가 1000번이기 때문
- 젠킨스는 사용자가 배포를 위해 생성한 내용과 사용자의 계정 정보,<br>사용하는 플러그인 같은 데이터를 저장하기 위해 PV와 PVC의 구성을 필요로 함

※ 젠킨스 릴리스 정보

- NAME : 젠킨스의 릴리스 이름, 이후 헬름 명령어로 젠킨스 조회, 삭제, 변경을 위해 사용하게 되는 이름
- NAMESPACE : 젠킨스가 배포된 네임스페이스
- REVISION : 배포된 릴리스가 몇 번째로 배포된 것인지 알려줌<br>`helm upgrade` 명령어로 젠킨스 버전 업그레이드 때마다 1씩 증가<br>이전 버전으로 돌아가기 위해 `helm rollback` 명령어를 사용할 수 있음<br>롤백할 경우, REVISION의 번호를 직접 지정해서 특정 리비전으로 돌아가도록 하는 것도 가능
- NOTES : 설치와 관련된 안내 사항 몇 가지 표시
  1. 젠킨스의 관리자 비밀번호를 얻어오기 위한 명령어
  2. 젠킨스가 구동되는 파드에 접속할 수 있도록 외부의 트래픽을 쿠버네티스의 파드로 전달하게 만드는 설정
  3. 젠킨스 접속 시 사용할 유저 이름 표시

<br>

- 젠킨스 배포 시 젠킨스가 마스터 노드에 있음을 확인할 수 있음
- node와 deployment의 yaml 파일을 확인해보면 taints와 tolerations가 이런 결과를 만들고 있음
- 일반적으로 taints와 tolerations는 혼합해서 사용
- 비유적으로 taints는 다루기 꺼려지는 것, tolerations는 꺼려지는 것을 참아내는 인내를 뜻함
- 그런데 쿠버네티스의 taints와 tolerations는 사전적 의미와 반대
  - 매우 특별하게 취급돼야 하는 곳에 taints 설정하고 쉽게 접근 못하는 소중한 것으로 설정
  - tolerations는 특별한 키를 가져야만 출입 가능
- 즉, 마스터 노드에 taints가 설정되어 있어서, 특별한 목적으로 사용되는 노드라는 것을 명시해둔 것
- 일반적으로 taints는 마스터 노드 이외에도 GPU 노드, DB 전용 노드 등 특별한 목적의 노드들에 주로 사용됨
- 이 책에서는 편의를 위해 젠킨스 컨트롤러가 여러 곳에 스케줄되지 않고 마스터 노드에만 스케줄됨

※ taints와 tolerations

- 관계를 어떻게 정의하냐에 따라 배포를 상당히 유연하게 만들 수 있음
- taints : key와 value, 그리고 이 둘에 따른 effect의 조합을 통해<br>taints를 통해 설정된 노드에 파드 배치 기준을 설정
  - key와 value의 조합은 taints를 설정한 노드가 어떤 노드인지를 구분하기 위해 사용함
  - key는 필수로 설정해야 하고, value는 생략할 수 있음
  - effect는 taints와 tolerations의 key 또는 value가 일치하지 않는 파드가<br>노드에 스케줄되려 하는 경우 어떤 동작을 할 것인지 나타냄
    - effect에는 NoSchedule, PreferNoSchedule, NoExecute 값을 줄 수 있음

|       효과       | taints가 설정된 노드에 파드 신규 배치                   | 파드가 배치된 노드에 taints 설정 |
| :--------------: | :------------------------------------------------------ | :------------------------------- |
|    NoSchedule    | 노드에 파드 배치 거부                                   | 노드에 존재하는 파드 유지        |
| PreferNoSchedule | 다른 노드에 파드 배치가 불가능할 때<br>노드에 파드 배치 | 노드에 존재하는 파드 유지        |
|    NoExecute     | 노드에 파드 배치 거부                                   | 파드를 노드에서 제거             |

- tolerations : 똑같이 key, value, effect를 가지고 있고, 추가적으로 operator가 있음
  - taints가 설정된 노드로 들어가기 위한 특별한 열쇠의 역할<br>key와 effect가 반드시 일치해야 함
  - 연산자는 기본적으로 Equal로 동작해서 taints와 tolerations를 비교하는 역할을 수행
  - 연산자 Exists의 경우 비교할 key와 value가 존재한다는 가정으로 taints에 접근할 만능키로 바꿔주는 역할 수행
  - key, value, effect를 연산자를 통해 비교한 후 조건에 맞는 taints를 식별하는 방식
  - key와 effect 중 생략된 요소가 있다면 해당 요소는 와일드카드로서의 의미
  - tolerations의 key, value, effect는 taints의 key, value, effect와<br>조건에 맞는지를 Equal 혹은 Exists 연산자를 통해서 판단
  - 연산자를 생략할 경우 묵시적으로 Equal을 의미함
  - 조건 판단 결과 taints와 tolerations의 조건이 맞으면<br>taints가 설정된 노드에 tolerations를 가진 파드 배치 가능
    - 조건이 맞다고 생각하는 기준은 Equal 연산자를 사용했을 때<br>taints와 tolerations의 key, value, effect까지 일치하는 경우
  - Exists 연산자 사용 시 value는 반드시 생략해야 하고 이 상태에서 key와 effect의 일치 여부 판단
    - key와 effect를 모두 생략한 상태로 Exists 연산자만 사용하면<br>taints의 key와 effect는 모든 key와 모든 effect를 의미하므로<br>Exitsts 연산자 하나만으로도 taints가 설정된 모든 노드에 대해서 해당 tolerations를 설정한 파드 배포 가능

※ jenkins-install.sh

```sh
#!/usr/bin/env bash
jkopt1="--sessionTimeout=1440"
jkopt2="--sessionEviction=86400"
jvopt1="-Duser.timezone=Asia/Seoul"
jvopt2="-Dcasc.jenkins.config=https://raw.githubusercontent.com/sysnet4admin/_Book_k8sInfra/main/ch5/5.3.1/jenkins-config.yaml"

helm install jenkins edu/jenkins \
--set persistence.existingClaim=jenkins \
--set master.adminPassword=admin \
--set master.nodeSelector."kubernetes\.io/hostname"=m-k8s \
--set master.tolerations[0].key=node-role.kubernetes.io/master \
--set master.tolerations[0].effect=NoSchedule \
--set master.tolerations[0].operator=Exists \
--set master.runAsUser=1000 \
--set master.runAsGroup=1000 \
--set master.tag=2.249.3-lts-centos7 \
--set master.serviceType=LoadBalancer \
--set master.servicePort=80 \
--set master.jenkinsOpts="$jkopt1 $jkopt2" \
--set master.javaOpts="$jvopt1 $jvopt2"
```

- jkopt 부분 : 기본 설정이 30분 넘게 사용하지 않으면 세션이 종료되므로<br>세션 유효 시간 및 세션 정리 시간을 하루로 설정
- -Duser.timezone : 기본 설정으로는 시간대가 정확히 맞지 않으므로<br>젠킨스를 통한 CI/CD 시에 명확히 작업을 구분하기 힘듦
- -Dcasc.jenkins.config : 쿠버네티스를 위한 젠킨스 에이전트 노드 설정은<br>Pod Template이라는 곳을 통해서 설정값 입력<br>그런데 마스터 노드가 재실행되면 설정이 초기화됨<br>따라서 설정값을 미리 입력해 둔 yaml 파일을 Github 저장소에서 받아오도록 설정
- helm install : edu 차트 저장소의 jenkins 차트를 사용해 jenkins 릴리스 설치
- --set persistence.existingClaim : PVC 동적 프로비저닝 사용을 위해 jenkins라는 이름의 PVC 사용하도록 설정
- --set master.adminPassword : 젠킨스 접속 시 사용할 관리자 비밀번호를 admin으로 설정<br>이 값이 없으면 jenkins가 설치 과정에서 임의로 생성한 비밀번호 사용
- --set master.nodeSelector : 젠킨스의 컨트롤러 파드를 쿠버네티스 마스터 노드에 배치하도록 선택<br>`nodeSelector`는 뒤에 따라오는 문자열과 일치하는 레이블을 가진 노드에 파드를 스케줄링하겠다는 설정<br>`.` 앞의 `\`는 점을 하위 속성으로 분리하게 되기 때문에 이를 방지하기 위한 escape
- --set master.tolerations[0] : 이 옵션들이 없으면 마스터 노드에 파드를 배치할 수 없음<br>현재 마스터 노드에 NoSchedule taints가 설정되어 있기 때문<br>taints가 설정된 노드에 파드를 배치하려면 tolerations 옵션 필요<br>그래서 taints와 tolerations 관련 설정들을 해주는 부분
- --set master.runAsUser / runAsGroup : 젠킨스를 구동하는 파드가 실행될 때의 유저 ID와 그룹 ID 설정
- --set master.tag : 이후 젠킨스 버전에 따른 UI 변경을 막기 위해서 젠킨스 버전 고정
- --set master.serviceType : 차트로 생성되는 서비스의 타입을 로드밸런서로 설정해 외부 IP를 받아옴
- --set master.servicePort : 젠킨스가 http 상에서 구동되도록 80포트 지정
- --set master.jenkinsOpts : 앞서 선언한 변수들을 호출해서 젠킨스에 적용
- --set master.javaOpts : 앞서 선언한 변수들을 호출해서 젠킨스 실행 환경(JVM)에 적용

<br>
<br>

## 젠킨스 살펴보기

- 젠킨스 컨트롤러는 마스터에 설치했지만 젠킨스 에이전트는 필요 시에 생성되고 제거되는 임시적 구조를 가짐
  - 따라서 젠킨스 에이전트 작업 내용들은 삭제 전에 젠킨스 컨트롤러에 저장되어야 함
  - 이를 위해 젠킨스 에이전트 서비스가 항상 동작하고 있음
- 젠킨스 컨트롤러 단독 설치 시 설치된 서버에서 젠킨스 자체 시스템 관리, CI/CD 설정, 빌드 등의 작업을<br>모두 젠킨스 컨트롤러 단일 노드에서 수행
- 컨트롤러-에이전트 구조로 설치 시 컨트롤러는 젠킨스 자체의 관리 및 CI/CD와 관련된 설정만 담당<br>실제 빌드 작업은 에이전트로 설정된 노드에서 이루어짐
- 따라서 컨트롤러 단독 설치는 일반적으로 간단한 테스트에서만 사용되고<br>주로 컨트롤러-에이전트 구조로 사용함

※ 젠킨스 메뉴에 대해

- Item : 젠킨스를 통해서 빌드할 작업을 뜻함
- 사람 : 사용자를 관리하는 메뉴<br>젠킨스 구동 서버에서 직접 사용자를 관리하는 방법과 별도의 DB를 가지고 관리하는 방법이 있음
- 빌드 기록 : 젠킨스 작업에 대한 성공, 실패, 진행 내역을 볼 수 있음
- Jenkins 관리 : 젠킨스의 시스템, 보안, 도구, 플러그인 등 각종 설정을 수행하는 곳
- My Views : 젠킨스에서 각종 작업을 분류해 모아서 볼 수 있는 대시보드
- Lockable Resources : 젠킨스에서는 한 번에 여러 작업이 일어날 수 있으므로 동시성 문제가 발생할 수 있음<br>그러므로 작업이 끝날 때까지 같은 작업을 하지 못하도록 하는 잠금 장치
- New View : 대시보드인 View를 생성하는 작업
