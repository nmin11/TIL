## 1. infancy programming language

- 내부 회로에 가산기, 감산기 등 원하는 스위치를 켜도록 하는 **Operation Code**를 사용했음
  - 줄여서 OP 코드, 우리말로 명령 코드
- 천공카드에 구멍을 뚫는 방식으로 기계어를 작성해서 컴퓨터에 명령을 내렸음

## 2. assembly language

- 기계어와 1:1로 대응되는 언어
- 인간이 쉽게 읽고 쓸 수 있는 문자로 표헌됨
- 인간이 어셈블리어를 사용하면 어셈블리어가 기계어로 변환해주는 방식
- 1:1 매칭이기 때문에 매우 빠르고, 기계어보다는 상대적으로 이해하기 쉬웠음
- 칩셋마다 명령을 새로 익혀야 하는 불편함 존재
- 여전히 기계 장치에 직접 코딩하는 임베디드 프로그래밍에서 많이 사용됨

## 3. high-level programming language

- 인간의 언어 표현법에 더 가까워졌음
- 현재 대부분의 프로그래밍 언어가 이에 해당
- 높은 생산성, 높은 가독성, 유연한 이식성 제공
- 인간 친화적 코드, 다양한 고급 기능 활용, 전체 흐름 이해 용이, 코드 양 대폭 감소

### execute high-level code

- 어떤 언어이든 컴퓨터가 명령을 실행하려면 결국 기계어 변환 과정은 필수
- 고수준 언어는 기계어 변환을 해주는 **컴파일러**가 반드시 필요
- 고수준 언어들은 저마다의 고유한 컴파일러를 가짐
  - Go 언어에도 Go 컴파일러가 있음

## 4. categories

### statically compiled language vs dynamically compiled language

- 컴파일을 언제 수행할 것인가가 기준

**정적 컴파일 언어**

- 미리 기계어로 변환해두었다가 사용하는 방식
- 윈도우의 `.exe` 파일과 같은 실행 파일
- 실행 파일이란 곧 기계어 코드라고 볼 수 있음
- 실행 시에 빠르고, 타입 에러를 컴파일 시점에서 발견할 수 있어서 타입 안정성이 뛰어남

**동적 컴파일 언어**

- 런타임에 기계어로 변환하는 방식
- 실행할 때 느리게 동작
- 정적 컴파일 언어보다 나중에 개발되었음 (정적 컴파일 언어의 아래 문제점들을 해결하기 위해)
  - 칩셋과 운영체제마다 0과 1로 된 binary 코드를 표현하는 방식이 다름
  - 실행 환경이 CPU 아키텍처와 운영체제에 따라 달라짐
- 동적 컴파일 언어는 위와 같은 문제들 없이 하나의 코드로 모든 플랫폼에서 실행됨
- 속도를 희생한 대신 범용성을!

⇒ Go 언어는 **정적 컴파일 언어**이므로 각 플랫폼에 맞는 실행 파일을 따로 만들어줘야 하지만 그 과정은 비교적 쉬움

### strongly typed language vs weakly typed language

- 타입 검사를 강하게 하는가 약하게 하는가의 기준
- 강 타입 언어는 정적 타입 언어라고도 불림
- 약 타입 언어는 동적 타입 언어라고도 불림
- 서로 다른 타입 간 연산에 관대한가
- 강 타입 언어는 사용하기 까다롭지만 타입 문제를 미연에 방지할 수 있음
- 약 타입 언어는 코딩이 편하지만 예상치 못한 버그를 발생시킬 수 있음

⇒ Go 언어는 자동 타입 변환조차 지원하지 않는 최강 타입 언어

### garbage collector

- GC 유무로 프로그래밍 언어를 구분할 수 있음
- GC는 메모리에서 불필요한 영역을 치워주는 역할 수행
- GC가 없는 언어는 프로그래머가 메모리 할당과 해제를 책임져야 함
  - 메모리 누수 현상 발생 가능
  - 이미 해제한 메모리를 다시 해제해서 버그가 생길 수 있음
- GC가 있는 언어는 메모리 청소에 CPU를 사용한다는 문제가 있음
  - GC가 없는 언어가 대체로 성능이 더 빠름

⇒ Go 언어는 매우 발전된 형태의 GC를 제공하기 때문에 CPU 성능 손실이 크지 않음
