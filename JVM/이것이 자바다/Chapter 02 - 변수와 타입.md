# 변수

## 변수의 선언

변수의 이름은 Java 언어에서 정한 naming convention을 따라야 한다.

- 첫 글자는 문자이거나 `$`, `_` 이어야 하고, 숫자로 시작할 수 없음
- 영어 대소문자가 구분됨
- 문자 길이 제한 없음
- Java 예약어(타입, 접근 지정자, 제어문 등) 사용 불가
- 첫 글자는 영어 소문자로 시작하고, 다른 단어가 붙을 경우 해당 단어의 첫 글자를 대문자로 함 (관례)

<br>
<br>

## 변수의 사용

변수의 초기값은 코드에서 직접 입력하는 경우가 많은데, 소스 코드 내에서 직접 입력된 값을 **literal** 이라고 부른다.  
리터럴은 값의 종류에 따라 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴로 구분된다.  
이 리터럴들은 정해진 표기법대로 작성되어야 한다.

<br>

### 정수 리터럴

- 소수점이 없는 정수 리터럴은 10진수로 간주

```java
0, 75, -100
```

- 0으로 시작되는 리터럴은 8진수로 간주

```java
02, -04
```

- 0x 또는 0X로 시작하며, A~F 또는 a~f로 구성된 리터럴은 16진수로 간주

```java
0x5, 0xA, 0xB3, 0xAC08
```

※ 정수 리터럴을 저장할 수 있는 타입은 **byte, char, short, int, long** 이렇게 5개이다.

<br>

### 실수 리터럴

- 소수점이 있는 리터럴은 10진수 실수로 간주

```java
0.25, -3.14
```

- E 또는 e가 있는 리터럴은 10진수 지수와 가수로 간주

```java
5E7     //5 * 10⁷
0.12E-5 //0.12 * 10­⁻⁵
```

※ 실수 리터럴을 저장할 수 있는 타입은 **float, double** 이다.

<br>

### 문자 리터럴

- `''` 로 묶은 텍스트는 하나의 문자 리터럴로 간주

```java
'A', '한', '\t', '\n'
```

- `\` 가 붙은 문자 리터럴은 escape 문자라고도 하며 특수한 용도로 사용됨

| escape 문자 |            용도            |    유니코드     |
| :---------: | :------------------------: | :-------------: |
|    '\t'     |          수평 탭           |     0x0009      |
|    '\n'     |          줄 바꿈           |     0x000a      |
|    '\r'     |            리턴            |     0x000d      |
|    '\"'     |            `"`             |     0x0022      |
|    '\''     |            `'`             |     0x0027      |
|    '\\'     |            `\`             |     0x005c      |
| '\u16진수'  | 16진수에 해당하는 유니코드 | 0x0000 ~ 0xffff |

※ 문자 리터럴을 저장할 수 있는 타입은 **char** 뿐이다.

<br>

### 문자열 리터럴

- `""` 로 묶은 텍스트는 문자열로 간주
- 안에 텍스트가 없을 경우에도 문자열로 간주
- 문자열 리터럴 내부에서도 escape 문자 사용 가능

```java
"로코"
"탭 만큼 이동 \t 합니다."
"한줄 내려쓰기 \n 합니다."
```

※ 문자열 리터럴을 저장할 수 있는 타입은 **String** 뿐이다.

<br>

### 논리 리터럴

```java
true, false
```

※ 문자열 리터럴을 저장할 수 있는 타입은 **boolean** 뿐이다.

<br>
<br>

# 데이터 타입

## 원시(primitive) 타입

- 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입
- 정수의 경우, 메모리 사용 크기가 n bit라고 할 때, `-2ⁿ⁻¹ ~ 2ⁿ⁻¹-1` 의 값을 저장할 수 있음
  - 양수에 `-1` 이 붙는 이유는 0이 포함되기 때문

| 값의 종류 | 기본 타입 | 메모리 사용 크기 | 저장되는 값의 범위                              |
| :-------: | :-------: | :--------------: | :---------------------------------------------- |
|   정수    |   byte    |   1byte (8bit)   | -2⁷ ~ 2⁷-1 (-128 ~ 127)                         |
|   정수    |   char    |  2byte (16bit)   | 0 ~ 2¹⁶-1 (유니코드 \u0000 ~ \uFFFF, 0 ~ 65535) |
|   정수    |   short   |  2byte (16bit)   | -2¹⁵ ~ 2¹⁵-1 (-32,768 ~ 32,767)                 |
|   정수    |    int    |  4byte (32bit)   | -2³¹ ~ 2³¹-1 (-2,147,483,648 ~ 2,147,483,647)   |
|   정수    |   long    |  8byte (64bit)   | -2⁶³ ~ 2⁶³-1                                    |
|   실수    |   float   |  4byte (32bit)   | (+/-)1.4E-45 ~ (+/-)3.4028235E38                |
|   실수    |  double   |  8byte (64bit)   | (+/-)4.9E-324 ~ (+/-)1.7976931348623157E308     |
|   논리    |  boolean  |   1byte (8bit)   | true, false                                     |

<br>
<br>

## 정수 타입

### byte 타입

- 색상 정보 및 파일 또는 이미지 등의 이진 데이터를 처리할 때 주로 사용됨
- -128 ~ 127 범위를 초과하는 값을 저장하려고 하면 `Type mismatch: cannot convert from int to byte` 발생
- 이미 범위 안의 값을 저장해두었는데, 해당 변수의 값이 변경되어 범위를 초과할 경우, 127을 넘어선 값이 -128부터 다시 시작하게 됨
  - 이러한 값을 쓰레기값이라고 함
  - 이러한 방식은 short, int, long에도 동일하게 적용됨

<br>

### char 타입

- Java는 모든 문자를 **Unicode** 로 처리
  - 유니코드는 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약
  - 하나의 문자에 대해 하나의 코드값 부여
  - 0 ~ 65535 범위의 2byte 크기를 가진 정수값
  - 0 ~ 127 : ASCII 문자 (특수기호 및 영어 알파벳) 할당
  - 44032 ~ 55203 : 한글 11172자 할당
  - 자세한 정보는 http://www.unicode.org 참고
- `''` 로 감싼 문자가 아닌, 유니코드 정수값을 직접 저장할 수도 있음

```java
char c = 65;
char c = '\u0041'
```

- 반대로 char 변수에 저장된 유니코드의 정수값을 알고 싶다면 char 타입 변수를 int 타입에 저장하면 됨

```java
char c = 'A';
int uniCode = c;
```

- 단순히 초기화 목적으로 `''` 안이 비어있는 빈 문자를 대입하면 컴파일 에러 발생
  - 공백(유니코드 32)을 하나 포함해서 초기화해야 함

```java
char c = '' //컴파일 에러 발생
char c = ' '
```

<br>

### short 타입

- C 언어와의 호환을 위해 사용됨
- Java에서는 잘 사용되지 않는 타입

<br>

### int 타입

- Java에서 정수 연산을 하기 위한 기본 타입
  - 만약 byte 또는 short 타입의 변수를 + 연산하면 int 타입으로 변환됨
- 8진수를 저장할 경우 앞에 `0`을 붙이고, 16진수를 저장할 경우 앞에 `0x`를 붙임

```java
int number = 10;
int octNumber = 012;
int hexNumber = 0xA;
```

<br>

### long 타입

- 범위 : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2⁶³ ~ 2⁶³-1)
- 수치가 큰 데이터를 다루는 프로그램에서 필수적으로 사용됨
  - ex) 은행 및 우주와 관련됨 프로그램들
- 변수를 초기화할 때 정수값 뒤에 `l`이나 `L`을 붙여줘야 함
  - 8byte 정수임을 컴파일러에게 알려주기 위한 목적
  - 일반적으로 소문자 `l`은 숫자 `1`과 혼동되기 쉽기 때문에 대문자 `L`을 주로 사용

<br>
<br>

## 실수 타입

- float과 double의 메모리 사용 크기는 4byte, 8byte로, 각각 int, long의 메모리 사용 크기와 같지만, 다른 저장 방식을 사용하기 때문에 훨씬 더 큰 범위 저장 가능
  - **부동 소수점(floating-point)** 방식으로 저장
- float은 실수값 뒤에 `f`나 `F`를 붙여줘야 함

```java
+ m X 10ⁿ

+ : 부호
m : 가수 (mantissa)
n : 지수 (exponent)
```

- 가수 m은 `0 <= m < 1` 범위의 실수
  - ex) 실수 1.2345를 부동 소수점으로 표시하면 `0.12345 * 10¹` 이 되고, 지수는 1
- float과 double은 가수와 지수를 저장하기 위해 전체 bit를 나누어 사용
  - float : 부호(1bit) + 지수(8bit) + 가수(23bit) = 32bit = 4byte
  - double : 부호(1bit) + 지수(11bit) + 가수(52bit) = 64bit = 8byte
  - double은 float에 비해 가수를 표현하는 데에 있어서 2배가 넘는 자릿수가 배정되어 있기 때문에 더욱 정밀한 값을 얻을 수 있음
- 만약 정수 리터럴에 10의 지수를 나타내는 `E` 혹은 `e`가 있다면 정수 타입에 저장할 수 없으며, 실수 타입에 저장해야만 함

<br>
<br>

## 논리 타입

- 2가지 상태값을 저장할 필요성이 있을 경우에 사용됨
  - 상태값에 따라 조건문과 제어문의 흐름을 변경하는 데에 주로 사용됨

<br>
<br>

## 타입 변환

### 자동 타입 변환 (Promotion)

- byte 크기가 작은 타입의 값이, byte 크기가 보다 큰 타입의 변수에 저장될 때 발생
- `byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)`
  - float이 long 보다 큰 이유는 표현할 수 있는 값의 범위가 더 크기 때문
  - 실수 타입 변수에 저장하는 정수 타입 값은 무조건 자동 변환
    - `.0`이 붙은 실수값이 됨
- 변환 이전의 값과 변환 이후의 값은 동일

```java
byte byteValue = 10;
int intValue = byteValue;
double doubleValue = intValue;  //10.0
```

- char 타입이 int 타입으로 자동 변환될 경우, 유니코드 값이 int 타입에 저장됨

```java
char charValue = 'A';
int intValue = charValue; //65
```

- 예외적으로, char 타입에는 음수가 저장될 수 없으므로 byte 타입은 보다 큰 타입인 char 타입으로 자동 변환 불가능

```java
byte byteValue = 65;
char charValue = byteValue;       //컴파일 에러 발생
char charData = (char) byteValue; //강제 타입 변환은 가능
```

<br>

### 강제 타입 변환 (Casting)

- 큰 크기의 타입을 작은 크기의 타입으로 쪼개어 저장하는 방법
- 타입 뿐 아니라 실제 저장해야 하는 값도 타입의 범위를 넘어설 경우, 저장할 수 있는 byte 단위만 저장하게 됨

```java
int intValue = 103029770;
byte byteValue = (byte) intValue;
```

103029770을 int 타입의 4byte로 나누면 다음과 같다.

`| 00000110 | 00100100 | 00011100 | 00001010 |`

byte 타입은 1byte만 저장할 수 있기 때문에 앞에 3byte는 모두 0으로 채워지고 나머지 맨 끝의 `00001010`, 10진법으로는 10인 숫자가 byte 타입에 저장된다.

- 반면에 큰 타입의 값을 작은 타입의 변수에서도 충분히 표현할 수 있다면 온전한 값이 그대로 저장됨
- 실수 타입을 정수 타입으로 강제 타입 변환할 경우, 소수점 이하 부분은 버려지고 정수 부분만 저장됨
- 정수를 char 타입으로 강제 변환하면 해당 유니코드에 맞는 문자가 저장됨

```java
int intValue = 44032;
char charValue = (char) intValue; //'가'
```

- Java에서 제공하는 기본 타입에 대한 최대값 및 최소값 상수를 값의 손실을 피하는 데에 활용할 수도 있음

| 기본 타입 | 최대값 상수       | 최소값 상수       |
| :-------: | :---------------- | :---------------- |
|   byte    | Byte.MAX_VALUE    | Byte.MIN_VALUE    |
|   short   | Short.MAX_VALUE   | Short.MIN_VALUE   |
|    int    | Integer.MAX_VALUE | Integer.MIN_VALUE |
|   long    | Long.MAX_VALUE    | Long.MIN_VALUE    |
|   float   | Float.MAX_VALUE   | Float.MIN_VALUE   |
|  double   | Double.MAX_VALUE  | Double.MIN_VALUE  |

- **정수 타입에서 실수 타입으로 변환할 때 정밀도 손실을 고려해야 함**

```java
public class FromIntToFloat {
  public static void main(String[] args) {

    int num1 = 123456780;
    int num2 = 123456780;

    float num3 = num2;  //float으로 자동 타입 변환
    num2 = (int) num3;  //그 값을 그대로 다시 int로 강제 타입 변환

    int result = num1 - num2;
    System.out.println(result);

  }
}
```

타입만 2번 변환했지, 추가적인 연산은 없었기 때문에 두 값을 빼면 0이 되는 것이 맞다.  
하지만 콘솔 창을 확인하면 `-4` 라는 값이 나온다.  
그 이유는 다음과 같다.  
우선 float 타입의 bit 수 할당은 `부호 1bit + 지수 8bit + 가수 23bit`이다.  
하지만 **123456780** 은 23bit로 표현할 수 없기 때문에 근사치로 변환된다.  
즉 정밀도 손실이 발생한다.  
그렇기 때문에 이 float 값을 다시 int 타입으로 변환하면 원래의 int 값을 얻지 못하게 되는 것이다.

<br>

이 문제는, double 타입을 사용하면 해결 가능하다.  
double 타입의 bit 수 할당은 `부호 1bit + 지수 11bit + 가수 52bit`이다.  
그리고 int 타입은 **32bit** 이다.  
따라서 어떠한 int 값이라도 정밀도 손실 없이 double 타입으로 변환될 수 있다.

<br>

### 연산식에서의 자동 타입 변환

- 연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행됨
- 서로 다른 타입의 피연산자가 있다면 두 피연산자 중 큰 타입으로 자동 변환된 후 연산 수행

```java
int intValue = 10;
double doubleValue = 5.5;
double result = intValue + doubleValue; //double 자동 타입 변환
```

- 만약 int 타입으로 꼭 연산을 해야 한다면 강제 타입 변환을 해야 함

```java
int intValue = 10;
double doubleValue = 5.5;
int result = intValue + (int) doubleValue;  //15
```

- 정수 연산은 int 타입을 기본으로 함
  - byte, char, short 타입에서의 연산은 int 타입으로 자동 변환
  - 만약 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 타입으로 자동 타입 변환되고 연산 결과도 long 타입이 됨
  - char 타입에서 연산할 경우에도 int 타입으로 변환되니, 이 결과를 다시 문자로 저장하기 위해서는 강제 타입 변환 필요

```java
char ai = 'A';
int result = ai + 1;
char na = (char) result;  //'B'
```

- 실수 연산은 double 타입을 기본으로 함
  - float 타입끼리의 연산 결과는 float 타입
  - 피연산자 중 실수 리터럴이나 double 타입이 있다면 연산 결과는 double 타입
