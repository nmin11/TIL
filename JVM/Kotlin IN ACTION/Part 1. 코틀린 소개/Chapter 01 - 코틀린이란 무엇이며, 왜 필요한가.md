## 1. 코틀린 맛보기

```java
data class Persion(
  val name: String,
  val age: Int? = null    // null이 될 수 있는 ? 타입
)

fun main(args: Array<String>) {
  val persons = listOf(
    Person("Min"),
    Person("Loko", age=20)  // 이름 붙인 파라미터
  )
  val oldest = persons.maxBy { it.age ?: 0 }  // 람다식과 엘비스 연산자
  println("oldest one : $oldest")     // 문자열 템플릿
}
```

※ Output

```java
oldest one : Person(name=Loko, age=20)      //toString 자동 생성
```

<br>
<br>

## 2. 코틀린의 주요 특성

### 2.1 대상 플랫폼 = Java가 실행되는 모든 곳

- 코틀린의 주목적 : 현재 Java가 사용되고 있는 모든 용도에 적합하면서도<br>더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
- 가장 일반적인 코틀린의 영역
  - 서버상의 코드(backend)
  - 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 이외 다른 환경에서도 잘 작동함
  - Intel Multi-OS Engine을 사용하면 iOS 디바이스에서 실행 가능
  - TornadoFX, JavaFX 등을 함께 사용해서 데스크탑 애플리케이션 작성 가능
  - JavaScript로도 코틀린을 컴파일할 수 있으므로 브라우저나 노드에서 실행 가능

<br>

### 2.2 정적 타입 지정 언어

- Java와 마찬가지로 코틀린도 정적 타입(statically typed) 지정 언어
- 정적 타입 지정 : 모든 프로그램 구성 요소의 타입을 컴파일 시점에서 알 수 있고<br>프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해주는 것

※ 참고 - 동적 타입(dynamically typed) 지정 언어

- JVM에서는 Groovy와 JRuby가 대표적인 동적 타입 지정 언어
- 타입과 관계 없이 모든 값을 변수에 넣을 수 있고,<br>메소드나 필드 접근에 대한 검증이 실행 시점에 일어나며,<br>그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있음

<br>

코틀린의 **타입 추론**(type inference)

- 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없음
- 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추
- `var x = 1`
  - 코틀린은 이 변수의 타입이 `Int`임을 자동으로 알아냄

<br>

정적 타입 지정의 장점

- **성능**
  - 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 빠름
- **신뢰성**
  - 컴파일러가 프로그램의 정확성을 검증하기에 실행 시 오류로 중단될 가능성이 적어짐
- **유지 보수성**
  - 객체가 어떤 타입에 속하는지 알 수 있기에 처음 보는 코드를 다룰 때도 쉬움
- **도구 지원**
  - 더 안전하게 리팩토링 가능
  - 더 정확한 코드 완성 기능 제공
  - IDE의 다른 지원 기능도 더 잘 만들어짐

<br>

코틀린의 타입 시스템

- class, interface, generics는 Java와 비슷하게 작동
- 새로운 것들 중 가장 중요한 특성은 **nullable type**
  - NullPointerException이 발생할 수 있는지 여부를 검사할 수 있으므로 프로그램의 신뢰성을 높여줌
- 다른 새로운 내용은 **function type**

<br>

### 2.3 함수형 프로그래밍과 객체지향 프로그래밍

핵심 개념

- **first-class 함수**
  - 함수를 일반 값처럼 다룰 수 있음
  - 함수를 변수에 저장하거나, 인자로 다른 함수에 전달하거나,<br>함수에서 새로운 함수를 만들어서 반환할 수 있음
- **immutability**
  - 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해서 프로그래밍
- **side effect 없음**
  - 입력이 같으면 항상 같은 출력
  - 다른 객체의 상태를 변경하지 않음
  - 외부와 상호작용하지 않는 pure function 사용

<br>

장점

- 간결성
  - 명령형(imperative) 코드에 비해 더 간결하며 우아함
  - 함수를 값처럼 사용해서 더 강력한 추상화가 가능하고, 이를 통해 코드 중복을 막을 수 있음

```java
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```

- safe multithreading
  - 다중 스레드 프로그램에서는 적절한 동기화 없이 동일 데이터를<br>여러 스레드가 변경하는 경우에 가장 많은 문제가 발생함
  - 불변 데이터 구조에 순수 함수를 적용하면 동일 데이터를 여러 스레드가 변경할 수 없음
- 테스트하기 쉬움
  - side effect가 있는 함수는 실행 시 필요한 전체 환경을 구성하는 setup code가 필요하지만<br>순수 함수는 독립적으로 테스트 가능

<br>

함수형 프로그래밍 지원 언어

- 일반적으로는 언어와 관계없이 함수형 스타일을 활용할 수 있음
- 하지만 모든 언어가 함수형 프로그래밍을 편하게 사용하기에<br>충분한 라이브러리와 문법 지원을 제공하지는 않음

<br>

코틀린의 함수형 프로그래밍 지원

- 함수 타입 지원
  - 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수 반환 가능
- 람다 식 지원
  - 번거로운 준비 코드 없이 코드 블록을 쉽게 정의하고 전달할 수 있음
- data class
  - 불변적인 값 객체를 간편하게 만들 수 있는 구문 제공
- 표준 라이브러리
  - 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API 제공

<br>

### 2.4 무료 오픈소스

- 언어, 컴파일러, 라이브러리 및 코틀린과 관련된 모든 도구는 모두 오픈소스
- Apache 2 라이선스하에 제공됨
- GitHub을 통해 개발되고 있음 (https://github.com/jetbrains/kotlin)

<br>
<br>

## 3. 코틀린 응용

### 3.1 코틀린 서버 프로그래밍

- Java 코드와 매끄럽게 상호운용할 수 있으므로 기존 시스템과의 통합에 용이함
- 몇 가지 새로운 기술을 활용해서 서버 시스템 개발 가능
  - Builder pattern을 활용해서 객체로 이뤄진 grpah를 쉽게 구축할 수 있음
- 깔끔하고 간결한 DSL 기능 제공
  - [Exposed 프레임워크](https://github.com/jetbrains/exposed) 를 사용하면 SQL DB 구조를 기술할 수 있는 읽기 쉬운 DSL 제공

<br>

### 3.2 코틀린 안드로이드 프로그래밍

- 특별한 컴파일러 플러그인 지원을 통해 개발 생산성을 높이고 개발의 즐거움을 더함
  - 컨트롤러에 리스너를 추가하거나 레이아웃 요소를 필드와 바인딩하는 등의<br>흔한 안드로이드 개발 작업을 훨씬 더 적은 코드로 달성 가능
- [Anko 라이브러리](https://github.com/kotlin/anko) 를 사용하면 수많은 안드로이드 API에 대한 코틀린 어댑터를 제공받을 수 있음
- 애플리케이션의 신뢰성을 더 높일 수 있음
  - 타입을 정확히 추적하여 NullPointerException 유형의 코드는 컴파일도 되지 않게 함
- 람다 함수를 inlining하기 때문에 람다를 사용해도 새로운 객체가 만들어지지 않음

<br>
<br>

## 4. 코틀린의 철학

### 4.1 실용성

- 연구를 위한 언어가 아니기 때문에 이미 성공적으로 검증된 해법과 기능에 의존
- 특정 프로그래밍 스타일이나 패러다임을 사용할 것을 강제로 요구하지 않음
- IntelliJ라는 좋은 도구를 강조함

<br>

### 4.2 간결성

- 개발자는 새로운 코드 작성보다 기존 코드를 읽을 때가 많다는 점에 주목함
- 의미 없는 코드 혹은 별 뜻이 없지만 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 노력해 왔음
  - getter, setter, constructor와 같은 번거로운 준비 코드를 묵시적으로 제공

<br>

### 4.3 안정성

- 안전하다 : 일부 유형의 에러를 프로그램 설계가 원천적으로 방지해준다는 뜻
- 이를 위해 컴파일러에게 많은 정보를 제공하다 보면 생산성이 떨어지므로,<br>안정성과 생산성은 **trade off** 관계가 성립함
- 앞서 살펴봤던 nullable type이 NullPointerException을 방지해주는 점 외에도<br>타입 검사와 캐스트를 한 연산자에서 이뤄지게 하여 **ClassCastException** 을 방지해줌
  - 어떤 객체의 타입을 검사했고, 객체의 타입을 알게 되었다면 별도의 캐스트 없이 사용 가능

```java
if (value is String)
  println(value.toUpperCase())
```

<br>

### 4.4 상호운용성

- Java 기존 라이브러리 사용 가능
  - Java 표준 라이브러리에 의존하며, 코틀린 자체 컬렉션 라이브러리는 제공하지 않음
  - 다만 컬렉션을 더 쉽게 활용할 수 있도록 몇 가지 기능을 더함
- Java 메소드 호출, 클래스 상속, 인터페이스 구현, 어노테이션 적용 등 모두 가능
- 자바와 코틀린 코드를 원하는 대로 섞어 쓸 수 있는 유연성

<br>
<br>

## 5. 코틀린 도구 사용

### 5.1 코틀린 코드 컴파일

- 소스코드 저장 시 보통 `.kt` 확장자 사용
- Java와 마찬가지로 컴파일 시 `.class` 파일을 만들어냄
- 만들어진 `.class` 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행
- 가장 간단한 방식은 커맨드라인에서 `kotlinc` 명령을 통해 컴파일하고 `java` 명령으로 실행

```bash
kotlinc <source file or directory> -include-runtime -d <jar name>
java -jar <jar name>
```

- 코틀린 컴파일러로 컴파일한 코드는 **kotlin runtime library**에 의존함
  - 이 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와<br>코틀린에서 Java API의 기능을 확장한 내용이 들어있음
- Maven, Gradle, Ant 등의 빌드 시스템과 호환됨

<br>

### 5.2 IntelliJ IDEA와 Android Studio의 코틀린 플러그인

- IntelliJ IDEA의 코틀린 플러그인은 코틀린 언어와 함께 개발되어 왔음
- 코틀린 개발에 필요한 모든 도구 제공되며, 기본적으로 설치되어 있음
- 제대로 작동한다면 New Project 메뉴 선택시 Kotlin을 볼 수 있음
- Android Studio의 경우, 플러그인 관리자를 통해 설치할 것

<br>

### 5.3 대화형 셀

- 코틀린 코드를 빨리 시험해보고 싶다면 REPL(read-eval-print-loop) 사용
- REPL을 시작하려면 `kotlinc` 명령을 아무 인자 없이 실행하거나<br>Tool > Kotlin > Kotlin REPL 사용

<br>

### 5.4 이클립스 플러그인

- 쓸 일은 없을 것 같으니 그냥 쓸 수 있다는 정도로만... 😅

<br>

### 5.5 온라인 놀이터

- 프로그램 설치 및 설정을 할 필요 없이 코틀린을 써볼 수 있는 아주 쉬운 방법
- http://try.kotl.in 에는 웹상에서 코틀린 코드를 갖고 놀 수 있는 온라인 놀이터가 있음
- 코틀린의 특성을 보여주는 예제들이 있고, 이 책의 모든 예제도 들어있음
- 대화식으로 공부하는 연습문제인 Kotlin Koans도 있음 (Play > Koans)

<br>

### 5.6 자바-코틀린 변환기

- 자바 파일에서 작성한 자바 코드를 그대로 복사해서 코틀린 파일에 붙여 넣으면<br>자동으로 같은 뜻의 코틀린 코드를 제안함
  - 변환기는 항상 가장 코틀린다운 코드를 제안해 주지는 못하지만 잘 작동하는 코드를 알려줌
- 자바 파일 하나를 통째로 코틀린으로 변환하고 싶다면<br>Code > Convert Java File to Kotlin File 선택

<br>
<br>

## 6. 요약

- 타입 추론을 지원하는 정적 타입 지정 언어
- 객체지향과 함수형 프로그래밍 모두 지원
- 서버 애플리케이션 개발에 유용
- 안드로이드에도 활용 가능
- 무료이고 오픈소스이며, 주요 IDE와 빌드 시스템 완전 지원
- 실용적이며 안전하고, 간결하며 상호운용성이 좋음
