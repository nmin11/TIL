## 1. 코틀린 맛보기

```java
data class Persion(
  val name: String,
  val age: Int? = null    // null이 될 수 있는 ? 타입
)

fun main(args: Array<String>) {
  val persons = listOf(
    Person("Min"),
    Person("Loko", age=20)  // 이름 붙인 파라미터
  )
  val oldest = persons.maxBy { it.age ?: 0 }  // 람다식과 엘비스 연산자
  println("oldest one : $oldest")     // 문자열 템플릿
}
```

※ Output

```java
oldest one : Person(name=Loko, age=20)      //toString 자동 생성
```

<br>
<br>

## 2. 코틀린의 주요 특성

### 2.1 대상 플랫폼 = Java가 실행되는 모든 곳

- 코틀린의 주목적 : 현재 Java가 사용되고 있는 모든 용도에 적합하면서도<br>더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
- 가장 일반적인 코틀린의 영역
  - 서버상의 코드(backend)
  - 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 이외 다른 환경에서도 잘 작동함
  - Intel Multi-OS Engine을 사용하면 iOS 디바이스에서 실행 가능
  - TornadoFX, JavaFX 등을 함께 사용해서 데스크탑 애플리케이션 작성 가능
  - JavaScript로도 코틀린을 컴파일할 수 있으므로 브라우저나 노드에서 실행 가능

<br>

### 2.2 정적 타입 지정 언어

- Java와 마찬가지로 코틀린도 정적 타입(statically typed) 지정 언어
- 정적 타입 지정 : 모든 프로그램 구성 요소의 타입을 컴파일 시점에서 알 수 있고<br>프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해주는 것

※ 참고 - 동적 타입(dynamically typed) 지정 언어

- JVM에서는 Groovy와 JRuby가 대표적인 동적 타입 지정 언어
- 타입과 관계 없이 모든 값을 변수에 넣을 수 있고,<br>메소드나 필드 접근에 대한 검증이 실행 시점에 일어나며,<br>그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있음

<br>

코틀린의 **타입 추론**(type inference)

- 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없음
- 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추
- `var x = 1`
  - 코틀린은 이 변수의 타입이 `Int`임을 자동으로 알아냄

<br>

정적 타입 지정의 장점

- **성능**
  - 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 빠름
- **신뢰성**
  - 컴파일러가 프로그램의 정확성을 검증하기에 실행 시 오류로 중단될 가능성이 적어짐
- **유지 보수성**
  - 객체가 어떤 타입에 속하는지 알 수 있기에 처음 보는 코드를 다룰 때도 쉬움
- **도구 지원**
  - 더 안전하게 리팩토링 가능
  - 더 정확한 코드 완성 기능 제공
  - IDE의 다른 지원 기능도 더 잘 만들어짐

<br>

코틀린의 타입 시스템

- class, interface, generics는 Java와 비슷하게 작동
- 새로운 것들 중 가장 중요한 특성은 **nullable type**
  - null pointer exception이 발생할 수 있는지 여부를 검사할 수 있으므로 프로그램의 신뢰성을 높여줌
- 다른 새로운 내용은 **function type**

<br>

### 2.3 함수형 프로그래밍과 객체지향 프로그래밍

핵심 개념

- **first-class 함수**
  - 함수를 일반 값처럼 다룰 수 있음
  - 함수를 변수에 저장하거나, 인자로 다른 함수에 전달하거나,<br>함수에서 새로운 함수를 만들어서 반환할 수 있음
- **immutability**
  - 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해서 프로그래밍
- **side effect 없음**
  - 입력이 같으면 항상 같은 출력
  - 다른 객체의 상태를 변경하지 않음
  - 외부와 상호작용하지 않는 pure function 사용

<br>

장점

- 간결성
  - 명령형(imperative) 코드에 비해 더 간결하며 우아함
  - 함수를 값처럼 사용해서 더 강력한 추상화가 가능하고, 이를 통해 코드 중복을 막을 수 있음

```java
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```

- safe multithreading
  - 다중 스레드 프로그램에서는 적절한 동기화 없이 동일 데이터를<br>여러 스레드가 변경하는 경우에 가장 많은 문제가 발생함
  - 불변 데이터 구조에 순수 함수를 적용하면 동일 데이터를 여러 스레드가 변경할 수 없음
- 테스트하기 쉬움
  - side effect가 있는 함수는 실행 시 필요한 전체 환경을 구성하는 setup code가 필요하지만<br>순수 함수는 독립적으로 테스트 가능

<br>

함수형 프로그래밍 지원 언어

- 일반적으로는 언어와 관계없이 함수형 스타일을 활용할 수 있음
- 하지만 모든 언어가 함수형 프로그래밍을 편하게 사용하기에<br>충분한 라이브러리와 문법 지원을 제공하지는 않음

<br>

코틀린의 함수형 프로그래밍 지원

- 함수 타입 지원
  - 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수 반환 가능
- 람다 식 지원
  - 번거로운 준비 코드 없이 코드 블록을 쉽게 정의하고 전달할 수 있음
- data class
  - 불변적인 값 객체를 간편하게 만들 수 있는 구문 제공
- 표준 라이브러리
  - 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API 제공

<br>

### 2.4 무료 오픈소스

- 언어, 컴파일러, 라이브러리 및 코틀린과 관련된 모든 도구는 모두 오픈소스
- Apache 2 라이선스하에 제공됨
- GitHub을 통해 개발되고 있음 (https://github.com/jetbrains/kotlin)

<br>
<br>

## 3. 코틀린 응용

### 3.1 코틀린 서버 프로그래밍

- Java 코드와 매끄럽게 상호운용할 수 있으므로 기존 시스템과의 통합에 용이함
- 몇 가지 새로운 기술을 활용해서 서버 시스템 개발 가능
  - Builder pattern을 활용해서 객체로 이뤄진 grpah를 쉽게 구축할 수 있음
- 깔끔하고 간결한 DSL 기능 제공
  - [Exposed 프레임워크](https://github.com/jetbrains/exposed) 를 사용하면 SQL DB 구조를 기술할 수 있는 읽기 쉬운 DSL 제공

<br>

### 3.2 코틀린 안드로이드 프로그래밍

- 특별한 컴파일러 플러그인 지원을 통해 개발 생산성을 높이고 개발의 즐거움을 더함
  - 컨트롤러에 리스너를 추가하거나 레이아웃 요소를 필드와 바인딩하는 등의<br>흔한 안드로이드 개발 작업을 훨씬 더 적은 코드로 달성 가능
- [Anko 라이브러리](https://github.com/kotlin/anko) 를 사용하면 수많은 안드로이드 API에 대한 코틀린 어댑터를 제공받을 수 있음
- 애플리케이션의 신뢰성을 더 높일 수 있음
  - 타입을 정확히 추적하여 NullPointerException 유형의 코드는 컴파일도 되지 않게 함
- 람다 함수를 inlining하기 때문에 람다를 사용해도 새로운 객체가 만들어지지 않음
