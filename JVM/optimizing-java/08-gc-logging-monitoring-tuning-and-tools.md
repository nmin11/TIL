## 1. GC 로깅 개요

- GC 로그는 'cold case'를 분석할 때 매우 유용
  - cold case: 원인을 알 수 없는 현상

주요 애플리케이션에 설정해야 하는 두 가지

- GC 로그 생성
- 특정 파일에 GC 로그 기록

### 1.1 GC 로깅 켜기

필수 GC 로깅 플래그

| 플래그 | 작용 |
| :--: | :-- |
| `-Xloggc:gc.log` | GC 이벤트를 로깅할 파일 지정 |
| `-XX:+PrintGCDetails` | GC 이벤트 세부 정보 로깅 |
| `-XX:+PrintTenuringDistribution` | 부가적인 GC 이벤트 세부 정보 추가 |
| `-XX:+PrintGCTimeStamps` | GC 이벤트 발생 시간 출력 (VM 시작 후 상대 시간) |
| `-XX:+PrintGCDateStamps` | GC 이벤트 발생 시간 출력 (절대 시간) |

필수 GC 로깅 플래그 사용 시 주의할 점

- `verbose:gc` 를 지우고 `PrintGCDetails` 사용
- `PrintTenuringDistribution` 플래그는 독특하고 어려움
  - memory pressure, 조기 승격 등의 이벤트 계산에 필요한 기초 데이터 제공
- `PrintGCTimeStamps` 와 `PrintGCDateStamps` 는 둘 다 필요함
  - `PrintGCTimeStamps` : GC와 다른 내부 JVM 이벤트를 연관짓는 용도
  - `PrintGCDateStamps` : GC 이벤트와 애플리케이션 이벤트를 연관짓는 용도

로깅과 JVM 성능

- 로깅은 JVM 성능에 이렇다 할 영향을 주지 않음

로그 순환 관련 플래그

| 플래그 | 작용 |
| :--: | :-- |
| `-XX:+UseGCLogFileRotation` | 로그 순환 기능 ON |
| `-XX:+NumberOfGCLogFiles=<n>` | 최대 로그 파일 개수 |
| `-XX:+GCLogFileSize=<size>` | 각 파일 최대 크기 |

### 1.2 GC 로그 vs JMX

*Java Management eXtensions*

JMX는 GC에 영향을 주기 때문에 아래 사항들을 숙지해야 함

| GC 로그 데이터 | JMX |
| --: | :-- |
| 실제 GC 이벤트가 발생해서 쌓임 | 데이터를 샘플링해서 얻음 |
| 캡처 영향도가 거의 없음 | 프록시 및 원격 메소드 호출(RMI) 과정에서 암묵적인 비용이 듦 |
| 자바 메모리 성능 데이터 50가지 이상 | 자바 메모리 성능 데이터 10가지 미만 |

JMX의 장점

- 성능 데이터 원천으로서 스트리밍된 데이터 즉시 제공
  - 그러나 요즘 jClarity 센섬 같은 툴도 GC 로그 데이터 스트리밍 API를 제공
- 기본적인 힙 사용 실태 파악 용도로 제격
  - 더 깊이 있는 진단을 하려면 금세 부족함을 느끼게 됨
- JMX로 가져온 MBean은 쉽게 액세스 가능
  - VisualVM 같은 도구로 쉽게 시각화할 수 있음
  - MBean(Managed Bean) : 관리되어야 할 리소스를 빈으로 나타낸 것

### 1.3 JMX의 단점

작동 방식

- 대부분 런타임을 샘플링해서 현재 상태를 업데이트 받는 방식
- 클라이언트는 데이터를 계속 넘겨받기 위해 런타임에 있는 JMX 빈을 폴링

GC에 대한 문제

- 수집기가 언제 실행될지 알 수 없음
- 수집 사이클 전후 메모리 상태 역시 알 수 없음
- 그러므로 GC 데이터를 깊고 정확하게 분석할 수 없음
- 장기적인 추이를 파악하는 정도

메모리압(할당률) 분석 불가능

- JMX의 데이터 수집 방식 때문에 아예 불가능

RMI(Remote Method Invocation)

- `JMXConnector` 명세를 구현하는 코드는 내부적으로 RMI에 의존적
- 그러므로 RMI 기반 통신 채널의 고질적인 문제점에 취약
  - 방화벽 포트를 열어야 하므로 secondary socket connection이 맺어질 수 있음
  - 프록시 객체를 이용해서 `remove()` 메소드 호출 대행
  - 자바 finalization에 대한 의존성

### 1.4 GC 로그 데이터의 장점

탄생 배경

- 자바 GC 개발자들이 GC 로깅을 JVM 구현체 디버깅 용도로 추가했음
- 이후 60개 정도의 GC 로깅 플래그로 생성된 데이터 상당수가 성능 디버깅 목적으로 쓰이게 되었음
- 점차 GC 로그가 런타임에서 발생한 문제를 파악하는 데 아주 유용한 도구로 자리매김
- 이제 GC 로그 수집 및 분석은 튜닝 활동에서 절대 빠질 수 없게 되었음

장점

- non-blocking 방식이므로 애플리케이션 성능에 미치는 영향의 거의 0에 가까움
- GC 이벤트와 연관 지을 수 있는 모든 의미 있는 분석 작업이 가능해짐
  - 어느 지점에서 수집 비용이 발생하는지
  - 어떻게 튜닝해야 긍정적인 결과를 얻을 수 있을지

## 2. 로그 파싱 툴

- GC 로그 메시지는 표준 포맷이 따로 없어서 파싱이 어려움
- GC 로그 플래그가 많아지면서 로그 메시지도 더 복잡해짐

**스스로 GC 로그를 파싱하려고 하지 말고 반드시 툴을 사용하자!**

### 2.1 센섬

- jClarity에서 제작한 상용 메모리 분석기
- 최고의 GC 로그 파싱, 정보 추출, 자동 분석 기능 제공을 목표로 함
- 센섬 SaaS 모니터링 서비스는 전체 클러스터 상태를 한눈에 볼 수 있어서 좋음
  - 한번에 한 JVM만 보면서 모니터링하는 것보다 엄청 편함
- 센섬 개발팀은 OpenJDK의 로깅 관련 소스 코드를 낱낱이 분석해서 변경된 로그파일 포맷을 철저히 반영
- 다양한 GC 로그 설정 지원
- 썬/오라클 자바 1.4.2부터 현재 버전까지 모든 수집기 지원

센섬이 지원하는 자동 분석 기능

- 정확한 할당률
- 조기 승격
- 공격적인 할당
- 유저 이탈
- 메모리 누수 감지
- 힙 크기 조정 및 용량 계획
- VM에 대한 OS 간섭
- 크기를 잘못 잡은 메모리 풀

### 2.2 GCViewer

- GC 로그 파싱 및 그래프 출력 등 기본 기능을 갖춘 데스크톱 툴
- 오픈소스이기 때문에 무료이지만 상용 툴에 비해 빈약함
- [소스](https://github.com/chewiebug/GCViewer)를 내려받아 컴파일/빌드 후 JAR 파일로 패키징하면 됨
- 분석 기능이 없으며, 특정 GC 핫스팟 로그 포맷만 파싱 가능

### 2.3 같은 데이터를 여러 가지 형태로 시각화하기

- 똑같은 데이터라도 센섬과 GCViewer의 시각화가 서로 다른 모습을 보임

## 3. GC 기본 튜닝

- GC 튜닝도 다른 튜닝 기법처럼 전체 진단 과정의 일부여야 함

실무 GC 튜닝에 도움이 되는 몇 가지 사실

1. GC를 성능 문제의 근원으로 보고 확인하는 비용은 저렴하다.
2. UAT 단계에서 GC 플래그를 켜는 비용은 저렴하다.
3. 메모리 프로파일러, 실행 프로파일러를 설정하는 비용은 저렴하지 않다.

엔지니어가 튜닝하면서 면밀히 측정해야 할 4가지

- 할당
- 중단 민감도
- 처리율 추이
- 객체 수명

⇒ 가장 중요한 요소는 **할당**

힙 크기를 조정하는 기본 플래그

| 플래그 | 작용 |
| :--: | :-- |
| `-Xms<size>` | 힙 메모리 최소 크기 설정 |
| `-Xmx<size>` | 힙 메모리 최대 크기 설정 |
| `-XX:MaxPermSize=<size>` | 펌젠 메모리 최대 크기 설정 (자바 7 이전) |
| `-XX:MaxMetaspaceSize=<size>` | 메타스페이스 메모리 최대 크기 설정 (자바 8 이후) |

성능 문제 요인이 GC인지 아닌지 판단하는 요령

- CPU 사용률이 100%에 가까운지
- 대부분의 시간이 유저 공간에서 소비되는지
- GC 로그가 쌓이고 있는지

⇒ 위 내용들을 확인할 수 있도록 모니터링 이력 데이터를 쌓는 시스템도 필요  
⇒ 3가지 조건이 다 맞는다면 GC가 성능 문제의 근원일 가능성이 높음

### 3.1 할당이란?

평균 할당률 산출

- 영 세대 수집 이벤트 데이터를 통해 할당된 데이터양, 단위 수집 시간 계산을 계산해서 평균 할당률을 산출할 수 있음
- 할당률 수치가 1GB/s 이상으로 지속되면 GC 튜닝만으로 해결할 수 없는 성능 문제가 터진 것
  - 이 경우 애플리케이션의 할당 로직을 제거하는 리팩토링 밖에 방법이 없음

초기 할당 전략에서 집중해야 할 4가지 단순 영역

- 사소한 객체 할당
- 박싱 비용
- 도메인 객체
- non-JDK 프레임워크 객체

조기 승격

- 할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼침
- 영 GC가 자주 발생하면 단명 객체가 테뉴어드로 잘못 승격될 수 있음
- JVM은 이를 위해 테뉴어드 승격 없이 엄청난 양의 생존 데이터를 담을 서바이버 공간을 동적으로 조절

❖ 조기 승격 문제에 요긴한 스위치

```bash
-XX:MaxTenuringThreshold=<n>
```

- 테뉴어드 영역으로 승격되기 전까지 객체가 통과해야 할 GC 횟수를 설정
- default 4회, 1~15 사이의 값으로 설정 가능
- 한계치가 높을수록 정말로 장수한 객체를 더 많이 복사
- 한계치가 너무 낮으면 단명 객체가 승격되어 테뉴어드에 메모리압을 가중시킴
- 그런데 non-default를 사용해서 성능이 확실히 나아진 벤치마킹 사례가 거의 없긴 함

### 3.2 중단 시간이란?

- 대부분의 애플리케이션에서 100ms 정도의 중단 시간은 허용 가능한 수준

중단 시간 튜닝에 유용한 휴리스틱

1. `> 1s` : 1초 이상 걸려도 괜찮은 경우
2. `1s ~ 100ms` : 1초에서 100ms 사이 정도면 괜찮은 경우
3. `< 100ms` : 100ms 미만이면 괜찮은 경우

초기 GC들의 허용 중단 시간

### 3.3 수집기 스레드와 GC 루트

GC 루트 탐색 시간이 영향을 받는 요인

- 애플리케이션 스레드 개수
- 코드 캐시에 쌓인 컴파일드 코드량
- 힙 크기

탐색은 단일 스레드로

- 마킹 단계에서 엄청 큰 `Object[]`가 발견되어도 탐색은 단일 스레드로 이루어짐
- 극단적인 경우 단일 스레드의 탐색 시간이 전체 마킹 시간을 결정짓게 됨
- 객체 그래프 내부에 객체 체인이 길게 늘어져 있으면 이런 현상이 더욱 심해짐
- 애플리케이션 스레드가 너무 많아도 스택 프레임을 더 많이 탐색해야 하고 세이프포인트 도달 시간도 길어지므로 좋은 게 아님

## 4. Parallel GC 튜닝

- 튜닝이 쉬운 편
- 목표와 트레이드오프가 뚜렷함
  - 풀 STW
  - GC 처리율이 높고 계산 비용이 저렴
  - 부분 수집이 일어날 일이 없음
  - 중단 시간은 힙 크기에 비례
- 힙이 4GB 이하로 작은 경우 Parallel GC는 아주 효과적인 선택

## 5. CMS 튜닝

- 튜닝이 까다롭기로 소문난 수집기
- CMS는 정말로 STW 시간을 단축시켜야 하는 어쩔 수 없는 유스케이스에 한해서만 사용해야 함
- 100여개의 방대한 플래그를 가지고 있지만 플래그 값을 바꾼다고 성능이 눈에 띄게 개선되는 일은 없을 것

CMF 발생 직전의 수집기 상태를 살펴봐야 한다

- CMS 수집 후 곧바로 새 CMS 수집이 발생하는 **백투백** 수집 현상은 고장의 전조
  - 회수 속도가 할당 속도를 따라잡지 못하고 CMF 발생하게 될 것
- 백투백 현상 발생 시 전체 애플리케이션의 실행 처리율은 50% 감소
  - 동시 수집을 위해 코어의 절반을 사용하므로

`-XX:CMSInitiatingOccupancyFraction=<n>`

- CMS가 언제 수집을 시작할지 설정
- CMS 실행 시 승격된 객체들을 수용할 여유 공간이 필요해짐
- 여유 공간은 원래 JVM이 자동 조정하지만 위 플래그로 첫 번째 CMS에 대한 조정을 할 수 있음
- 첫 번째 CMS를 가동시킬 추정치를 위 플래그와 함께 미리 정해놓을 수 있음
- 기본값 75%

`-XX:+UseCMSInitiatingOccupancyOnly`

- 초기 점유 공간을 동적으로 조정하는 기능을 끔
- 함부로 켜면 안 되는 플래그

### 5.1 단편화로 인한 CMF

**프리 리스트 통계치**를 통해 언제 CMF가 발생할지 예측하는 방법

```bash
-XX:+PrintFLSStatistics=1
```

- 총 프리 공간, 최대 청크 크기, 블록 개수, 평균 블록 크기, 트리 높이를 출력해줌
- 평균 블록 크기와 최대 청크 크기를 비교해보면 메모리 청크의 크기 분포를 대략 짐작 가능
- 큰 라이브 객체를 테뉴어드로 옮길 때 청크가 바닥난 경우 CMF로 이어질 것
- 그러면 JVM은 Parallel GC로 전환해서 힙을 압착하고 프리 리스트를 병합 → STW 시간이 길어짐

## 6. G1 튜닝

G1 튜닝의 목표

- 엔드 유저가 최대 힙 크기와 최대 STW 시간을 설정하면 G1이 나머지를 알아서 처리하게 하는 것

G1의 플래그들

- 많은 플래그들이 있지만 여전히 실험 단계인 것들이 있으므로 사용해야겠다면 아래의 플래그부터 사용해야 함

```bash
-XX:+UnlockExperimentalVMOptions
```

- 특히 `-XX:G1NewSizePercent=<n>` `-XX:G1MaxNewSizePercent=<n>` 플래그를 사용할 때 필요

튜닝의 어려운 점들

- 수집기 등장 이후 많은 변화가 있었기 때문에 민간 튜닝 시 심각한 문제가 발생할 수 있음
- *따라서 이 책에서 G1 튜닝에 대한 자세한 내용은 다루지 않음*

높은 할당률과 함께 단명 객체가 많이 생성되는 경우

- 영 세대를 크게 설정하기
- 테뉴어드 한계치를 최대 15 정도 늘리기
- 수용 가능한 최장 중단 시간 목표 정하기

## 7. jHiccup

- HdrHistogram을 사용하는 오픈소스 툴
- JVM이 연속적으로 실행되지 못한 'hiccup(딸꾹질)' 지점을 보여주는 계측 도구
- 히컵을 일으키는 가장 흔한 원인은 GC STW
  - OS나 플랫폼 관련 문제 때문에 발생하기도 함
  - 따라서 GC 튜닝에도 좋지만 초저지연 작업에도 유용

사용 방법

- 자바 에이전트로 사용

```bash
java -javaagent:jHiccup.jar MyProgram
```

- Attach API로 사용

```bash
jHiccup -p <pid>
```

용도

- HdrHistogram의 입력 데이터로 사용 가능한 히스토그램 로그 형식 결과 출력

참고

http://psy-lob-saw.blogspot.com/2015/02/hdrhistogram-better-latency-capture.html
