10장에서는...

- JVM JIT 컴파일러를 깊이 알아볼 것
  - 핫스팟 위주로
- JITWatch를 활용한 JVM 내부 작동 원리 시각화
- 구체적인 JIT 최적화 알고리즘들


## 1. JITWatch란?

- [오픈 소스 자바FX 툴](https://github.com/AdoptOpenJDK/jitwatch)
- 애플리케이션 실행 중 핫스팟이 바이트코드에 어떤 작동을 하는지 이해하는 데 도움을 줌
- hot path에 있는 컴파일 대상 메소드를 분석 대상으로 삼을 것
- 자바 애플리케이션이 생성하는 핫스팟 컴파일 상세 로그를 파싱 및 분석하고, 결과를 자바FX GUI 형태로 보여줌
  - 따라서 자바 애플리케이션 실행 시 아래의 플래그를 추가해야 함

```bash
java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:+TraceClassLoading -jar myapp.jar
```

sandbox

- 작은 프로그램을 신속히 프로토타이핑하고 테스트할 수 있는 환경
- 로그파일 대신 JVM 언어를 로드할 수 있음

triview

- 샌드박스보다 정교한 애플리케이션 컴파일 뷰
- 소스 코드가 바이트코드 및 어셈블리 양쪽으로 어떻게 컴파일됐는지 알 수 있게 해줌

segmented code cache

- 자바 8 이전에는 컴파일드 메소드, 논프로파일드 메소드, VM 자체 네이티브 코드를 하나의 코드 캐시 영역에 담았음
- 자바 9부터는 이를 세그먼트화하여 각각의 영역에 담음
- 덕분에 단편화 및 스위퍼 시간을 단축하고 풀 컴파일드 코드의 지역성을 높일 수 있게 되었음

### 1.2 디버그 JVM과 hsdis

- JIT 서브시스템의 통게치를 얻으려면 디버그 JVM을 이용할 것
- 디버그 JVM: 성능 희생을 감수하고 디버깅에 치중한 JVM
- 핫스팟 디버그 JVM은 OpenJDK 소스에서 빌드 가능
- JIT 컴파일러가 생성한 역어셈블 네이티브 코드를 살펴보려면 hsdis 역어셈블 바이너리 필요
  - [Building hsdis](https://github.com/AdoptOpenJDK/jitwatch/wiki/Building-hsdis) 페이지 참고
- 메소드 어셈블리 출력을 위해 아래의 플래그 추가 필요

```bash
java -XX:PrintAssembly
```

## 2. JIT 컴파일 개요

MDO(Method Data Object)

- 핫스팟은 실행 프로그램 정보를 MDO에 저장
- MDO 용도: 바이트코드 인터프리터, C1 컴파일러에서 JIT 컴파일러가 언제 무슨 최적화를 할지 결정하는 데 필요한 정보를 기록
  - 어떤 메소드가 호출되었고, 어느 분기가 실행되었는지, 호출부에서 무슨 타입이었는지
- 프로파일링된 프로퍼티의 'hotness'를 카운터에 계속 기록하고, 컴파일 큐 맨 앞에 이르렀을 때에도 핫한 메소드만 컴파일됨
- 프로파일링 데이터 수집 → 컴파일 결정 → 컴파일러별 세부 처리 절차 진행
- 컴파일러는 코드의 내부 표현형을 빌드
  - 구체적인 표현형은 컴파일러(C1, C2)에 따라 다름
- 핫스팟 JIT 컴파일러는 최신 컴파일러 최적화 기법을 총동원
  - 인라이닝
  - 루프 펼치기
  - 탈출 분석
  - 락 생략/확장
  - 단일형 디스패치
  - 인트린직
  - 온-스택 치환
- 최적화 기법은 런타임 정보와 지원 여부에 따라 완전히 달라질 수 있음
- C1: 추측성 최적화 X
- C2: 공격적 최적화, 런타임 실행 주시 결과를 토대로 추정하고 최적화 수행
- 추측성 최적화 이전에는 항상 guard라는 타당성 검사 수행
  - guard에 실패하면 컴파일드 코드는 안전하지 않으므로 제거해야 함
  - 핫스팟은 메소드를 인터프리티드 모드로 강등시켜 역최적화 수행

## 3. 인라이닝

- 호출된 메소드를 호출부에 복사하는 기법
- 아래의 오버헤드 제거
  - 전달할 매개변수 세팅
  - 호출할 메소드를 정확하게 룩업
  - 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
  - 새 메소드로 제어권 이송
  - 호출부에 결과 반환 (결과값이 있는 경우)
- JIT 컴파일러가 제일 먼저 적용하는 최적화라서 gateway optimization이라고도 불림
- 다른 최적화 기법들의 최적화 범위를 확장시킴
  - 탈출 분석
  - DCE(Dead Code Elimination)
  - 루프 펼치기
  - 락 생략

### 3.1 인라이닝 제한

- VM에서 다음 항목을 조정할 때는 인라이닝 서브시스템에 제한을 두어야 함
  - JIT 컴파일러가 메소드를 최적화하는 데 소비하는 시간
  - 생성된 네이티브 코드 크기 (코드 캐시 메모리 사용량)
- 제약 조건이 하나도 없으면 컴파일러는 아주 깊은 호출 체인까지 파헤치며 인라이닝을 수행
  - 그러면 코드 캐시를 거대한 네이티브 메소드로 가득 채우게 됨
- 핫스팟의 인라이닝 메소드 결정 조건들
  - 인라이닝할 메소드의 바이트코드 크기
  - 현재 호출 체인에서 인라이닝할 메소드의 깊이
  - 메소드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 3.2 인라이닝 서브시스템 튜닝

인라이닝 스위치

| 스위치 | 디폴트 | 설명 |
| :--: | :--: | :-- |
| -XX:MaxInlineSize=<n> | 35byte 바이트코드 | 메소드 크기 제한 |
| -XX:FreqInlineSize=<n> | 325byte 바이트코드 | 핫 메소드 크기 제한 |
| -XX:InlineSmallCode=<n> | 1,000byte(단계 X) 네이티브 코드<br>2,000byte(단계 O) 네이티브 코드 | 코드 캐시에 지정 수치보다 많은 공간의 최종 단계 컴파일이 있으면 메소드 인라이닝 제한 |
| -XX:MaxInlineLevel=<n> | 9 | 호출 프레임 깊이 제한 |
