10장에서는...

- JVM JIT 컴파일러를 깊이 알아볼 것
  - 핫스팟 위주로
- JITWatch를 활용한 JVM 내부 작동 원리 시각화
- 구체적인 JIT 최적화 알고리즘들


## 1. JITWatch란?

- [오픈 소스 자바FX 툴](https://github.com/AdoptOpenJDK/jitwatch)
- 애플리케이션 실행 중 핫스팟이 바이트코드에 어떤 작동을 하는지 이해하는 데 도움을 줌
- hot path에 있는 컴파일 대상 메소드를 분석 대상으로 삼을 것
- 자바 애플리케이션이 생성하는 핫스팟 컴파일 상세 로그를 파싱 및 분석하고, 결과를 자바FX GUI 형태로 보여줌
  - 따라서 자바 애플리케이션 실행 시 아래의 플래그를 추가해야 함

```bash
java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:+TraceClassLoading -jar myapp.jar
```

sandbox

- 작은 프로그램을 신속히 프로토타이핑하고 테스트할 수 있는 환경
- 로그파일 대신 JVM 언어를 로드할 수 있음

triview

- 샌드박스보다 정교한 애플리케이션 컴파일 뷰
- 소스 코드가 바이트코드 및 어셈블리 양쪽으로 어떻게 컴파일됐는지 알 수 있게 해줌

segmented code cache

- 자바 8 이전에는 컴파일드 메소드, 논프로파일드 메소드, VM 자체 네이티브 코드를 하나의 코드 캐시 영역에 담았음
- 자바 9부터는 이를 세그먼트화하여 각각의 영역에 담음
- 덕분에 단편화 및 스위퍼 시간을 단축하고 풀 컴파일드 코드의 지역성을 높일 수 있게 되었음

### 1.2 디버그 JVM과 hsdis

- JIT 서브시스템의 통게치를 얻으려면 디버그 JVM을 이용할 것
- 디버그 JVM: 성능 희생을 감수하고 디버깅에 치중한 JVM
- 핫스팟 디버그 JVM은 OpenJDK 소스에서 빌드 가능
- JIT 컴파일러가 생성한 역어셈블 네이티브 코드를 살펴보려면 hsdis 역어셈블 바이너리 필요
  - [Building hsdis](https://github.com/AdoptOpenJDK/jitwatch/wiki/Building-hsdis) 페이지 참고
- 메소드 어셈블리 출력을 위해 아래의 플래그 추가 필요

```bash
java -XX:PrintAssembly
```

## 2. JIT 컴파일 개요

MDO(Method Data Object)

- 핫스팟은 실행 프로그램 정보를 MDO에 저장
- MDO 용도: 바이트코드 인터프리터, C1 컴파일러에서 JIT 컴파일러가 언제 무슨 최적화를 할지 결정하는 데 필요한 정보를 기록
  - 어떤 메소드가 호출되었고, 어느 분기가 실행되었는지, 호출부에서 무슨 타입이었는지
- 프로파일링된 프로퍼티의 'hotness'를 카운터에 계속 기록하고, 컴파일 큐 맨 앞에 이르렀을 때에도 핫한 메소드만 컴파일됨
- 프로파일링 데이터 수집 → 컴파일 결정 → 컴파일러별 세부 처리 절차 진행
- 컴파일러는 코드의 내부 표현형을 빌드
  - 구체적인 표현형은 컴파일러(C1, C2)에 따라 다름
- 핫스팟 JIT 컴파일러는 최신 컴파일러 최적화 기법을 총동원
  - 인라이닝
  - 루프 펼치기
  - 탈출 분석
  - 락 생략/확장
  - 단일형 디스패치
  - 인트린직
  - 온-스택 치환
- 최적화 기법은 런타임 정보와 지원 여부에 따라 완전히 달라질 수 있음
- C1: 추측성 최적화 X
- C2: 공격적 최적화, 런타임 실행 주시 결과를 토대로 추정하고 최적화 수행
- 추측성 최적화 이전에는 항상 guard라는 타당성 검사 수행
  - guard에 실패하면 컴파일드 코드는 안전하지 않으므로 제거해야 함
  - 핫스팟은 메소드를 인터프리티드 모드로 강등시켜 역최적화 수행

## 3. 인라이닝

- 호출된 메소드를 호출부에 복사하는 기법
- 아래의 오버헤드 제거
  - 전달할 매개변수 세팅
  - 호출할 메소드를 정확하게 룩업
  - 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
  - 새 메소드로 제어권 이송
  - 호출부에 결과 반환 (결과값이 있는 경우)
- JIT 컴파일러가 제일 먼저 적용하는 최적화라서 gateway optimization이라고도 불림
- 다른 최적화 기법들의 최적화 범위를 확장시킴
  - 탈출 분석
  - DCE(Dead Code Elimination)
  - 루프 펼치기
  - 락 생략

### 3.1 인라이닝 제한

- VM에서 다음 항목을 조정할 때는 인라이닝 서브시스템에 제한을 두어야 함
  - JIT 컴파일러가 메소드를 최적화하는 데 소비하는 시간
  - 생성된 네이티브 코드 크기 (코드 캐시 메모리 사용량)
- 제약 조건이 하나도 없으면 컴파일러는 아주 깊은 호출 체인까지 파헤치며 인라이닝을 수행
  - 그러면 코드 캐시를 거대한 네이티브 메소드로 가득 채우게 됨
- 핫스팟의 인라이닝 메소드 결정 조건들
  - 인라이닝할 메소드의 바이트코드 크기
  - 현재 호출 체인에서 인라이닝할 메소드의 깊이
  - 메소드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 3.2 인라이닝 서브시스템 튜닝

인라이닝 스위치

| 스위치 | 디폴트 | 설명 |
| :--: | :--: | :-- |
| -XX:MaxInlineSize=<n> | 35byte 바이트코드 | 메소드 크기 제한 |
| -XX:FreqInlineSize=<n> | 325byte 바이트코드 | 핫 메소드 크기 제한 |
| -XX:InlineSmallCode=<n> | 1,000byte(단계 X) 네이티브 코드<br>2,000byte(단계 O) 네이티브 코드 | 코드 캐시에 지정 수치보다 많은 공간의 최종 단계 컴파일이 있으면 메소드 인라이닝 제한 |
| -XX:MaxInlineLevel=<n> | 9 | 호출 프레임 깊이 제한 |

## 4. 루프 펼치기

- back branch가 발생할 때마다 CPU는 명령어 파이프라인을 덤프하기 때문에 성능이 저하됨
  - back branch: 루프의 끝에서 루프의 시작으로 돌아가는 분기
- 루프 바디가 짧을수록 백 브랜치 비용은 상대적으로 높음
- 루프 펼치기 기준
  - 루프 카운터 변수 유형 (int, long)
  - 루프 보폭 (한번 순회할 때 루프 카운터 값이 얼마나 바뀌는지)
  - 루프 내부의 탈출 지점 개수 (break, return, throw)

array bounds check elimination

- 루프를 돌며 배열 원소에 액세스할 때 핫스팟은 루프를 3 구역으로 나누어 배열 경계 검사를 제거

| 루프 구역 | 경계 검사 여부 | 설명 |
| :--: | :--: | :-- |
| 사전 루프 | Y | 초기 순회는 경계 검사 필요 |
| 메인 루프 | N | 루프 보폭을 활용해서 경계 검사를 안 해도 순회 가능한 최대 횟수 계산해서 적용 |
| 사후 루프 | Y | 나머지 순회는 경계 검사 필요 |

safepoint poll

- JIT 컴파일러는 컴파일된 코드가 너무 오래 세이프포인트 플래그 체크 없이 실행되는 일이 없도록 세이프포인트 체크 코드를 삽입함
- 루프 보폭이 가변적인 경우에는 루프 펼치기를 하지 않고 백 브랜치가 일어나기 직전에 세이프포인트 체크 코드를 삽입함

### 4.1 루프 펼치기 정리

최적화 기법

- 카운터가 int, short, char 형일 경우 루프 최적화
- 루프 바디를 펼치고 세이프포인트 폴 제거
- 루프를 펼치면 백 브랜치 횟수가 줄고 그만큼 분기 예측 비용도 줄어듦
- 세이프포인트 폴을 제거하면 루프를 순회할 때마다 하는 일이 줄어듦

## 5. 탈출 분석

scope-based analysis

- 어떤 메소드의 내부 수행 작업을 외부에서 볼 수 있는지, 부수 효과를 유발하지는 않는지 분석하는 것
- 메소드 내부에서 할당된 객체를 메소드 범위 밖에서 바라볼 수 있는지 알아보는 용도

잠재적 탈출 가능 객체를 3가지 유형으로 분류

```java
enum EscapeState {
  NoEscape, // 메소드 범위 내에서만 사용
  ArgEscape, // 메소드 인자로 전달되어 범위 밖에서 사용
  GlobalEscape // 메소드 범위 밖에서 사용
};
```

### 5.1 힙 할당 제거

- 핫스팟의 탈출 분석 최적화는 객체 할당률을 신경 쓰지 않고도 자바 코드를 작성할 수 있게 해줌
- NoEscape
  - scalar replacement 최적화를 통해 객체 필드를 마치 처음부터 객체 필드가 아닌 지역 변수였던 것처럼 스칼라 값으로 대체
  - 그 다음 register allocator라는 핫스팟 컴포넌트에 의해 CPU 레지스터에 할당
- 탈출 분석의 목표: 객체를 스택에 자동 할당해서 GC 압박을 줄이는 것

### 5.2 락과 탈출 분석

락 최적화 핵심

- **lock elision** : non-escaping 객체에 대한 락을 생략
- **lock coarsening** : 연속되는 락 영역 병합
- **nested lock** : 락을 해제하지 않고 같은 락을 반복 획득한 블록 찾아내기

### 5.3 탈출 분석의 한계

- 다른 기법들과 마찬가지로 트레이드오프가 존재
- 기본적으로 원소가 64개 이상인 배열은 탈출 분석 대상에서 제외됨
  - 개수 제한은 다음 VM 스위치로 조정 가능

```bash
-XX:EliminateAllocationArraySizeLimit=<n>
```

partial escape analysis 미지원

- 흐름에 민감한 탈출 분석을 지원하지 않는다는 뜻
- 객체가 메소드 범위를 탈출하면 힙에 객체를 할당하지 않는 최적화가 적용될 수 없음

## 6. 단형성 디스패치

- 핫스팟 C2 컴파일러의 추측성 최적화는 대부분 경험적 연구 결과를 토대로 함

mono-morphic dispatch

- mono-morphic은 single form을 의미하는 그리스어에서 유래
- '사람이 작성한 코드를 보면 십중팔구 각 호출부마다 딱 한 가지 런타임 타입이 수신자 객체 타입이 된다'
  - 객체 지향 소프트웨어 설계 방식을 고려해보면 매우 일리 있는 말
- 즉, 어떤 객체의 메소드를 호출할 때, 최초로 호출한 객체의 런타임 타입을 알아내면 이후 모든 호출도 동일한 타입일 가능성이 크다는 뜻
- 항상 타입이 같으므로 invokevirtual 명령어를 퀵 타입 테스트(guard) 후 컴파일드 메소드 바디로 분기하는 코드로 치환
  - klass 포인터 및 vtable을 통해 가상 룩업을 하고 에둘러 참조하는 일은 딱 한번만

bi-morphic dispatch

- 자주 쓰이진 않지만 핫스팟에서 지원하는 최적화
- 서로 다른 두 타입을 단형성 디스패치와 같은 방법으로 호출부마다 상이한 두 klass 워드를 캐시해서 처리

megamorphic dispatch

- 그리스어로 many form을 의미
- 극히 소수의 관측된 타입을 지는 다형성 호출부를 찾아내면 성능 향상을 도모할 수 있음
- 호출부에서 instanceof 체크를 하며 2가지 구체 타입을 바라보는 이형성 호출부만 남겨두는 방식
- 여러 타입 중 하나를 다른 호출부로 벗겨내면(peel off) 다형성 코드에 비해 성능을 높일 수 있음
- [메소드 디스패치의 흑마술](https://shipilev.net/blog/2015/black-magic-method-dispatch/) 읽어보기

## 7. 인트린직

- 서브시스템의 동적 생성 이전에 JVM이 이미 알고 있는 고도로 튜닝된 네이티브 메소드 구현체
- 주로 OS, CPU 아키텍처의 특정 기능을 응용하는 성능이 필수적인 코어 메소드에 사용됨
- 플랫폼에 따라 지원하지 않을 수도 있음
- JVM은 기동 직후 런타임에 자신을 실행한 하드웨어의 CPU를 꼼꼼히 살펴보고 사용 가능한 프로세스 기능을 목록화

대표적인 인트린직 메소드

| 메소드 | 설명 |
| :--: | :-- |
| java.lang.System.arraycopy() | CPU 벡터 지원 기능으로 배열을 빠르게 복사 |
| java.lang.System.currentTimeMillis() | 대부분 OS 제공 구현체가 빠름 |
| java.lang.Math.min() | 분기 없이 연산 가능 |
| 기타 java.lang.Math 메소드 | CPU에서 직접 명령어 지원 |
| 암호화 함수 (AES 등) | 하드웨어로 가속하면 성능이 매우 좋아짐 |

인트린직 템플릿

- OpenJDK 핫스팟 소스 코드에서 확장자가 `.ad` (architecture-dependent)인 파일
  - `hotspot/src/cpu/x86/vm/x86_64.ad`

인트린직 활용

- 자바 9부터 메소드 앞에 `@HotSpotIntrinsicCandidate` 어노테이션을 붙이면 JVM이 해당 메소드를 인트린직 후보로 삼음
- 새 인트린직을 추가할 때에는 복잡도가 증가하는 것과, 유용하게 잘 쓰는 것 사이에서 저울질을 해봐야 함
- 정말 자주 쓰이는 작업에 한해서만 성능에 큰 영향을 미칠 수 있다

## 8. 온-스택 치환

- 컴파일을 일으킬 정도로 호출 빈도가 높진 않지만 메소드 내부에 핫 루프가 포함된 경우가 있음
  - 대표적으로 자바 프로그램의 `main()` 메소드
- 핫스팟은 이런 코드를 OSR(On Stack Replacement)이라는 기법으로 최적화
- 인터프리터가 루프 백 브랜치 횟수를 세어보고, 특정 한계치를 초과하면 루프 컴파일 후 치환해서 실행
- 대신 컴파일러는 컴파일 이전의 루프 내 상태 변화가 컴파일 이후에도 반영되도록 보장해야 함

## 9. 세이프포인트 복습

전체 스레드가 세이프포인트에 걸리는 조건들

- GC STW 이벤트
- 메소드 역최적화
- 힙 덤프 생성
- 바이어스 락 취소
- 클래스 재정의

세이프포인트 체크 코드를 넣는 지점

- 루프 백 브랜치 지점
- 메소드 반환 지점

세이프포인트에 대해 고려할 점

- 스레드가 세이프포인트에 도달할 때까지의 시간 소요
  - 많은 산술 연산 코드가 포함된 루프가 펼쳐져 있으면 세이프포인트에 이르기까지 적잖은 시간이 걸릴 것
- 컴파일러는 세이프포인트를 폴링하며 체크하는 비용을 감수할지, 이미 세이프포인트에 닿은 스레드가 다른 스레드도 세이프포인트에 닿을 때까지 대기하는 TTSP(time to safe point)를 감수할지 결정해야 함

```bash
java -XX:+PrintSafepointStatistics -XX:PrintGCApplicationStoppedTime
```

- 위 명령어를 통해 다른 스레드가 세이프포인트에 이를 때까지 기다린 시간, 세이프포인트로 인한 프로그램 총 소요 시간을 확인할 수 있음

## 10. 코어 라이브러리 메소드

- JDK 코어 라이브러리 크기가 JIT 컴파일에 어떤 영향을 주는지 알아볼 것

### 10.1 인라이닝하기 적합한 메서드 크기 상한

- 인라이닝 여부는 메소드 바이트코드 크기로 결정
- 클래스 파일을 정적 분석하면 인라이닝하기에 지나치게 큰 메소드를 솎아낼 수 있음
- JITWatch의 JarScan은 클래스 폴더 또는 JAR 파일 내부에서 바이트코드 크기가 한계치 이상인 메소드를 모두 찾아냄
- 플랫폼의 FreqInlineSize 값에 따라 인라이닝 크기 상한이 결정됨

### 10.2 컴파일하기 적합한 메서드 크기 상한

- 핫스팟에는 메소드가 컴파일되지 않게 하는 크기 상한이 존재 (8,000byte)
- 운영계 JVM에서는 이 값을 바꿀 수 없고, 디버그 JVM에서는 `-XX:HugeMethodLimit` 플래그로 바꿀 수 있음
- JarScan으로 JDK 코어 메소드 중 최대 크기를 넘어서는 메소드들 확인 가능

```bash
./jarScan.sh --mode=maxMethodSize --maxMethodSize=8000 /path/to/java/jre/lib/rt.jar
```

- JIT 컴파일이 안된 메소드는 컴파일된 메소드보다 거의 2배 정도 느림
- 라이브러리를 사용할 때 JarScan을 활용해서 메소드 크기를 한번씩 확인해보는 게 좋음

## 11. 마치며

- `-XX:+PrintCompilation` 플래그와 함께 개별 메소드들이 최적화되었는지 확인해보는 습관을 가지자!
- '먼저 좋은 코드를 작성하고 필요한 경우에만 최적화'
