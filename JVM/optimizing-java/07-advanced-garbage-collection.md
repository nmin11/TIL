## 1. 트레이드오프와 탈착형 수집기

- 썬 마이크로시스템즈 환경에서 GC는 탈착형 서브시스템(Pluggable Subsystem)으로 취급됨
  - 같은 자바 프로그램이라도 여러 GC를 갖고 돌려볼 수 있음
  - 완전무결한 범용 GC 알고리즘은 없음
- 개발자가 GC를 선정할 때 고민해야 할 포인트들
  - 중단 시간
  - 처리율 (런타임 대비 GC 시간 비율)
  - 중단 빈도
  - 회수 효율 (GC 사이클 당 회수되는 메모리 양)
  - 중단 일관성

## 2. 동시 GC 이론

- 동시 GC는 GC를 수행하면서 애플리케이션을 계속 실행하는 방식
- 물론 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집 로직은 더 복잡해짐
- 우선 필수 GC 용어 및 기술부터 알아볼 것

### 2.1 JVM 세이브포인트

- JVM은 어떻게 STW를 일으키는가?
- JVM은 스레드를 통제하기 위해 애플리케이션 스레드마다 세이브포인트(Safepoint)를 두고 있음
- 세이브포인트 처리 규칙
  - JVM은 강제로 스레드를 세이브포인트 상태로 바꿀 수 없다.
  - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.
- 스레드는 세이브포인트 요청을 받았을 때 제어권을 반납해야 함
  - 이를 위한 코드(배리어)가 VM 인터프리터 구현에 어딘가에 있어야 함

스레드가 세이브포인트 상태로 바뀌는 일반적인 경우들

1. JVM이 전역 'time to safepoint' 플래그를 세팅한다.
2. 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
3. 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

작동 원리

- 인터프리터에서 바이트코드 2개를 실행할 때마다 체크
- 컴파일드 코드 → 메소드가 회귀하는 지점에 세이브포인트 폴링 코드 삽입

자동 세이브포인트 상태

- 모니터에서 차단
- JNI 코드 실행

꼭 세이브포인트가 되는 건 아닌 경우

- 바이트 코드 실행 도중
- OS의 인터럽트

### 2.2 삼색 마킹

작동 원리

- GC 루트에 회색 표시
- 다른 객체는 모두 흰색 표시
- 마킹 스레드가 임의의 회색 노드로 이동
- 마킹 스레드가 흰색 표시된 자식 노드를 만나면 자식 노드들을 모두 회색 표시한 뒤 해당 노드에 검은색 표시
- 회색 노드가 하나도 남지 않을 때까지 반복
- 검은색 객체는 모두 reachable 하므로 회수 대상에서 제외
- 흰색 객체는 모두 unreachable 하므로 회수 대상에 포함

**SATB**

*Snapshot At The Beginning (일단 스냅샷 뜨기)*

- 수집 사이클을 시작할 때 접근 가능하면 라이브 객체로 간주
- 애플리케이션 스레드가 마킹 작업 도중에 객체를 변경하는 것을 조심해야 함
  - 해결 방안 1 - 쓰기 배리어: 변경된 객체는 색깔을 회색으로 바꾸고 처리할 노드 세트에 추가한다
  - 해결 방안 2 - main phase 이후 fixup 단계에서 바로잡는다

## 3. CMS

*Concurrent Mark Sweep*

- 테뉴어드(올드) 공간 전용 수집기
- 보통 영 세대 전용 ParNew 수집기와 함께 사용됨
- 중단 시간 최소화를 위해, 애플리케이션 스레드 실행 중에 많은 일을 함께 함
- 삼색 마킹 알고리즘에 따라 수집하므로, 레코드를 바로잡기 위한 복잡한 로직 필요

GC 작업 순서

1. Initial Mark (STW)
2. Concurrent Mark
3. Concurrent Preclean
4. Remark (STW)
5. Concurrent Sweep
6. Concurrent Reset

Initial Mark

- 목적: GC 출발점(initial pointer, 목적상 GC 루트와 동일) 얻기
- 다른 메모리 영역은 신경 쓰지 않고 하나의 GC 풀에 집중

Concurrent Mark

- 삼색 마킹 알고리즘을 힙에 적용하면서 나중에 생길 변경사항 추적

Concurrent Preclean

- 목적: Remark 단계의 STW 시간 줄이기
- 카드 테이블을 이용해 Concurrent Mark 도중 영향을 끼친 마킹 조정

CMS 장단점

- 짧은 STW
- 단일 풀 GC 사이클 시간이 긺
- 사이클 실행 중 애플리케이션 처리율 감소
- GC의 객체 추적 때문에 더 많은 메모리 소모
- GC 수행을 위해 더 많은 CPU 시간 소모
- 힙을 압착하지 않으므로 테뉴어드 영역의 단편화 발생 가능

### 3.1 CMS 작동 원리

- 애플리케이션 스레드와 동시 실행
  - 기본적으로 가용 스레드 절반을 GC에 투입
- CMS 실행 도중 에덴 공간이 꽉 차면?
  - STW 이후 영 GC 발생 (CMS가 이미 실행 중이므로 오래 걸림)
  - 영 수집에서 일부 객체가 테뉴어드로 승격되면?
    - 평상시에는 영 수집에서 극히 일부만 테뉴어드로 승격 이후 CMS 올드 수집을 해서 테뉴어드가 정리됨
    - 하지만 할당률이 급증하면 영 수집에서의 조기 승격이 발생하고 테뉴어드 공간이 부족해지는 문제가 발생할 수 있음

→ CMF (Concurrent Mode Failure)

- 조기 승격으로 인한 테뉴어드 공간 부족 문제가 발생하면 JVM은 풀 STW를 유발하는 Parallel Old GC 수집 방식으로 돌아감
- CMF 방지를 위해 테뉴어드 공간이 꽉 차기 전에 CMS 수집 사이클을 실행해야 함
  - 테뉴어드 힙 점유 수준을 기준으로 CMS 수집 사이클 실행
  - default: 75% 테뉴어드 점유 시점
- 힙 단편화
  - CMF를 유발하는 또 다른 원인
  - CMS는 테뉴어드를 압착하지 않음
  - 테뉴어드의 빈 공간은 단일 연속 블록이 아니기 때문에 승격된 객체를 기존 객체 사이사이에 밀어 넣어야 함
  - 객체를 끼워 넣을 공간이 부족하면 테뉴어드 승격이 불가능해지고 CMF 발생

프리 리스트

- CMS는 내부적으로 프리 리스트를 통해 사용 가능한 빈 공간 관리
- Concurrent Sweep 단계에서 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉침
- 새로 할당된 블록이 잘못 스윕될 경우를 예방하기 위해 스위퍼 스레드는 작업 도중 프리 리스트를 잠궈둠

### 3.2 CMS 기본 JVM 플래그

```bash
java -XX:+UseConcMarkSweepGC
```

- 최신 핫스팟 버전에서 이 플래그를 쓰면 ParNew GC와 함께 작동
- 60개가 넘는 플래그들이 있음 (숲을 보기 위해 지금은 보지 말자)

## 4. G1

*Garbage First*

특성

- CMS보다 훨씬 튜닝하기 쉬움
- 조기 승격에 덜 취약
- 대용량 힙에서의 우수한 확장성
- 풀 STW 수집을 없앨 수 있음
- 자바 9부터 디폴트 GC

### 4.1 G1 힙 레이아웃 및 영역

- 힙은 region으로 구분됨
  - default 크기 1MB 메모리 공간
  - 세대를 불연속적으로 배치 가능
  - 매 GC마다 전체 가비지를 수집할 필요가 없음

(이미지 첨부 - g1-region.png)

- 1, 2, 4, 8, 16, 32, 64MB 크기로 region을 사용할 수 있음
- 기본적으로 힙에는 2,048 ~ 4,095개의 region 존재
  - 이 개수에 따라 region 크기도 조정됨
  - `regionSize = heapSize / 2048`
  - `regionCount = heapSize / regionSize`
  - 런타임 스위치로도 변경 가능

### 4.2 G1 알고리즘 설계

G1 수집기가 하는 일의 맥락

- 동시 마킹 단계 활용
- 방출 수집기로서 작동
- 통계적으로 압착

세부 작업들

- 워밍업 시기 - GC 사이클이 한번 돌 때 얼마나 많은 '일반' 영역에서 가비지를 수집할 수 있는지 그 수치 보관
- TLAB 할당, 서바이버로의 방출, 테뉴어드로의 승격 등은 다른 핫스팟 수집기와 비슷

영 세대 구성

- 영 세대는 똑같이 에덴, 서바이버 영역으로 나뉨
  - 다만 세대를 구성하는 영역이 연속되어 있지 않을 뿐
  - 영 세대의 크기는 전체 중단 시간 목표에 따라 조정됨

**RSet**

- *Remembered Set*
- 영역별로 하나씩, 외부에서 힙 영역 내부를 참조하는 레퍼런스 관리 장치
- 카드 테이블과 함께 floating garbage를 추적하는 데 사용됨
  - floating garbage: 현재 수집 세트 외부에서 죽은 객체가 참조하는 객체라서 살아있는 객체처럼 보이는 객체

### 4.3 G1 단계

1. 초기 마킹 (STW)
2. 동시 루트 탐색
3. 동시 마킹
4. 재마킹 (STW)
5. 정리 (STW)

동시 루트 탐색

- 초기 마킹 단계의 서바이버 영역에서 올드 세대를 가리키는 레퍼런스를 찾는 동시 단계
- 반드시 다음 영 GC 탐색 시작 전에 끝내야 함

재마킹

- 마킹 작업을 끝냄
- 레퍼런스(weak/soft) 처리 후 SATB 방식으로 정리 작업 수행

정리

- accounting 및 RSet scrubbing 태스크 수행
- accounting: 재사용 준비를 마친 영역을 식별하는 작업

### 4.4 G1 기본 JVM 플래그

```bash
java -XX:+UseG1GC
```

```bash
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200
```

- G1의 목표는 특정 시간 안에 GC를 끝내는 것
- 하지만 실제로 이 기준에 맞추리란 보장은 없고, 어디까지나 목표치
- 100ms 이하는 지키지 못할 가능성이 큼

```bash
java -XX:+UseG1GC -XX:G1HeapRegionSize=<n>
```

- region 크기를 조정할 수 있음
- 1, 2, 4, 8, 16, 32, 64MB 중 하나로 설정

정리

- G1은 오라클의 전폭적인 지원을 받고 있는 안정된 알고리즘
- 하지만 저지연 워크로드에서 아직 CMS보다 STW가 긺
