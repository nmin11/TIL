## 1. 트레이드오프와 탈착형 수집기

- 썬 마이크로시스템즈 환경에서 GC는 탈착형 서브시스템(Pluggable Subsystem)으로 취급됨
  - 같은 자바 프로그램이라도 여러 GC를 갖고 돌려볼 수 있음
  - 완전무결한 범용 GC 알고리즘은 없음
- 개발자가 GC를 선정할 때 고민해야 할 포인트들
  - 중단 시간
  - 처리율 (런타임 대비 GC 시간 비율)
  - 중단 빈도
  - 회수 효율 (GC 사이클 당 회수되는 메모리 양)
  - 중단 일관성

## 2. 동시 GC 이론

- 동시 GC는 GC를 수행하면서 애플리케이션을 계속 실행하는 방식
- 물론 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집 로직은 더 복잡해짐
- 우선 필수 GC 용어 및 기술부터 알아볼 것

### 2.1 JVM 세이브포인트

- JVM은 어떻게 STW를 일으키는가?
- JVM은 스레드를 통제하기 위해 애플리케이션 스레드마다 세이브포인트(Safepoint)를 두고 있음
- 세이브포인트 처리 규칙
  - JVM은 강제로 스레드를 세이브포인트 상태로 바꿀 수 없다.
  - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.
- 스레드는 세이브포인트 요청을 받았을 때 제어권을 반납해야 함
  - 이를 위한 코드(배리어)가 VM 인터프리터 구현에 어딘가에 있어야 함

스레드가 세이브포인트 상태로 바뀌는 일반적인 경우들

1. JVM이 전역 'time to safepoint' 플래그를 세팅한다.
2. 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
3. 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

작동 원리

- 인터프리터에서 바이트코드 2개를 실행할 때마다 체크
- 컴파일드 코드 → 메소드가 회귀하는 지점에 세이브포인트 폴링 코드 삽입

자동 세이브포인트 상태

- 모니터에서 차단
- JNI 코드 실행

꼭 세이브포인트가 되는 건 아닌 경우

- 바이트 코드 실행 도중
- OS의 인터럽트

### 2.2 삼색 마킹

작동 원리

- GC 루트에 회색 표시
- 다른 객체는 모두 흰색 표시
- 마킹 스레드가 임의의 회색 노드로 이동
- 마킹 스레드가 흰색 표시된 자식 노드를 만나면 자식 노드들을 모두 회색 표시한 뒤 해당 노드에 검은색 표시
- 회색 노드가 하나도 남지 않을 때까지 반복
- 검은색 객체는 모두 reachable 하므로 회수 대상에서 제외
- 흰색 객체는 모두 unreachable 하므로 회수 대상에 포함

**SATB**

*Snapshot At The Beginning (일단 스냅샷 뜨기)*

- 수집 사이클을 시작할 때 접근 가능하면 라이브 객체로 간주
- 애플리케이션 스레드가 마킹 작업 도중에 객체를 변경하는 것을 조심해야 함
  - 해결 방안 1 - 쓰기 배리어: 변경된 객체는 색깔을 회색으로 바꾸고 처리할 노드 세트에 추가한다
  - 해결 방안 2 - main phase 이후 fixup 단계에서 바로잡는다
