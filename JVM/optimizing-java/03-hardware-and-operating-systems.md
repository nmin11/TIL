## 1. 최신 하드웨어 소개

- 아직도 많은 대학교에서 간단하고 고전적인 하드웨어 내용을 가르치고 있음
- C 프로그래밍만이 진리의 원천이 아님
- 이 장에서 그간 발전된 여러 CPU 기술을 알아볼 것

## 2. 메모리

- 처음에는 트랜지스터 개수의 급증에 따라 clock speed가 빨라지는 방향으로 발전
- 그러나 시간이 갈수록 빨라지는 프로세스 코어의 데이터 수요를 메인 메모리가 맞추기 어려워졌음
- 결국 clock speed가 올라가도 CPU는 데이터가 도착할 때까지 기다려야 하는 상황

### 2.1 메모리 캐시

![cpu-cache](https://github.com/nmin11/TIL/assets/75058239/9a0ed819-deb2-4e4c-a3c6-676bbe5e0ad6)

- 그래서 CPU 캐시가 고안되었음
- 액세스 빈도가 높은 캐시일수록 프로세스 코어와 가깝게 위치하며 L1, L2, L3 등으로 구분
- 프로세서 아키텍처에 따라 세부 설정은 다르지만 일반적으로 각 실행 코어에 전용 프라이빗 캐시 L1, L2를 두고, L3는 일부 또는 전체 코어가 공유
- 메모리와 캐시가 어떻게 데이터를 싱크할지에 대한 고민거리가 추가되었음
  - 이 문제는 보통 캐시 일관성 프로토콜(cache coherence protocol)을 통해 해결
- MESI 프로토콜은 캐시 라인 상태를 4가지로 정의
  - Modified: 데이터가 수정되었음
  - Exclusive: 이 캐시에만 존재하고 메인 메모리와 일치함
  - Shared: 둘 이상의 캐시에 존재하고 메인 메모리와 일치함
  - Invalid: 다른 프로세스가 데이터를 수정했으므로 이 캐시는 더 이상 유효하지 않음
- 초기에는 매번 캐시 연산 결과를 메모리에 바로 기록하는 write-through 방식을 사용했으나 근래에는 dirty 캐시 블록만 메모리에 기록하는 write-back 방식 사용
- 최대 전송률이 결정되는 인자들
  - 메모리 클록 주파수
  - 메모리 버스 폭(보통 64bit)
  - 인터페이스 개수(보통 2개)

## 3. 최신 프로세서의 특성

- 메모리 케시는 증가하는 트랜지스터를 가장 확실하게 사용하긴 했지만 여러 다른 기술도 등장했음

### 3.1 변환 색인 버퍼(TLB)

- 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할 수행
- TLB가 없으면 L1 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16사이클이 걸리기 때문에 모든 최신 칩에서 필수적으로 사용

### 3.2 분기 예측과 추측 실행

- 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상 방지
- 요즘 프로세서는 다단계 명령 파이프라인을 이용해 CPU 1사이클도 여러 개별 단계로 나누어 실행
  - 여러 명렁이 동시에 실행 중일 수 있으므로 조건문을 다 평가하기 전까지 분기를 예측할 수 없음
- 이를 방지하기 위해 트랜지스터를 아낌없이 활용해 가장 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성하는 방식으로 해결
  - 마치 도박이라도 하듯 미리 추측한 결과를 바탕으로 파이프라인을 채움
  - 추측이 맞아떨어지면 CPU는 다음 작업을 진행하고, 아니면 파이프라인을 비워야 함

### 3.3 하드웨어 메모리 모델

- "어떻게 하면 서로 다른 여러 CPU가 일관되게 동일한 메모리 주소를 액세스할 수 있을까?"
- JIT 컴파일러인 javac와 CPU는 코드 실행 순서를 바꿔서 이 문제를 해결
  - 물론 코드 실행 순서를 바꿔도 스레드 결과는 아무런 영향이 없어야 함
- JVM은 프로세서 타입별로 다른 메모리의 일관성을 고려하여 **weak model** 로 설계되었음
  - 따라서 멀티스레드 코드가 제대로 작동하려면 락과 volatile을 정확히 알고 사용해야 함 (12장에서 다시 다룰 중요한 주제)

## 4. 운영체제

- MMU(Memory Management Unit)를 통한 가상 주소 방식과 페이지 테이블은 액세스 제어의 핵심
  - 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 훼손하지 못하도록 보호
  - MMU는 개발자가 직접 손대기에는 너무 저수준 영역이므로 **OS 액세스 스케줄러** 를 살펴볼 것

## 4.1 스케줄러

- **process scheduler** : CPU 액세스를 통제하며 run queue를 이용
  - **run queue** : CPU 실행 대기 중인 프로세스 목록
  - 스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리

![thread-lifecycle](https://github.com/nmin11/TIL/assets/75058239/63dc2f90-af32-4a1d-9648-d21724579514)

- OS는 특성상 CPU에서 코드가 실행되지 않는 시간을 유발
  - 코드가 실행되는 시간보다 기다리는 시간이 더 많음
  - 그러므로 관측한 프로세스에서 나온 통계치는 시스템에 있는 다른 프로세스의 동작에도 영향을 미침
  - 이러한 **jitter** 와 스케줄링 오버헤드는 측정 결과에 노이즈를 끼게 만드는 주요인
- 스케줄러의 움직임을 확인하는 가장 쉬운 방법은 OS가 스케줄링 과정에서 발생시킨 오버헤드를 관측하는 것

```java
long start = System.currentTimeMillis();
for (int i = 0; i < 1_000; i++) {
  Thread.sleep(1);
}
long end = System.currentTimeMillis();
System.out.println("Millis elapsed: " + (end - start) / 4000.0);
```

### 4.2 시간 문제

- POSIX(Portable Operating System Interface) 같은 업계 표준이 있더라도 OS는 저마다 다르게 동작
- `os::javaTimeMillis()` : 네이티브 메소드로 구현된 OS 시간 측정 기능

### 4.3 컨텍스트 교환

- **context switch** : OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스
  - 스레드 실행 명령과 스택 상태를 교체하는 모든 일에 연관되어 있음
  - 유저 스레드 사이에서 발생하거나, 유저 모드에서 커널 모드로 바뀌면서 발생
  - 두 경우 다 비싼 작업이며, 특히 후자가 더 비쌈
- 유저 스레드는 **time slice (preemption)** 도중 커널 모드로 바꿔 어떤 기능을 실행해야 할 때가 있음
  - 하지만 유저 공간에 있는 코드가 액세스하는 메모리 영역은 커널 코드와 거의 공유할 부분이 없음
  - 그러므로 모드가 바뀌면 명령어와 다른 캐시를 강제로 비워야 함
- 커널 모드로 컨텍스트가 교환되면 TLB를 비롯한 다른 캐시까지 무효화
  - 캐시는 시스템 콜 반환 시 다시 체워야 하므로 커널 모드 교환의 여파는 유저 공간으로 다시 제어권이 넘어간 후에도 당분간 이어짐
- 리눅스는 이를 만회하고자 vDSO(virtual Dynamically Shared Object) 장치 제공
  - kernel privilages를 요구하지 않는 시스템 콜을 유저 공간에서 실행할 수 있도록 함

## 5. 단순 시스템 모델

- 단순한 시스템 모델을 예로 들어 성능 문제를 일으키는 근원을 알아볼 것
- 모델을 이루는 기본 컴포넌트
  - 애플리케이션이 실행되는 하드웨어와 OS
  - 애플리케이션이 실행되는 JVM/컨테이너
  - 애플리케이션 코드
  - 애플리케이션이 호출하는 외부 시스템
  - 애플리케이션으로 유입되는 트래픽
- 이들 중 누구라도 성능 문제를 일으킬 수 있음

## 6. 성능 감지 전략

- 성능 진단의 첫 단추 - 어느 리소스가 한계에 도달했는지
- OS 자체가 시스템을 가장 지치게 하는 원흉이 되어서는 곤란
  - OS의 임무는 유저 프로세스 대신 리소스를 관리하는 것
  - 자기 자신이 리소스를 소모하는 것은 아님

### 6.1 CPU 사용률

- 애플리케이션 성능을 나타내는 핵심 지표
- 효율적인 CPU 사용은 성능 향상의 지름길
- 성능 엔지니어라면 `vmstat` `iostat` 정도는 쓸 줄 알아야 함
  - 가상 메모리 및 I/O 서브시스템 상태에 관한 유용한 데이터 제공
- 그러나 `vmstat` 만으로 여러 경우의 수를 분간하기는 어려움
  - thread lock contention 문제를 감지하려면 VisualVM 같은 툴을 사용해야 함

`vmstat` 지표들

- `procs`
  - `r` : 실행 가능한 프로세스
  - `b` : 블로킹된 프로세스
- `memory`
  - `swpd` : 스왑된 메모리
  - `free` : 사용 가능한 메모리
  - `buff` : 버퍼로 사용된 메모리
  - `cache` : 캐시로 사용된 메모리
- `swap`
  - `si` : 디스크로 스왑된 메모리
  - `so` : 메모리로 스왑된 메모리
  - 최신 서버급 머신은 보통 스왑이 별로 일어나지 않음
- `io`
  - `bi` : 블록 디바이스로부터 읽은 512byte 블록 수
  - `bo` : 블록 디바이스로 쓴 512byte 블록 수
- `system`
  - `in` : 초당 인터럽트 수
  - `cs` : 초당 컨텍스트 스위치 수
- `cpu`
  - `us` : 유저 시간
  - `sy` : 시스템 시간
  - `id` : 유휴 시간
  - `wa` : I/O 대기 시간
  - `st` : 가상화 환경에서 훔친 시간

### 6.2 가비지 수집

- 핫스팟 JVM은 시작 시 메모리를 유저 공간에 할당/관리
- 그러므로 메모리를 할당하는 시스템 콜을 할 필요가 없으며, 가비지 수집을 위해 커널 교환을 할 일이 거의 없음
- 따라서 시스템에서 CPU 사용률이 높게 나타났다면 GC는 주범이 아님
- 반면에 유저 공간에서 CPU 사용률이 높게 나타났다면 GC를 의심해야 함
  - 범인이 JVM일까 유저 코드일까?
  - 일단 GC 로그를 확인하고 새 항목이 추가되는 빈도를 알아봐야 함
- JVM에서 GC 로깅은 거의 공짜나 다름없음
  - GC 로깅은 분석용 데이터로서 가치가 높으므로 운영 환경에서는 꼭 GC 로그를 남길 것

### 6.3 입출력

- 자바 프로그램의 I/O
  - 대부분 단순한 I/O만 처리하며 I/O 서브시스템을 심하게 가동하는 애플리케이션 클래스도 비교적 적은 편
  - CPU 및 메모리와 I/O 중 한쪽을 동시에 고갈시키는 애플리케이션은 거의 없음
- `vmstat` `iostat` 만 있어도 기초 진단용으로 충분

**커널 바이패스 I/O**

- 커널을 이용해 데이터를 복사해 유저 공간에 넣는 고성능 애플리케이션은 데이터 매핑 전용 하드웨어/소프트웨어 사용
- 자바의 경우 커스텀 라이브러리를 써야 함

### 6.4 기계 공감

> 자동차 경주 선수가 되려고 엔지니어가 될 필요는 없지만,
> 기계를 공감할 줄은 알아야 합니다.
>
> ― 재키 스튜어트

- 기계 공감은 자바 개발자가 무시하기 쉬운 관심사
  - JVM이 하드웨어를 추상화했으니 굳이 개발자가 성능 관련 내용을 일일이 파악할 필요가 없게끔 느껴짐
- 하지만 고성능/저지연이 필수라면 JVM이 하드웨어와 어떻게 상호작용하는지 이해해야 함

## 7. 가상화

- 가상화는 다양한 종류가 있지만 원본 OS 위에 OS 사본을 하나의 프로세스로 실행시키는 모양새가 가장 일반적
- 요즘은 가상 환경 또는 클라우드 환경에서 애플리케이션을 작동시키는 일이 점점 대세로 굳혀지고 있음
- 가상화의 특징 3가지
  - 가상화 OS에서 실행하는 프로그램은 베어 메탈에서 실행할 때와 동일하게 작동해야 한다.
  - 하이퍼바이저는 모든 하드웨어 리소스 액세스를 조정해야 한다.
  - 가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당 부분을 차지해선 안 된다.
- 게스트 OS의 하드웨어 액세스를 위해 privileged 명령어를 unprevileged 명령어로 고쳐 쓰는 과정 필요
- 지나친 TLB가 일어나지 않도록 일부 OS 커널의 자료 구조는 shadow 해야 함
- 가상 환경 내에서 프로그램을 실행하는 것 자체가 성능 분석 및 튜닝을 한층 더 복잡하게 만듦

## 8. JVM과 운영체제

- JVM은 자바 코드에 공용 인터페이스를 제공하여 OS에 독립적인 휴대용 실행 환경 제공
- 하지만 스레드 스케줄링 같은 아주 기본적인 서비스조차도 하부 OS에 반드시 액세스해야 함
- 이런 기능은 `native` 키워드를 붙인 네이티브 메소드로 구현
  - 이 작업을 대행하는 공통 인터페이스를 JNI(Java Native Interface)라고 함
