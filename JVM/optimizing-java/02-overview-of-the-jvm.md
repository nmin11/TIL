- 자바 기술 플랫폼은 오라클 자료에 따르면 개발자 수가 9백만~1천만 명에 달하는 거대한 기술 플랫폼
- 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계되었음
- 성능에 관심이 있다면 JVM technology stack의 구조를 이해해야 함
- 이 장에서는 JVM이 자바 코드를 실행하는 방법을 소개할 것

## 1. 인터프리팅과 클래스 로딩

- VM 스펙에 따르면 JVM은 스택 기반의 해석 머신
- 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 스택의 맨 위 값들을 가져와 계산

JVM 인터프리터

- 쉽게 보자면 **while 루프 안의 switch문 역할**
- 평가 스택을 이용해 중간값들을 담아둠
- 독립적으로 프로그램을 구성하는 opcode를 하나씩 순서대로 처리
- 실제 제품급 자바 인터프리터는 이보다 훨씬 복잡하지만 우선 이렇게 이해해둘 것

자바 애플리케이션 실행

1. `java HelloWorld` 명령어 실행
2. OS는 가상 머신 프로세스(자바 바이너리)를 구동
3. 자바 가상 환경 구성 및 스택 머신 초기화
4. 실제로 유저가 작성한 `HelloWorld` 클래스 파일 실행

자바 클래스로딩 메커니즘

- 애플리케이션의 entry point는 `HelloWorld.class`의 `main()` 메소드
- 제어권을 클래스로 넘기려면 가상 머신 실행 이전에 클래스를 로드해야 함
- 자바 프로세스가 초기화되면 줄지어 연결된 클래스로더가 차례차례 작동
  - **부트스트랩 클래스로더**
    - 자바 런타임 코어 클래스를 로드
    - 최소한의 필수 클래스(예: `java.lang.Object, Class, Classloader`)만 로드
  - **확장 클래스로더**
    - 필요할 때 클래스로딩 작업을 부모인 부트스트랩 클래스로더에게 넘김
    - 자주 쓰이진 않지만 확장 클래스로더를 통해 특정 OS나 플랫폼에 native code를 제공하고 기본 환경을 오버라이드할 수 있음
  - **애플리케이션 클래스로더**
    - 지정된 클래스패스에 위치한 유저 클래스 로드
    - 확장 클래스로더의 자식이며, 아주 자주 쓰임
- 자바는 프로그램 실행 중 처음 보는 새 클래스를 dependency에 로드
  - 클래스로더는 클래스를 찾지 못하면 기본적으로 부모 클래스로더에게 대신 룩업을 넘김
  - 부트스트랩 클래스로더까지 룩업하지 못하면 `ClassNotFoundException` 발생
- 보통 환경에서 자바는 런타임 환경에서 클래스를 나타내는 `Class` 객체를 만듦
  - 같은 클래스를 서로 다른 클래스로더가 로드할 가능성도 있으니 주의
  - 시스템 안에서 클래스는 _'패키지명을 포함한 풀 클래스명'_ 과 _'자신을 로드한 클래스로더'_ , 2가지 정보로 식별됨

## 2. 바이트코드 실행

- 자바 소스 코드 실행을 위한 변환을 위한 첫 단계는 자바 컴파일러 `javac` 를 이용한 컴파일
- 보통 전체 빌드 프로세스의 한 부분으로 수행
- 자바 소스 코드를 바이트코드인 `.class` 파일로 변경
- 컴파일하면서 최적화는 거의 하지 않기 때문에 결과로 생성된 바이트코드는 쉽게 해독 가능
  - 표준 역어셈블리 툴 `javap` 를 통해 원래의 자바 코드도 어렵지 않게 알아볼 수 있음
- 바이트코드: 컴퓨터 아키텍처를 특정하지 않은 IR(Intermediate Representation)
  - 이식성이 좋기 때문에 JVM 지원 플랫폼 어디서건 실행 가능하고 자바 언어에 대해서도 추상화되어 있음

※ 컴파일러가 생성한 클래스 파일은 VM 명세서에 명확히 정의된 구조를 따름

|         component         |                 description                  |
| :-----------------------: | :------------------------------------------: |
|       magic number        |                 `0xCAFEBABE`                 |
| class file format version |        클래스 파일의 major/minor 버전        |
|       constant pool       |        클래스 상수들이 모여 있는 위치        |
|        access flag        | 추상 클래스, 정적 클래스 등 클래스 종류 표시 |
|        this class         |                현재 클래스명                 |
|        superclass         |                부모 클래스명                 |
|         interface         |       클래스가 구현한 모든 인터페이스        |
|           field           |           클래스에 있는 모든 필드            |
|          method           |          클래스에 있는 모든 메소드           |
|         attribute         |           클래스가 지닌 모든 속성            |

magic number

- 모든 클래스 파일은 이 파일이 클래스 파일임을 나타내는 4byte 16진수 `0xCAFEBABE` 로 시작

class file format version

- 그다음 4byte는 컴파일할 때 꼭 필요한 major/minor 버전 숫자
- 클래스를 실행하는 대상 JVM이 컴파일한 JVM보다 버전이 낮으면 안됨
- 클래스로더의 호환성 보장을 위해 검사
- 호환되지 않는 버전의 클래스 파일을 만나면 런타임에 `UnsupportedClassVersionError` 발생

constant pool

- 클래스명, 인터페이스명, 필드명 등의 상숫값
- JVM은 코드 실행 시 메모리 대신 상수 풀 테이블을 찾아보고 필요한 값을 참조

access flag

- 클래스에 적용하는 수정자 결정
- public class: `ACC_PUBLIC(0x0001)`
- final class: `ACC_FiNAL(0x0010)`
- superclass: `ACC_SUPER(0x0020)`
- interface: `ACC_INTERFACE(0x0200)`
- 추상 클래스: `ACC_ABSTRACT(0x0400)`
- 합성 클래스: `ACC_SYNTHETIC(0x1000)`
- annotation: `ACC_ANNOTATION(0x2000)`
- enum: `ACC_ENUM(0x4000)`

this class / superclass / interface

- 클래스에 포함된 타입 계층을 나타냄
- 각각 상수 풀을 가리키는 인덱스로 표시

field / method

- 시그니처와 비슷한 구조를 정의
- 수정자도 포함

attribute

- 더 복잡하고 크기가 고정되지 않은 구조를 나타내는 데 쓰임

※ [클래스 파일 구조를 이해하기에 좋은 글](https://blog.lse.epita.fr//2014/04/28/0xcafebabe-java-class-file-format-an-overview.html)

## 3. 핫스팟 입문

![hotspot-jvm](https://github.com/nmin11/TIL/assets/75058239/35ed7281-7982-48e7-bc34-c7008cc73b3f)

- 1999년 Sun Microsystems가 핫스팟 가상 머신을 선보인 이후 C/C++에 필적하는 성능을 자랑하게 되었음
- 제로-오버헤드 원칙에 대해
  - 기계에 가까운 언어는 성능을 끌어올릴 수 있음
  - 개발자가 아주 세세한 저수준까지 알아야 함
- 자바는 제로-오버헤드 추상화 철학에 한번도 동조한 적이 없음
- 핫스팟은 프로그램의 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신
- 핫스팟 VM의 목표는 개발자가 억지로 VM 틀에 맞게 개발하는 대신, 자연스럽게 자바 코드를 작성하도록 하는 것

### 3.1 JIT 컴파일이란?

- 네이티브 기능 실행
  - 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작
  - 프로그램이 성능을 최대로 내려면 CPU에서 직접 네이티브 기능을 활용해야 함
- JIT 컴파일: 핫스팟이 프로그램 단위를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일하는 것
- 핫스팟의 인터프리티드 모드
  - 애플리케이션을 모니터링하면서 자주 실행되는 코드 파트를 발견하고 JIT 컴파일 수행
  - 분석하는 동안 미리 프로그래밍 추적 정보가 취합되면서 더 정교한 최적화 수행
  - 특정 메소드가 어느 threshold를 넘어가면 프로파일러가 해당 코드 섹션을 컴파일/최적화
- JIT 컴파일의 이점
  - 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정한다는 것이 가장 큰 장점
  - 핫스팟이 상황별로 수집한 다양한 정보를 토대로 올바른 방향으로 최적화
- PGO (profile-guided optimization)
  - 런타임 정보를 활용해서 **동적 인라이닝** 또는 **가상 호출** 등으로 성능 개선 가능
  - 핫스팟 VM은 시동 시 CPU 타입을 정확히 감지해 가능하면 특정 프로세서의 기능에 맞게 최적화 적용 가능
- 핫스팟 특유의 정교한 접근 방식 덕에 대다수 일반 개발자는 엄청난 혜택을 누리게 되었음
- 그러나 제로-오버헤드 추상화를 포기했기 때문에 '상식적 추론'으로 애플리케이션의 실제 동작을 단순하게 넘겨 짚기 어려움

## 4. JVM 메모리 관리

- 자바는 Garbage Collection 프로세스를 이용해 힙 메모리를 자동 관리
- GC = JVM이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적(Non-deterministic) 프로세스
- GC가 실행되면 애플리케이션 중단되며 중단 시간은 대개 아주 짧음

## 5. 스레딩과 자바 메모리 모델(JMM)

```java
Thread t = new Thread(() -> System.out.println("Hello from new thread"));
t.start();
```

- 자바는 멀티스레드 프로그래밍을 기본 지원
- 그런데 자바 환경 자체가 멀티스레드 기반이기 때문에 프로그램 작동 방식이 복잡하며 성능 분석이 어려움
- 주류 JVM 구현체에서 애플리케이션 스레드는 하나의 전용 OS 스레드에 대응
  - JVM 애플리케이션 스레드의 이면에는 `Thread` 객체의 `start()` 메소드 호출로 생성되는 유일한 OS 스레드가 있다고 보면 됨
- 자바 멀티스레드 방식의 3가지 기본 설계 원칙
  1. 자바 프로세스의 모든 프로세스는 가비지가 수집되는 하나의 공용 힙을 가진다.
  2. 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다.
  3. 기본적으로 객체는 변경 가능하다. 즉, 객체 필드에 할당된 값은 프로그래머가 애써 `final` 키워드로 불변 표시하지 않는 한 바뀔 수 없다.
- JMM: 서로 다른 실행 스레드가 객체 안에 변경되는 값을 어떻게 바라보는지를 기술한 공식 메모리 모델
  - OS 스케줄러가 언제라도 CPU 코어에서 강제로 스레드를 방출할 수 있기 때문에 객체 참조는 의외로 복잡한 문제
  - 상호 베타적 락(mutual exclusion lock): 스레드가 동시에 실행되는 도중 객체 손상을 막는 유일한 방어 장치
    - 실제 애플리케이션에 사용하려면 상당히 복잡해질 수 있음
  - JMM의 상세한 작동 원리, 스레드/락을 다루는 방법은 12장에서

## 6. JVM 구현체 종류

**OpenJDK**

- 자바 기준 구현체(Reference Implementation)를 제공하는 GPL 오픈 소스 프로젝트
- 오라클이 직접 프로젝트 주관/지원
- 자바 릴리즈 기준 발표

**Oracle**

- 가장 널리 알려진 구현체
- OpenJDK 기반
- 오라클 자바의 변경 내용은 거의 전부 OpenJDK에 반영

**Zulu**

- Azul Systems에서 제공하는 OpenJDK 기반 구현체

**IcedTea**

- Red Hat에서 제공하는 OpenJDK 기반 구현체

**Zing**

- Azul Systems에서 제작한 고성능 상용 JVM
- 대용량 힙 메모리와 멀티 CPU 서버급 시스템을 위해 설게된 제품

**J9**

- IBM에서 제공하는 오픈 소스 JVM
- IBM 상용 제품의 근간을 이룸
- 자바 인증 체계와 완전히 호환됨

**Avian**

- 100% 자바 인증을 받은 구현체가 아님
- JVM의 세부 작동 원리를 이해하기 위한 훌륭한 학습 도구 역할

**Android**

- 원래 구글 안드로이드는 non-JVM 용도의 다른 파일 포멧(`.dex`)으로 변환하기 위해 여러 자바 클래스 라이브러리 구현체와 cross compiler를 사용했음
- 근래에는 자체 런타임에서 직접 지원되는 OpenJDK 8 클래스 라이브러리를 사용하는 방향으로 전환하는 추세
- *안드로이드 기술 스택은 JVM 기반의 자바와 다소 거리가 있으므로 이 책에서 안드로이드는 고려 대상에서 제외*

### 6.1 JVM 라이선스

- JVM 구현체는 거의 다 오픈 소스
- IBM J9, Azul Zing을 제외하면 대부분 핫스팟(GPL) 기반
- 오라클 라이선스 체계는 복잡함
  - 오라클 JDK와 OpenJDK는 라이선스 외에는 아무런 차이가 없음
  - 그래도 OpenJDK 컨트리뷰터는 이중 라이선스에 동의한다는 서명을 해야 함
  - 오라클 라이선스에서 눈여겨봐야 할 조항
    - 회사 밖으로 오라클 바이너리를 재배포하는 행위는 허용되지 않는다.
    - 사전 동의 없이 오라클 바이너리를 함부로 패치하면 안 된다.

## 7. JVM 모니터링과 툴링

instrumentation, 모니터링, 관측을 위한 기술들

- JMX(Java Management Extension)
- Java agent
- JVMTI(Java Virtual Machine Tool Interface)
- SA(Serviceability Agent)

**JMX**

- JVM과 그 위에서 동작하는 애플리케이션을 제어하고 모니터링하는 강력한 범용 툴
- 클라이언트와 같이 메소드를 호출하고 매개변수를 바꿀 수 있음
- JVM을 관리하는 기본 수단

**Java agent**

- `java.lang.instrument` 인터페이스로 메소드 바이트코드를 조작
- JVM에 아래와 같이 시작 플래그를 추가해서 설치

```bash
java -javaagent:myagent.jar
```
- 에이전트 JAR 파일에서 `manifest.mf` 파일에 `Premain-Class` 속성에 에이전트 클래스명을 반드시 지정해야 함
  - 지정한 클래스는 자바 에이전트 registration hook 역할을 수행하는 `public static void premain(String agentArgs, Instrumentation inst)` 메소드를 반드시 포함해야 함

**JVMTI**

- JVM의 네이티브 인터페이스
  - JVMTI를 사용하는 에이전트는 C/C++ 같은 네이티브 컴파일 언어로 작성해야 함
- 네이티브 에이전트가 JVM 이벤트를 모니터링하며 알림을 받을 수 있도록 만든 통신 인터페이스

```bash
java -agentlib:myagent
```

```bash
java -agentpath:myagent.so
```

- JVMTI 에이전트는 네이티브 코드로 개발해야 하는 요건 때문에 애플리케이션에 악영향을 주게 될 수도 있음
- 가급적이면 Java agent로 작성하는 것이 나음

**SA**

- 자바 객체, 핫스팟 자료 구조를 모두 조사할 수 있는 API 및 툴
- 대상 JVM에서 코드를 실행할 필요가 없음
- 핫스팟 SA는 symbol lookup 같은 기본형을 이용하거나 프로세스 메모리를 읽는 방식으로 디버깅
- 코어 파일 및 자바 프로세스 디버깅

### 7.1 VisualVM

- 자바에 내장된 LTS 버전의 VisualVM을 사용하거나, 아니면 [VisualVM 홈페이지](https://visualvm.github.io/)에서 다운로드 가능
  - 직접 다운로드한 경우 `visualvm` 경로 설정 필요
- attach mechanism을 이용해 실행 프로세스를 실시간 모니터링
- 프로세스가 로컬인지, 원격인지에 따라 작동 방식이 다름
  - 로컬 프로세스: 화면 좌측에 프로세스가 나열되고 그중 하나를 클릭하기만 하면 됨
  - 원격 프로세스: remote로부터 JMX 인바운드가 허용돼야 함
    - 표준 자바 프로세스라면 remote의 `jstatd` 실행 여부를 확인할 것
- 플러그인을 통해 다양한 기능 확장 가능

**Overview**

- 자바 프로세스에 관한 요약 정보
- 프로세스에 전달한 전체 플래그, 시스템 프로퍼티, 실행 중인 자바 버전

**Monitor**

- CPU, 힙 사용량 등 JVM을 고수준에서 원격 측정한 값들 표시
- 로드/언로드된 클래스 수, 스레드 수 등

**Threads**

- 실행 중인 애플리케이션 각 스레드가 시간대별로 표시됨
- 필요시 thread dump 생성 가능

**Sampler**

- CPU 및 메모리 사용률에 관한 단순 샘플링 결과 표시
