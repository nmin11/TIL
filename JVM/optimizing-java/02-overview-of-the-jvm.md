- 자바 기술 플랫폼은 오라클 자료에 따르면 개발자 수가 9백만~1천만 명에 달하는 거대한 기술 플랫폼
- 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계되었음
- 성능에 관심이 있다면 JVM technology stack의 구조를 이해해야 함
- 이 장에서는 JVM이 자바 코드를 실행하는 방법을 소개할 것

## 1. 인터프리팅과 클래스 로딩

- VM 스펙에 따르면 JVM은 스택 기반의 해석 머신
- 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 스택의 맨 위 값들을 가져와 계산

JVM 인터프리터

- 쉽게 보자면 **while 루프 안의 switch문 역할**
- 평가 스택을 이용해 중간값들을 담아둠
- 독립적으로 프로그램을 구성하는 opcode를 하나씩 순서대로 처리
- 실제 제품급 자바 인터프리터는 이보다 훨씬 복잡하지만 우선 이렇게 이해해둘 것

자바 애플리케이션 실행

1. `java HelloWorld` 명령어 실행
2. OS는 가상 머신 프로세스(자바 바이너리)를 구동
3. 자바 가상 환경 구성 및 스택 머신 초기화
4. 실제로 유저가 작성한 `HelloWorld` 클래스 파일 실행

자바 클래스로딩 메커니즘

- 애플리케이션의 entry point는 `HelloWorld.class`의 `main()` 메소드
- 제어권을 클래스로 넘기려면 가상 머신 실행 이전에 클래스를 로드해야 함
- 자바 프로세스가 초기화되면 줄지어 연결된 클래스로더가 차례차례 작동
  - **부트스트랩 클래스로더**
    - 자바 런타임 코어 클래스를 로드
    - 최소한의 필수 클래스(예: `java.lang.Object, Class, Classloader`)만 로드
  - **확장 클래스로더**
    - 필요할 때 클래스로딩 작업을 부모인 부트스트랩 클래스로더에게 넘김
    - 자주 쓰이진 않지만 확장 클래스로더를 통해 특정 OS나 플랫폼에 native code를 제공하고 기본 환경을 오버라이드할 수 있음
  - **애플리케이션 클래스로더**
    - 지정된 클래스패스에 위치한 유저 클래스 로드
    - 확장 클래스로더의 자식이며, 아주 자주 쓰임
- 자바는 프로그램 실행 중 처음 보는 새 클래스를 dependency에 로드
  - 클래스로더는 클래스를 찾지 못하면 기본적으로 부모 클래스로더에게 대신 룩업을 넘김
  - 부트스트랩 클래스로더까지 룩업하지 못하면 `ClassNotFoundException` 발생
- 보통 환경에서 자바는 런타임 환경에서 클래스를 나타내는 `Class` 객체를 만듦
  - 같은 클래스를 서로 다른 클래스로더가 로드할 가능성도 있으니 주의
  - 시스템 안에서 클래스는 _'패키지명을 포함한 풀 클래스명'_ 과 _'자신을 로드한 클래스로더'_ , 2가지 정보로 식별됨
