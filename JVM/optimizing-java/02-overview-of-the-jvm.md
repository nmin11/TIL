- 자바 기술 플랫폼은 오라클 자료에 따르면 개발자 수가 9백만~1천만 명에 달하는 거대한 기술 플랫폼
- 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계되었음
- 성능에 관심이 있다면 JVM technology stack의 구조를 이해해야 함
- 이 장에서는 JVM이 자바 코드를 실행하는 방법을 소개할 것

## 1. 인터프리팅과 클래스 로딩

- VM 스펙에 따르면 JVM은 스택 기반의 해석 머신
- 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 스택의 맨 위 값들을 가져와 계산

JVM 인터프리터

- 쉽게 보자면 **while 루프 안의 switch문 역할**
- 평가 스택을 이용해 중간값들을 담아둠
- 독립적으로 프로그램을 구성하는 opcode를 하나씩 순서대로 처리
- 실제 제품급 자바 인터프리터는 이보다 훨씬 복잡하지만 우선 이렇게 이해해둘 것

자바 애플리케이션 실행

1. `java HelloWorld` 명령어 실행
2. OS는 가상 머신 프로세스(자바 바이너리)를 구동
3. 자바 가상 환경 구성 및 스택 머신 초기화
4. 실제로 유저가 작성한 `HelloWorld` 클래스 파일 실행

자바 클래스로딩 메커니즘

- 애플리케이션의 entry point는 `HelloWorld.class`의 `main()` 메소드
- 제어권을 클래스로 넘기려면 가상 머신 실행 이전에 클래스를 로드해야 함
- 자바 프로세스가 초기화되면 줄지어 연결된 클래스로더가 차례차례 작동
  - **부트스트랩 클래스로더**
    - 자바 런타임 코어 클래스를 로드
    - 최소한의 필수 클래스(예: `java.lang.Object, Class, Classloader`)만 로드
  - **확장 클래스로더**
    - 필요할 때 클래스로딩 작업을 부모인 부트스트랩 클래스로더에게 넘김
    - 자주 쓰이진 않지만 확장 클래스로더를 통해 특정 OS나 플랫폼에 native code를 제공하고 기본 환경을 오버라이드할 수 있음
  - **애플리케이션 클래스로더**
    - 지정된 클래스패스에 위치한 유저 클래스 로드
    - 확장 클래스로더의 자식이며, 아주 자주 쓰임
- 자바는 프로그램 실행 중 처음 보는 새 클래스를 dependency에 로드
  - 클래스로더는 클래스를 찾지 못하면 기본적으로 부모 클래스로더에게 대신 룩업을 넘김
  - 부트스트랩 클래스로더까지 룩업하지 못하면 `ClassNotFoundException` 발생
- 보통 환경에서 자바는 런타임 환경에서 클래스를 나타내는 `Class` 객체를 만듦
  - 같은 클래스를 서로 다른 클래스로더가 로드할 가능성도 있으니 주의
  - 시스템 안에서 클래스는 _'패키지명을 포함한 풀 클래스명'_ 과 _'자신을 로드한 클래스로더'_ , 2가지 정보로 식별됨

## 2. 바이트코드 실행

- 자바 소스 코드 실행을 위한 변환을 위한 첫 단계는 자바 컴파일러 `javac` 를 이용한 컴파일
- 보통 전체 빌드 프로세스의 한 부분으로 수행
- 자바 소스 코드를 바이트코드인 `.class` 파일로 변경
- 컴파일하면서 최적화는 거의 하지 않기 때문에 결과로 생성된 바이트코드는 쉽게 해독 가능
  - 표준 역어셈블리 툴 `javap` 를 통해 원래의 자바 코드도 어렵지 않게 알아볼 수 있음
- 바이트코드: 컴퓨터 아키텍처를 특정하지 않은 IR(Intermediate Representation)
  - 이식성이 좋기 때문에 JVM 지원 플랫폼 어디서건 실행 가능하고 자바 언어에 대해서도 추상화되어 있음

※ 컴파일러가 생성한 클래스 파일은 VM 명세서에 명확히 정의된 구조를 따름

|         component         |                 description                  |
| :-----------------------: | :------------------------------------------: |
|       magic number        |                 `0xCAFEBABE`                 |
| class file format version |        클래스 파일의 major/minor 버전        |
|       constant pool       |        클래스 상수들이 모여 있는 위치        |
|        access flag        | 추상 클래스, 정적 클래스 등 클래스 종류 표시 |
|        this class         |                현재 클래스명                 |
|        superclass         |                부모 클래스명                 |
|         interface         |       클래스가 구현한 모든 인터페이스        |
|           field           |           클래스에 있는 모든 필드            |
|          method           |          클래스에 있는 모든 메소드           |
|         attribute         |           클래스가 지닌 모든 속성            |

magic number

- 모든 클래스 파일은 이 파일이 클래스 파일임을 나타내는 4byte 16진수 `0xCAFEBABE` 로 시작

class file format version

- 그다음 4byte는 컴파일할 때 꼭 필요한 major/minor 버전 숫자
- 클래스를 실행하는 대상 JVM이 컴파일한 JVM보다 버전이 낮으면 안됨
- 클래스로더의 호환성 보장을 위해 검사
- 호환되지 않는 버전의 클래스 파일을 만나면 런타임에 `UnsupportedClassVersionError` 발생

constant pool

- 클래스명, 인터페이스명, 필드명 등의 상숫값
- JVM은 코드 실행 시 메모리 대신 상수 풀 테이블을 찾아보고 필요한 값을 참조

access flag

- 클래스에 적용하는 수정자 결정
- public class: `ACC_PUBLIC(0x0001)`
- final class: `ACC_FiNAL(0x0010)`
- superclass: `ACC_SUPER(0x0020)`
- interface: `ACC_INTERFACE(0x0200)`
- 추상 클래스: `ACC_ABSTRACT(0x0400)`
- 합성 클래스: `ACC_SYNTHETIC(0x1000)`
- annotation: `ACC_ANNOTATION(0x2000)`
- enum: `ACC_ENUM(0x4000)`

this class / superclass / interface

- 클래스에 포함된 타입 계층을 나타냄
- 각각 상수 풀을 가리키는 인덱스로 표시

field / method

- 시그니처와 비슷한 구조를 정의
- 수정자도 포함

attribute

- 더 복잡하고 크기가 고정되지 않은 구조를 나타내는 데 쓰임

※ [클래스 파일 구조를 이해하기에 좋은 글](https://blog.lse.epita.fr//2014/04/28/0xcafebabe-java-class-file-format-an-overview.html)

## 3. 핫스팟 입문

(이미지 첨부 - hotspot-jvm)

- 1999년 Sun Microsystems가 핫스팟 가상 머신을 선보인 이후 C/C++에 필적하는 성능을 자랑하게 되었음
- 제로-오버헤드 원칙에 대해
  - 기계에 가까운 언어는 성능을 끌어올릴 수 있음
  - 개발자가 아주 세세한 저수준까지 알아야 함
- 자바는 제로-오버헤드 추상화 철학에 한번도 동조한 적이 없음
- 핫스팟은 프로그램의 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신
- 핫스팟 VM의 목표는 개발자가 억지로 VM 틀에 맞게 개발하는 대신, 자연스럽게 자바 코드를 작성하도록 하는 것

### 3.1 JIT 컴파일이란?

- 네이티브 기능 실행
  - 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작
  - 프로그램이 성능을 최대로 내려면 CPU에서 직접 네이티브 기능을 활용해야 함
- JIT 컴파일: 핫스팟이 프로그램 단위를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일하는 것
- 핫스팟의 인터프리티드 모드
  - 애플리케이션을 모니터링하면서 자주 실행되는 코드 파트를 발견하고 JIT 컴파일 수행
  - 분석하는 동안 미리 프로그래밍 추적 정보가 취합되면서 더 정교한 최적화 수행
  - 특정 메소드가 어느 threshold를 넘어가면 프로파일러가 해당 코드 섹션을 컴파일/최적화
- JIT 컴파일의 이점
  - 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정한다는 것이 가장 큰 장점
  - 핫스팟이 상황별로 수집한 다양한 정보를 토대로 올바른 방향으로 최적화
- PGO (profile-guided optimization)
  - 런타임 정보를 활용해서 **동적 인라이닝** 또는 **가상 호출** 등으로 성능 개선 가능
  - 핫스팟 VM은 시동 시 CPU 타입을 정확히 감지해 가능하면 특정 프로세서의 기능에 맞게 최적화 적용 가능
- 핫스팟 특유의 정교한 접근 방식 덕에 대다수 일반 개발자는 엄청난 혜택을 누리게 되었음
- 그러나 제로-오버헤드 추상화를 포기했기 때문에 '상식적 추론'으로 애플리케이션의 실제 동작을 단순하게 넘겨 짚기 어려움
