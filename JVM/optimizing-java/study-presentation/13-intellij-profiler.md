## 취지

- 상용 툴을 학습 단계나 사이드 프로젝트에서 사용하기엔 무리
- 어짜피 상용 툴의 적용 방법은 대부분 java agent를 부착하는 방식
- 오픈 소스인 perf 를 활용하는 방식은 복잡한 느낌
- 간단하게 사용할 수 있는 프로파일러를 사용해보면서 프로파일링 개념 및 방법을 숙지해보자

## IntelliJ Profiler 소개

- CPU, 메모리 할당 프로파일링을 위한 단순하지만 강력한 툴
- 2개의 유명한 자바 프로파일러인 JFR(Java Flight Recorder), Async Profiler 를 결합한 툴
- 주 관심사는 편한 사용성!
  - 복잡한 설정 없이 몇번의 클릭만으로 프로파일링을 할 수 있게 해줌
- 다른 프로세서에도 쉽게 연결할 수 있고 해당 프로세서에 대한 스냅샷을 저장할 수도 있음
- **flame graph** 기능을 통해 다양한 접근 방식의 성능을 빠르고 효과적으로 분석할 수 있음
- Windows, macOS, Linux 지원

## Flame Graph

- y축: 스택의 깊이
- x축: 샘플 모집단
- 모든 직사각형은 함수 이름을 나타냄
  - 파란색 직사각형: native calls
  - 노란색 직사각형: java calls
  - 보라색 직사각형: library calls
- 시계열이 아님 (애플리케이션에서 메소드를 호출하는 순서를 표시하는 게 아님)
- 각 블록들은 상대적이며, CPU 스냅샷에서의 총 사용 시간을 나타냄
- 한번 실행하는데 오래 걸린 게 아니라 여러 번 호출되어서 비율이 높을 수도 있음

## Call Tree

- flame graph를 텍스트 형식으로 표현한 것
- 메소드들이 어떻게 호출되었고, CPU 시간을 얼만큼 사용했는지 표현
- 어떤 메소드 실행 경로가 느린지 검토해보고, 중요한 실행 경로를 조정하는데 도움이 됨

## Method List

- 프로파일할 때 실행된 메소드 목록을 보여줌
- IntelliJ IDEA에서 메소드를 클릭하면 해당 메소드의 소스 코드로 이동할 수 있음

## Events

- 클래스 로딩, GC, OS 이벤트 같은 JVM 이벤트를 보여줌

## Live Chart

- 실행 중인 프로세스에 대해 실시간 성능 통계를 보여줌
- `Perform GC` 버튼을 누르면 GC를 수동으로 실행할 수 있음
- CPU: CPU 사용률
- Heap Memory: 힙 메모리 사용률 (현재 사용량 / 최대 힙 사이즈)
- Threads: 활성 스레드 수
  - 노란색: 전체 스레드 개수
  - 빨간색: 데몬 스레드 개수
- Non-Heap Memory: 힙 메모리를 제외한 메모리 사용률
  - JVM 작동에 필요한 JVM 객체 저장 용도
