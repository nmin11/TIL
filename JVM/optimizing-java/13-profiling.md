- 프로파일링의 핵심 주제 2가지
  - **실행**
  - **할당**

13장에서는...

- 애플리케이션을 프로파일링하는 툴 소개
- 메모리 프로파일링 관련 기능을 제공하는 툴 소개

## 1. 프로파일링 개요

instrumentation

- JVM 프로파일링/모니터링 툴은 보통 저수준의 instrumentation을 사용
  - instrumentation: 프로그램의 여러 지점에 계측 행위를 끼워넣는 기술
- 수집한 데이터는 그래픽 콘솔에 피드백하거나 추후 분석 용도로 로그 저장
- 대부분 애플리케이션 시작 시 로드되는 agent나 실행 중인 JVM에 동적으로 부착하는 컴포넌트 형태로 구현
- 모니터링 툴, 경고 시스템, 프로파일러를 명확히 구분해야 함
- 프로파일링의 목표: 리팩토링 및 성능 최적화 대상 코드를 식별하는 것
- 성능 진단의 첫 단계: 문제를 일으키는 리소스를 찾아내는 것

## 2. 샘플링과 세이프포인팅 편향

- data point, stack trace는 대부분 샘플링을 통해 획득
- 데이터 수집 비용을 아끼기 위해 메소드 입출구는 보통 추적하지 않음
- 대신 스레드 실행 스냅샷을 낮은 빈도로 찍음
  - new relic thread profiler는 100ms마다 샘플링 (최적의 주기로 알려져 있음)

safepointing bias

- 대부분의 샘플링이 세이프포인트에서만 일어난다는 문제점
- 모든 스레드는 샘플을 뜨기 전에 세이프포인트에 다다라야 함
  - 모든 스레드를 세이프포인트에 두기 위한 오버헤드 가중
- 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링 가능
  - 표본점 분포가 왜곡될 소지가 있음

`GetCallTree()`

- 실행 프로파일러는 대부분 핫스팟 C++ API에 있는 `GetCallTree()`를 사용해서 스레드의 스택 샘플 수집
- 일반적으로 agent 내부에서 샘플을 채취한 다음, 데이터를 로깅하거나 다른 프로세스로 전송
- 하지만 오버헤드가 만만치 않음
  - 활성 스레드가 N개면 스택 샘플을 수집할 때 JVM이 세이프포인트를 N번 해야 함

세이프포인팅 시간

- 성능 문제를 진단할 때 세이프포인팅 시간을 예의주시해야 함
- 세이프포인팅 시간이 높은 경우 아래의 JVM 플래그를 사용해서 추적해볼 것
  - GC 로그에 세이프포인팅 시간에 관한 추가 정보 로깅
  - 툴을 활용해서 세이프포인팅 시간과 OS 커널 중단 시간을 구분할 수도 있음

```bash
java -XX:+PrintGCApplicationStoppedTime
```
