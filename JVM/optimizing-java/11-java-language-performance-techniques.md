## 1. 컬렉션 최적화

대부분의 프로그래밍 언어 라이브러리에서 제공하는 최소 2개의 컨테이너

- sequence container: 인덱스로 표기한 특정 위치에 객체 저장
- associative container: 객체 자체를 이용해 컬렉션 내부에 저장할 위치 결정

호환성과 동등성

- 컨테이너에서 메소드가 정확히 작동하려면 저장할 객체가 호환성과 동등성 개념을 지니고 있어야 함
- 코어 자바 API 컬렉션에서는 모든 객체가 반드시 `equals`와 `hashCode` 메소드를 구현해야 한다고 표현

컬렉션 API

![collection-api](https://github.com/nmin11/TIL/assets/75058239/e5c6f8e3-3a8a-43dd-84df-ffc197335bef)

- 타입별로 컨테이너가 준수해야 할 작업을 구체적으로 명시한 인터페이스 모음
- JDK에는 인터페이스 말고도 다양한 컬렉션 구현체가 들어 있음

## 2. List 최적화

List 구현체

- **ArrayList**
- **LinkedList**
- Stack: 쓸데없는 추가 로직만 있음
- Vector: deprecated

### 2.1 ArrayList

- 고정 크기 배열에 기반한 리스트
- 배킹 배열의 최대 크기만큼 원소 추가 가능, 배열이 꽉 차면 더 큰 배열을 새로 할당한 후 기존 원소 복사
  - 처음에 빈 배열로 시작하고, 첫 원소가 추가될 때 크기 10의 배열을 할당
- 따라서 크기 조정 작업 비용이 성능 측정의 중요한 요소
- 초기 용량값을 생성자에 전달해서 크기 조정을 최소화하자!
  - `new ArrayList<>(1000)`
  - `ensureCapacity` 메소드를 활용하는 방법도 있음

### 2.2 LinkedList

- 동적으로 증가하는 리스트
- doubly linked list로 구현되어 있어서 추가 작업은 항상 O(1)

### 2.3 ArrayList vs LinkedList

- 리스트의 끝에 원소를 추가하는 작업은 동일 (ArrayList의 크기 조정 작업이 없다고 가정할 때)
- 중간 원소 삽입
  - ArrayList는 해당 인덱스 다음 원소들을 모두 한 칸씩 뒤로 밀어야 함
  - LinkedList는 삽입 지점을 찾기 위해 노드 레퍼런스를 쭉 따라가는 작업이 필요하지만 연결 작업은 간단
- 중간 원소 삭제
  - ArrayList는 해당 인덱스 다음 원소들을 모두 한 칸씩 앞으로 당겨야 함
  - LinkedList는 레퍼런스 2개만 바꾸면 됨
- 액세스 성능
  - ArrayList는 인덱스로 바로 접근 가능 O(1)
  - LinkedList는 처음부터 인덱스 카운트만큼 원소를 방문해야 함 O(n)
- 액세스 성능을 위해 ArrayList를 사용하고, 중간 삽입/삭제가 많은 경우 LinkedList를 사용하자
  - ArrayList는 가급적 미리 크기를 정해두자

## 3. Map 최적화

- `java.util.Map<K, V>` 인터페이스는 키/값 모두 반드시 참조형이어야 함

### 3.1 HashMap

- 버킷 엔트리를 리스트에 저장
- 값을 찾을 때 키 해시값을 계산하고 `equals` 메소드로 리스트에서 해당 키를 찾음
- 키 해시값에 대한 동등성을 기준으로 리스트에서 값을 찾는 메커니즘이므로 키 중복은 허용되지 않음

`initialCapacity` & `loadFactor`

- HashMap의 성능에 가장 큰 영향을 미치는 매개변수들
- `initialCapacity`: 버킷 배열의 초기 크기
  - default: 16
- `loadFactor`: 버킷 배열이 얼마나 차있어야 배열 크기를 두 배로 늘릴지 결정
  - default: 0.75
  - 0.75 * 16 = 12개의 엔트리가 채워지면 배열 크기를 2배로 늘림
- **rehash**: 용량을 2배 늘리고 저장된 데이터를 다시 배치한 다음, 해시를 다시 계산하는 과정
- ArrayList와 마찬가지로 초기 용량을 미리 정해두자

순회 작업

- initialCapacity와 loadFactor가 높으면 순회 작업에 상당한 영향을 미침

treeify

- 최근에 HashMap 내부에 구현된 기술
- 하나의 버킷에 TREEIFY_THRESHOLD 설정 개수만큼 키/값 쌍이 모이면 버킷을 TreeNode로 변환
  - 마치 TreeMap처럼 작동하게 됨
- 아예 처음부터 바꾸면 안 되나?
  - TreeNode는 리스트 노드보다 약 2배 더 큰 공간을 차지
  - 값이 고루 잘 분포되는 해시 함수를 쓰면 버킷을 TreeNode로 바꿀 일이 거의 없음

**LinkedHashMap**

- HashMap의 서브클래스
- 이중 연결 리스트를 사용해 원소의 삽입 순서를 관리
- 기본 관리 모드는 insertion-order이지만 access-order로 바꿀 수 있음
  - access-order: 가장 최근에 접근한 원소를 가장 뒤로 보냄
- 순서가 중요한 코드에서 많이 쓰이고, TreeMap처럼 비용이 많이 들지 않음
- Map을 사용할 때 대부분 삽입/접근 순서는 딱히 중요하지 않기 때문에 사용하는 경우가 드문 편

### 3.2 TreeMap

- red-black tree로 구현된 Map
  - red-black tree: 기본 이진 트리 구조에 메타데이터를 node coloring해서 균형을 유지하는 트리
- 다양한 키가 필요할 때 유용
- 서브맵에 신속히 접근 가능
- 처음부터 특정 지점까지, 혹은 특정 지점부터 끝까지 데이터를 분할하는 용도
- `get` `put` `containsKey` `remove` 메소드의 시간 복잡도는 O(log n)
- 실제로 대부분의 요건은 HashMap만으로도 충분하지만, 스트림이나 람다로 Map 일부를 처리해야 할 때 TreeMap을 사용하면 좋음

### 3.3 MultiMap은 없어요

- 자바는 하나의 키에 여러 값을 묶는 MultiMap을 제공하지 않음
- 사용할 일이 드믈고 대부분 `Map<K, List<V>>` 형태로도 충분히 구현 가능

## 4. Set 최적화

- Set에 대한 성능 관련 고려사항은 Map과 비슷
  - 실제로 HashSet은 HashMap을 이용해 구현되어 있음
- Set은 Map의 키 원소와 같이 중복을 허용하지 않음

## 5. 도메인 객체

- 도메인 객체 = 애플리케이션에 유의미한 비즈니스 컨셉을 표현하는 객체
- 대부분 타입 간 연관관계가 있음
- 메모리 누수 같은 버그를 찾는 과정에서 쉽게 눈에 뜨임
- 자바 힙에 관한 기본적인 팩트
  - 가장 흔히 할당되는 자료 구조는 String, char[], byte[], 자바 컬렉션 타입 인스턴스
  - jmap에서 누수되는 데이터는 비정상적으로 비대한 데이터셋으로 나타남
- 도메인 객체가 jmap 결과치 상위 30위 정도 안에 든다면 메모리 누수가 발생한 신호라고 볼 수 있음

all generations 효과

- 특정 타입의 객체가 수집되어야 할 시점에서 수집되지 않을 경우 세대 카운트 값을 지닌 채 테뉴어드 세대까지 살아남을 것
- 그 결과 도메인 객체가 전체 세대에 걸쳐 분포
- 대처 방법: 도메인 객체에 대응되는 데이터셋의 크기가 적당한지, working set에 존재하는 도메인 객체 수가 적당한지 확인

부유 가비지 문제

- 단명 도메인 객체는 부유 가비지 문제를 일으키는 원인이 될 수 있음

도메인 객체 정리

- 많은 애플리케이션에서 도메인 객체는 '탄광 속 카나리아' 같은 역할을 수행
- 비즈니스 관심사를 가장 분명하게, 자연스럽게 나타낸 객체라서 메모리 누수에 더 취약
- 도메인 객체에 알맞은 크기의 작업 세트가 배정되도록 해야 함

## 6. 종료화 안 하기

`finalize`

- C++의 RAII(Resource Acquisition Is Initialization) 패턴과 같이 자동으로 리소스를 관리하기 위해 만든 장치
  - 객체 초기화 시 가장 중요한 작업은 자원 획득이라는 의미
- RAII 패턴에는 객체를 해체할 때 자동으로 리소스를 해체/정리하는 메소드가 있음
- RAII는 다른 말로 ARM(Automatic Resource Management)이라고도 함
- 객체가 지닌 리소스를 자동으로 없애는 일을 프로그래머가 아닌 플랫폼이 하도록 하자!

### 6.2 왜 종료화로 문제를 해결하지 않을까?

- Object의 `finalize` 메소드는 자바 태동기부터 있던 no-op 메소드
  - 오버라이드해서 특정 로직을 부여할 수 있음
  - GC가 객체를 수집할 때 호출됨

종료화 대상으로 등록된 객체의 수명 연장 방식

1. 종료화 가능 객체는 큐로 이동
2. 애플리케이션 스레드 재시작 후, 종료화 스레드가 큐를 비우고 각 개체마다 `finalize` 메소드를 실행
3. `finalize` 메소드가 실행되면 객체는 다음 사이클에 진짜 수집될 준비를 마침

⇒ 종료화 가능 객체는 적어도 한번의 GC 사이클을 더 겪게 됨 (테뉴어드 세대인 경우 상당히 긴 시간이 될 수도 있음)

종료화 스레드의 예외 발생 문제

- 종료화 도중 발생한 예외는 개발자가 어떻게 할 수 없음
- JVM이 새 스레드를 생성/실행하는 오버헤드를 감수해야 함

자바의 종료화는 당초 의도한 목적과는 다르게 사용되고 있다

- GC는 정해진 시간에 실행되는 법이 없으므로 종료화를 통해 자동으로 리소스를 관리한다는 것은 불가능
- 리소스 해제와 객체 수명을 엮는 장치가 따로 없으므로 항상 리소스가 고갈될 위험에 노출되어 있음
- 그래서 Oracle은 일반 애플리케이션 코드에 종료화를 사용하지 말라고 권고하고 있음

### 6.3 try-with-resources

```java
public void readFirstLineNew(File file) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(file))) {
        String FirstLine = br.readLine();
        System.out.println(FirstLine);
    }
}
```

- 자바 7부터 추가된 기능
- `AutoCloseable` 인터페이스를 구현한 객체를 사용할 때 `try-with-resources` 구문을 사용하면 자동으로 리소스를 해제할 수 있음
- 더욱 캡슐화되고 버그 없는 코드를 작성할 수 있음
- C++ RAII 패턴과 유사한 코드 구현 시 강력히 추천하는 베스트 프랙티스
- 블록 범위 코드에만 쓸 수 있다는 제약은 존재

종료화 정리

- 종료화는 GC에 의존하고 GC는 불확정적 프로세스이기 때문에 리소스 관리를 비롯한 대부분의 경우 원래 의도와 맞지 않다
- 종료화에 의존하는 객체가 언제 리소스 해제될지 아무런 보장이 없다
- **절대로 `finalize` 메소드를 오버라이드해서 사용하지 말자**

## 7. 메서드 핸들

`invokedynamic`

- 자바 7부터 추가된 기능
- 이 명령어 덕분에 호출부에서 실행할 메소드를 유연하게 결정할 수 있음
- 핵심은 런타임에 메소드를 결정할 수 있다는 점
- 호출부가 인터프리터에 이르면 특수 보조 메소드 BSM(Bootstrap Method)를 호출하고, BSM은 호출할 실제 메소드를 가리키는 객체 반환
- 이 객체를 호출 대상이라고 하며, 호출부 내부에서 'laced into' 되었다고 표현

method handle

- invokedynamic 호출부에 의해 호출되는 메소드를 나타낸 객체
- reflection과 비슷한 개념이지만 더 빠르고 유연
- 자바 7부터 일부 클래스, `java.lang.invoke.MethodHandle` 패키지가 추가되어 실행 가능한 메소드의 레퍼런스를 직접 반영할 수 있게 되었음
  - 하부 메소드를 실행할 수 있는 다양한 메소드가 메소드 핸들 객체에 내장되어 있음
  - 그중 `invoke` 메소드가 제일 많이 쓰임
- 안정된 불변 객체라서 보관, 캐시하기에 용이

lookup context

- `MethodHandles.lookup` 메소드를 호출해 컨텍스트 객체 생성
- 위 메소드가 반환한 불변 객체에는 컨텍스트 객체 생성 시점의 액세스 가능 메소드 및 필드를 기록한 상태 정보가 있음
- 이러한 유연성 덕에 private 메소드에 선택적으로 액세스할 수 있음
- reflection의 경우 private 메소드에 액세스하려면 `setAccessible` 메소드를 호출해야 하므로 액세스 제어 체계에 큰 허점을 노출시킴

메소드 추론

- `invoke` 호출은 모든 인수를 두루 받아들이는 만능 호출이 아닌, 런타임에 호출돼야 할 메소드의 예상 시그니처를 기술
- javac는 호출에 적합한 타입 시그니처를 알아서 추론
- JVM 런타임은 메소드 호출을 있는 그대로 연결
  - 런타임에 메소드 핸들이 정확한 시그니처를 반영하고 `invoke` 호출이 기본적으로 하부 메소드를 대신 호출하는 코드로 치환되리라 예상
- 이와 같이 기괴한 특징(시그니처 다형성)은 오직 메소드 핸들에만 적용됨

쉬운 설명 버전

- 메소드 핸들은 코어 리플렉션과 기능은 비슷하지만 최대한 정적 타입을 안전하게 지키는 요즘 방식의 리플렉션
