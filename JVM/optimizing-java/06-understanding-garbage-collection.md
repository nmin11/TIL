가비지 수집 구현체의 2가지 기본 원칙

1. **알고리즘은 반드시 모든 가비지를 수집해야 한다.**
2. **살아 있는 객체는 절대로 수집해선 안 된다.**

6장에서는...

- 자바 가비지 수집의 기초 이론 소개
- 자바 플랫폼에서 가비지 수집을 완전히 이해/제어하기 어려운 이유에 대해
- 핫스팟이 런타임에 객체를 힙에 나타내는 방법 및 기본 특성
- 병렬 수집기 소개
  - 핫스팟에서 가장 단순한 상용 수집기
  - 다양한 워크로드에서의 쓰임새에 대해

## 1. 마크 앤 스위프

GC 알고리즘의 전체적인 과정

1. allocated list를 순회하면서 mark bit를 지움
2. GC 루트부터 살아 있는 객체 찾기
3. 찾은 객체마다 mark bit 세팅
4. allocated list를 순회하면서 mark bit가 세팅되지 않은 객체 찾기
   - 힙에서 메모리를 회수해 free list에 되돌림
   - allocated list에서 객체를 제거

- 살아 있는 객체는 대부분 DFS로 찾음
- live object graph: 살아 있는 객체들의 그래프
  - transitive closure of reachable objects 라고도 불림
- 힙 상태는 시각화해서 보기 어려움
  - `jmap -histo` 명령어로 타입별 할당된 바이트 수와, 해당 메모리를 차지하는 전체 인스턴스 개수 확인 가능

### 1.1 가비지 수집 용어

**STW**

- Stop The World
- GC 사이클 동안 모든 애플리케이션 스레드가 일시 중단되는 시간
- 애플리케이션 스레드가 멈춰야 살아 있는 객체를 정확히 식별할 수 있기 때문

**동시**

- GC 스레드는 애플리케이션 스레드와 동시(병행) 실행될 수 있음
- 아주 어렵고 비싼 작업인 데다 100% 동시 실행을 보장할 수는 없음

**병렬**

- 여러 스레드를 동원해서 가비지 수집

**정확**

- GC 스킴은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지님

**보수**

- 보수적인 스킴은 정확한 정보가 없어서 리소스를 낭비하는 일이 잦고 타입 체계를 무시하므로 훨씬 비효율적

**이동**

- 이동 수집기에서 객체는 메모리를 여기저기 이동할 수 있음
- 객체 주소가 고정 도니 것이 아님
- raw pointer로 직접 액세스하는 환경은 이동 수집기오 맞지 않음

**압착**

- 살아 있는 객체들은 GC 사이클 마지막에 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백 시작점을 가리키는 포인터가 있음
- 압착 수집기는 memory fragmentation을 방지

**방출**

- 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동(방출)

## 2. 핫스팟 런타임 개요

- GC 작동 원리를 온전히 이해하려면 핫스팟 내부도 어느 정도는 알아야 함
  - 자바는 객체에 대한 역참조가 없고, offset operator(`.`) 만으로 필드에 액세스하거나 메소드를 호출
  - call-by-value 방식으로만 메소드 호출
  - 객체 레퍼런스의 복사된 값은 힙에 있는 객체의 주소

### 2.1 객체를 런타임에 표현하는 방법

**oop (ordinary object pointer)**

- 핫스팟은 런타임에 oop라는 구조체로 자바 객체를 나타냄
- oop는 참조형 지역 변수 안에 위치하는 포인터
- 자바 메소드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킴
- **instanceOop**
  - 자바 클래스의 인스턴스를 나타냄
  - instanceOop의 메모리 레이아웃은 모든 객체에 대한 기계어 워드 2개로 구성된 헤더로 시작
    - *Mark 워드* : 인스턴스 관련 메타데이터를 가리키는 포인터
    - *Klass 워드* : 클래스 메타데이터를 가리키는 포인터

핫스팟 객체 헤더의 일반적인 구성

- Mark 워드
  - 32bit 환경에서는 4byte, 64bit 환경에서는 8byte
- Klass 워드
- length 워드
  - 객체가 배열인 경우에만 존재
  - 항상 32bit
- padding 워드
  - 정렬 규칙 때문에 필요한 경우에 존재
  - 32bit 여백

JVM 환경에서 자바 레퍼런스는 instanceOop, null을 제외한 어떤 것도 가리킬 수 없다는 말의 의미

- 자바 값은 기본형 값 또는 instanceOop 주소에 대응되는 비트 패턴이다
- 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터라고 볼 수 있다
- 자바 레퍼런스가 가리키는 주소에는 Mark 워드 + Klass 워드가 들어 있다
- klassOop와 Class<?> 인스턴스는 다르며, klassOop를 자바 변수 안에 넣을 수 없다
  - klassOop는 힙의 메타데이터 영역에 있음

oop의 전체 상속 구조

- oop (추상 베이스)
  - instanceOop (인스턴스 객체)
  - methodOop (메소드 표현형)
  - arrayOop (배열 추상 베이스)
  - symbolOop (내부 심볼 / String)
  - klassOop (Klass 헤더) (Java 7 이전)
  - markOop

👉 런타임에 oop 구조체를 이용해서 한 포인터는 클래스 메타데이터를 가리키고, 다른 포인터는 인스턴스 메타데이터를 가리키는 방식은 결코 드문 방식이 아님

### 2.2 GC 루트 및 아레나

**GC 루트** : 메모리의 anchor point로, 메모리 풀 외부에서 내부를 가리키는 포인터

GC 루트의 종류

- stack frame
- JNI
- register (hoisted value)
- code root (in JVM code cache)
- 전역 객체
- 로드된 클래스의 메타데이터

👉 힙에 있는 객체를 가리키는 참조형 지역 변수도 가장 단순한 형태의 GC 루트

**핫스팟 GC는 Arena라는 메모리 영역에서 작동**

**핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않는다!**

- 핫스팟은 유저 공간 코드에서 힙 크기를 관리 → 단순 측정값을 이용해 GC 서브시스템이 어떤 성능 문제를 일으키고 있는지 파악 가능

## 3. 할당과 수명

자바 애플리케이션에서 GC가 발생하는 주된 원인 2개 → **할당률, 객체 수명**

- 할당률: 일정 기간(보통 MB/s 단위) 새로 생성된 객체가 사용한 메모리량
  - JVM이 할당률을 직접 기록하지 않지만 비교적 쉽게 측정 가능한 값
- 반면에 객체 수명은 측정하기 어려움
- 따라서 객체 수명이 할당률보다 더 핵심적인 요인

GC의 핵심 전제: 동일한 물리 메모리 조각을 몇 번이고 계속 다시 쓸 수 있는가

- 객체가 생성된 후 잠시 존재하고 그 상태를 보관하는 데 사용한 메모리를 다시 회수한다는 점이 핵심

### 3.1 약한 세대별 가설

*Weak Generational Hypothesis*

> JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보인다.  
> 거의 대부분의 객체는 아주 짧은 시간만 살아 있지만, 나머지 객체는 기대 수명이 훨씬 길다.

- GC를 수행하는 힙은 단명 객체를 쉽고 빠르게 수집할 수 있게 설계하고, 장수 객체와 단명 객체를 완전히 떼어놓는 것이 가장 좋다

핫스팟이 '약한 세대별 가설'을 수용하는 메커니즘

- 객체마다 'generation count'를 센다
  - generation count: 객체가 지금까지 무사 통과한 GC 사이클 수
- 큰 객체를 제외한 나머지 객체는 Eden 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
- 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역에 보관한다.
  - old 또는 Tenured 영역

![generational-collection](https://github.com/nmin11/TIL/assets/75058239/4ad2f12c-3e5c-4910-80c0-04d2e3cf62f8)

👉 핫스팟의 마크 앤 스위프 수집 구현에 따라 더 세분화할 수 있음 → 중요한 건 외부에서 young 세대 내부를 가리키는 포인터를 계속 추적하는 기법!

> 늙은 객체가 젊은 객체를 참조할 일은 거의 없다.

**card table**

- 늙은 객체가 젊은 객체를 참조하는 정보를 기록하는 자료 구조
- JVM이 관리하는 byte 배열
- 각 원소는 올드 세대 공간의 512byte를 나타냄
- 핵심 로직
  - 늙은 객체 `o`에 있는 참조형 필드값 변경
  - `o`에 해당하는 instanceOop가 들어 있는 카드를 찾아 해당 엔트리를 더티 마킹
    - 핫스팟은 레퍼런스 필드를 업데이트할 때마다 단순 write barrier 이용
      - 늙은 객체와 젊은 객체의 관계가 맺어지면 카드 테이블 엔트리를 더티 값으로 세팅
      - 관계가 해제되면 더티 값을 지움
    - 필드 저장이 끝나면 다음 코드 조각 실행

```java
cards[*instanceOop >> 9] = 0;
```

👉 0 = 카드에 더티하다고 표시한 값  
👉 카드 테이블이 512(2⁹)byte이므로 9bit 우측 시프트

***새로운 수집기 G1(Garbage First)은 힙을 배치하는 방식 자체가 완전 다르고, 최신 자바에서 디폴트 수집기로 사용됨 (7장에서 배울 것)***

## 4. 핫스팟의 가비지 수집

- 자바는 C/C++ 계열과 달리 OS를 이용해서 동적으로 메모리를 관리하지 않음
- 프로세스가 시작되면 JVM은 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리

### 4.1 스레드 로컬 할당

- 에덴은 대부분의 객체가 탄생하고, 단명 객체도 많으므로 각별한 관리가 필요
- JVM은 에덴을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포
  - 각 스레드는 다른 스레드가 자신의 버퍼에 객체를 할당하지 못하도록 독점
  - TLAB(Thread Local Allocation Buffer)
- JVM 스레드의 할당 복잡도 = O(1)
  - 스레드가 객체를 생성할 때 객체에 저장 공간이 할당되고 스레드-로컬 포인터는 그다음 비어 있는 메모리 주소를 가리키도록 업데이트
  - pointer bump: 다음 빈 포인터로 계속 이동시키는 부가 명령어

### 4.2 반구형 수집

*hemispheric evacuating collector*

- 두 공간을 사용하는 독특한 방출 수집기
- 장수하지 못한 객체를 임시 수용소에 담아 두자는 아이디어
- 단명 객체가 테뉴어드 세대를 어지럽히지 않게 하고 풀 GC 발생 빈도를 줄일 수 있음

2가지 기본 특성

- 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용한다
- 절반의 공간은 항상 완전히 비운다

부가 설명

- 실제로 보관 가능한 메모리 공간보다 2배를 더 사용
  - 공간이 너무 크지 않다면 유용한 기법
- 핫스팟은 이 반구형 기법과 에덴 공간을 접목시켜 영 세대 수집을 수행
- **Survivor** : 핫스팟에서 영 힙의 반구부를 일컫는 말
  - 일반적으로 서바이버 공간은 에덴보다 작음
  - 역할: 각 영 세대 수집을 교환

## 5. 병렬 수집기

- 자바 8 이전 JVM 디폴트 가비지 수집기
- 처리율에 최적화되어 있고 영 GC, 풀 GC 모두 풀 STW를 일으킴
  - 애플리케이션을 모두 중단시킨 다음 가용 CPU 코어를 총동원해 가능한 한 빨리 메모리를 수집

**Parallel GC**

- 가장 단순한 영 세대용 병렬 수집기

**ParNew GC**

- CMS 수집기와 함께 사용할 수 있게 Parallel GC를 조금 변형한 것

**ParallelOld GC**

- 올드 세대용 병렬 수집기

### 5.1 영 세대 병렬 수집

- 영 세대 수집은 가장 흔한 가비지 수집 형태

영 세대 병렬 수집 과정

1. 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고 JVM은 새 TLAB을 할당할 수 없을 때 영 세대 수집 발생
2. 영 세대 수집이 발생하면 JVM은 어쩔 수 없이 STW를 일으킴
3. STW 이후 핫스팟은 에덴 및 서바이버의 영 세대를 뒤져서 가비지가 아닌 객체를 골라냄
   - GC 루트를 병렬 마킹 스캔 작업의 출발점으로 사용
4. Parallel GC는 살아남은 객체를 비어 있는 서바이버 공간으로 모두 방출한 후, 세대 카운트를 늘려 한 차례 이동했음을 기록
5. 에덴과 서바이버를 재사용 가능한 빈 공간으로 표시하고 애플리케이션 스레드 재시작, TLAB을 애플리케이션 스레드에 배포하는 프로세스 재개

의도

- 살아 있는 객체만 건드려 '약한 세대별 가설'의 이점을 최대한 활용
- 가능한 코어를 총동원해 STW 중단 시간을 조금이라도 단축

### 5.2 올드 세대 병렬 수집

- Parallel GC와 상당히 비슷하지만 근본적인 차이점이 있음
  - Parallel GC: 객체를 방출하는 반구형 수집기
  - ParallelOld GC: 하나의 연속된 메모리 공간에서 압착하는 수집기
- 올드 세대에 더 이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치
  - 메모리 사용 면에서 효율적이고 메모리 단편화가 일어날 일도 없음

### 5.3 병렬 수집기의 한계

풀 STW 유발

- 영 수집에 대해서는 약한 세대별 가설에 따라 극소수 객체만 살아남기 때문에 큰 문제는 아님
  - 최신 2GB JVM에서 영 수집 중단 시간은 대부분 10ms 이하
- 올드 세대는 디폴트 크기 자체가 영 세대의 7배
  - 살아 있는 객체들도 많아서 마킹 시간도 늘어남
  - STW 시간이 힙 크기에 거의 비례

## 6. 할당의 역할

- GC는 메모리 할당 요청을 수용하기에 메모리가 부족할 때 작동
- GC 사이클은 예측 불가능하며, 그때그때 필요에 의해 발생
  - 시계열 해석 방법으로 로그를 처리하기 어려움
- **조기 승격(premature promotion)**
  - 할당률이 너무 높으면 객체는 어쩔 수 없이 테뉴어드로 곧장 승격됨
  - 가비지 수집에서 갖아 중요한 side effect이자, 많은 튜닝 활동의 출발점 중 하나
