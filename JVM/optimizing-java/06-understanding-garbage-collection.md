가비지 수집 구현체의 2가지 기본 원칙

1. **알고리즘은 반드시 모든 가비지를 수집해야 한다.**
2. **살아 있는 객체는 절대로 수집해선 안 된다.**

6장에서는...

- 자바 가비지 수집의 기초 이론 소개
- 자바 플랫폼에서 가비지 수집을 완전히 이해/제어하기 어려운 이유에 대해
- 핫스팟이 런타임에 객체를 힙에 나타내는 방법 및 기본 특성
- 병렬 수집기 소개
  - 핫스팟에서 가장 단순한 상용 수집기
  - 다양한 워크로드에서의 쓰임새에 대해

## 1. 마크 앤 스위프

GC 알고리즘의 전체적인 과정

1. allocated list를 순회하면서 mark bit를 지움
2. GC 루트부터 살아 있는 객체 찾기
3. 찾은 객체마다 mark bit 세팅
4. allocated list를 순회하면서 mark bit가 세팅되지 않은 객체 찾기
   - 힙에서 메모리를 회수해 free list에 되돌림
   - allocated list에서 객체를 제거

- 살아 있는 객체는 대부분 DFS로 찾음
- live object graph: 살아 있는 객체들의 그래프
  - transitive closure of reachable objects 라고도 불림
- 힙 상태는 시각화해서 보기 어려움
  - `jmap -histo` 명령어로 타입별 할당된 바이트 수와, 해당 메모리를 차지하는 전체 인스턴스 개수 확인 가능

### 1.1 가비지 수집 용어

**STW**

- GC 사이클 동안 모든 애플리케이션 스레드가 일시 중단되는 시간
- 애플리케이션 스레드가 멈춰야 살아 있는 객체를 정확히 식별할 수 있기 때문

**동시**

- GC 스레드는 애플리케이션 스레드와 동시(병행) 실행될 수 있음
- 아주 어렵고 비싼 작업인 데다 100% 동시 실행을 보장할 수는 없음

**병렬**

- 여러 스레드를 동원해서 가비지 수집

**정확**

- GC 스킴은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지님

**보수**

- 보수적인 스킴은 정확한 정보가 없어서 리소스를 낭비하는 일이 잦고 타입 체계를 무시하므로 훨씬 비효율적

**이동**

- 이동 수집기에서 객체는 메모리를 여기저기 이동할 수 있음
- 객체 주소가 고정 도니 것이 아님
- raw pointer로 직접 액세스하는 환경은 이동 수집기오 맞지 않음

**압착**

- 살아 있는 객체들은 GC 사이클 마지막에 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백 시작점을 가리키는 포인터가 있음
- 압착 수집기는 memory fragmentation을 방지

**방출**

- 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동(방출)
