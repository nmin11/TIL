## PageRank algorithm

- Google은 어떻게 수십억 장이 넘는 웹 페이지를 다 분석하고 가장 적절한 페이지를 추천하는걸까?
- 검색 품질을 높이는 알고리듬은 다양하지만 그 중에서 핵심은 **PageRank algorithm**
- Google을 창립한 Sergey Brin과 Larry Page는 원래 스탠퍼드 대학교에서 그래프 알고리듬을 연구하는 컴퓨터 과학도
- 두 사람은 웹을 그래프 모델로 정의했음
  - 웹 페이지는 정점, 페이지 사이의 링크는 간선으로 정의
- 어떤 웹 페이지가 다른 중요한 페이지로부터 많이 링크된다면, 링크된 페이지 역시 중요한 페이지일 것
- PageRank 알고리듬은 페이지를 그래프로 나타내고, 여러 라운드에 걸쳐 페이지의 점수를 평가
  - 라운드가 진행될 때마다 페이지들은 자신이 획득한 점수를 자신이 링크하는 페이지에 나누어줌
  - 이 분배 과정은 점수가 안정화될 때까지 계속해서 반복
- 웹 페이지의 중요도를 판별하는 PageRank 알고리듬은 Google이 다른 검색 엔진을 압도할 수 있도록 한 일등공신

<br>

## DBMS의 색인(index)

- DBMS는 각 행의 ID와 메모리 주소를 대응시키는 색인(index)을 추가로 만들어둠
- 색인은 자가 균형 이진 탐색 트리로 되어 있음
- 트리의 각 정점의 키가 바로 색인해야 하는 필드의 값
- 이진 탐색 트리의 탐색 비용은 O(log n)
- 일반적으로 DBMS는 모든 primary key에 대해 색인 생성

<br>

## 분산 데이터베이스

- 여러 대의 컴퓨터가 협동하여 데이터베이스 시스템을 제공
- 필요한 상황들 예시
  - 수백 테라바이트 규모
  - 초당 수천 건의 질의 동시 처리 (트위터)
  - 실패를 불허하는 사활적 임무 담당 (항공기 운항 정보)

### Single-master replication

- 컴퓨터 한 대가 master로서 모든 질의를 입력받음
- 여러 대의 컴퓨터가 slave로서 연결된 구조이며, 각 slave들은 DB의 복제본을 가짐
- 만약 master가 쓰기 질의를 요청받으면 이를 slave들에게 전달하여 모든 DB 사본을 동기화함
- master는 읽기 질의를 여러 slave에게 맡겨서 처리할 수 있으며, 신뢰도가 더욱 높아짐
- 모종의 이유로 master가 종료되더라도 slave 컴퓨터들이 협력하여 새로운 master를 자동으로 선택함

### Multi-master replication

- cluster를 구성하는 모든 컴퓨터를 master로 삼는 방식
- load balancer를 이용해서 입력되는 질의들을 cluster의 모든 컴퓨터에 골고루 나누어줌
- 각 컴퓨터가 cluster의 다른 모든 컴퓨터와 연결되어서, 쓰기 질의를 서로 전파하며 DB 사본을 동기화

### Sharding

- 대용량의 쓰기 질의가 대량으로 발생하면 cluster의 컴퓨터들이 전부 DB 사본을 동기화하기가 힘들어짐
- 이를 해결하기 위해 DB를 여러 컴퓨터에 분할해서 저장하는 방법 사용
- 이를 sharding이라고 하며, 각 분할본을 shard라고 함
- 분할되어 있는 경우, 질의를 처리하기 위해 질의를 수행할 수 있는 컴퓨터로 질의를 전달하는데,<br>이 때 **query router** 이용
- 때로는 sharding과 replication을 병행하기도 함

<br>

## 컴퓨터의 기본 구조

- 컴퓨터는 일련의 명령에 따라 데이터를 조작하는 기계
- 컴퓨터의 핵심 부품 2가지 - 프로세서와 메모리
- RAM(Random Access Memory) : 컴퓨터가 수행해야 할 명령어를 써넣는 공간, 연산의 대상이 되는 데이터 저장
- CPU(Central Processing Unit) : 메모리에서 명령어와 데이터를 읽어 그에 맞게 계산

(이미지 첨부 CPU & RAM)

### 메모리

- 수많은 셀로 나뉨
- 각 셀은 저마다 미세한 양의 데이터를 저장하며 각 셀을 구분하는 주소 번호가 순서대로 매겨져 있음
- 데이터를 읽고 쓰는 작업은 셀을 한번에 하나씩 조작하는 연산을 통해 수행
- 메모리는 전기 부품이므로, 셀의 주소는 여러 가닥의 전선을 통해 이진 주소로 전송해야 함
  - 각 전선마다 이진수 숫자를 하나씩 전송 가능
  - 높은 전압이 걸린 전선은 '1' 신호를, 낮은 전압이 걸린 전선은 '0' 신호를 나타냄
- 셀의 주소에 대해 읽기 및 쓰기 작업이 가능하며, 동작 모드를 설정하기 위한 특별 입력 전선이 있음
- 일반적으로 메모리 셀 하나에는 8자리의 이진수, **byte**를 저장할 수 있음
- 한 덩어리의 데이터를 전송하는 전선의 모음을 **bus**라고 함
  - 주소를 전송하는 8가닥의 전선은 **주소 버스**
  - 메모리 셀과 데이터를 주고받는 데 사용되는 다른 8가닥의 전선은 **데이터 버스**
  - 주소 버스는 단방향, 데이터 버스는 양방향
- CPU와 RAM은 끊임없이 데이터를 교환
  - CPU는 메모리에서 명령어와 데이터를 지속적으로 읽어들이며, 때때로 출력 값이나 중간 계산을 메모리에 저장

### CPU

- CPU 내부에는 **register**라고 불리는 자체 메모리 셀들이 존재
- CPU는 레지스터에 지정된 수를 대상으로 간단한 수학 연산 가능
- RAM과 레지스터 사이에서 데이터 교환 가능
- CPU 명령의 예시
  - 메모리 220번 셀의 데이터를 레지스터 3번으로 복사
  - 레지스터 3번의 수를 레지스터 1번의 수에 덧셈
- CPU가 수행할 수 있는 모든 연산의 집합을 **instruction set (명령어 집합)** 이라고 부름
  - 명령어 집합의 각 연산에는 번호가 할당됨
  - 컴퓨터 프로그램 코드는 근본적으로 CPU의 연산을 나타내는 번호들을 실행 순서에 따라 배열한 것
  - 프로그램 실행 시 연산들은 수로서 RAM에 저장
  - RAM에는 입출력 데이터, 중간 계산 데이터, 프로그램 코드 등이 모두 뒤섞여서 저장되는 셈
- CPU의 동작은 메모리의 명령어를 끊임없이 가져와 수행하는 무한 루프로 이루어짐
- 이 무한 루프의 중심에는 **program counter**가 있음
  - program counter는 다음에 수행해야 할 명령어가 기록된 메모리의 주소를 가리키는 특별 레지스터
- CPU가 program counter를 활용하는 방식
  1. program counter가 가리키는 메모리 주소에서 명령어를 가져옴
  2. program counter를 1 증가시킴
  3. 가져온 명령 수행
  4. 1번으로 돌아감
- CPU에 전원을 넣으면 program counter는 기본값으로 설정됨
  - 기본값은 일반적으로 immutable한 BIOS를 가리킴
- CPU는 점프라는 명령도 지원
  - 점프는 program counter에 새로운 값을 써넣어 실행 흐름을 메모리의 다른 지점으로 건너뛰도록 하는 명령
  - 이 분기를 조건부로 처리할 수도 있음
- 여기까지의 컴퓨터 기본 동작 원리는 웹사이트를 방문하든, 컴퓨터 게임을 하든, 문서를 편집하든<br>컴퓨터의 연산 수행이 언제나 똑같이 작동하도록 하는 원리
- 여러 개의 프로시저를 조합해서 프로그램을 구성하므로, 프로그램은 결국 단순한 연산들을 모아 나열한 것
  - 예를 들어 '스페이스 인베이더'는 3천여 개의 CPU 명령어로 만들어졌음

### CPU 클락

- 클락이란, CPU가 1초 동안 실행하는 기본 연산이 몇 개인지를 나타내는 단위
- 만약 2MHz라면 CPU가 1초에 약 2백만 개의 기본 연산 수행
- 기계어 명령 하나가 수행되는 데 필요한 기본 연산은 5개 ~ 10개 정도
- 오늘날에는 평범한 데스크탑이나 스마트폰에도 흔하게 2GHz 가량의 CPU 탑재
  - 매 초당 수억 개의 기계어 명령을 수행
- 게다가 멀티 코어 CPU가 많아지고 있음
  - 2GHz 쿼드 코어 프로세서 하나는 초당 십억 개의 기계 명령 수행

### CPU 아키텍처

- 요즘 사용하는 개인용 컴퓨터는 대부분 x86 아키텍처 CPU 사용
- 하지만 스마트폰은 별도의 전력 효율이 좋은 아키텍처를 사용
- 이처럼 CPU 아키텍처가 다르다는 것은 CPU 명령어 집합이 다르다는 뜻
  - 따라서 명령어에 숫자 번호를 매기는 방법도 다름

### 32bit 아키텍처와 64bit 아키텍처

- 최초의 CPU 인텔 4004는 4bit 아키텍처로 설계되었음
  - 이는 이 CPU가 명령어 하나당 4자리까지의 이진수를 연산할 수 있었다는 뜻
  - 이 CPU의 데이터 버스와 주소 버스는 각각 4개의 전산망으로 구성되었음
- 이후 보급된 DOS(Disk Operating System)를 구동하는 초기 개인용 컴퓨터는 8bit CPU
- 32bit 아키텍처
  - CPU의 레지스터가 32bit 수를 수용
  - 32개의 선으로 이루어진 주소 버스 덕분에 2³²byte(4GB) 크기의 메모리에까지 주소 부여 가능
- 64bit 아키텍처
  - 4GB가 넘는 메모리 주소를 32bit 레지스터에 욱여넣으려면 꽤 까다로운 처리가 필요했음
  - 64bit CPU는 명령어 하나가 극도로 큰 수를 처리할 수 있음
  - 64bit 레지스터 또한 매우 방대한 메모리 공간의 주소 저장 가능
  - 그 범위는 2⁶⁴byte = 170GB 이상

### little-endian / big-endian

- little-endian : CPU와 RAM에 수를 저장할 때, **왼쪽에서 오른쪽으로** 저장하는 방식
- big-endian : 메모리 데이터를 **오른쪽에서 왼쪽으로** 저장하는 방식
- 예를 들어 10000011이라는 이진 수열을 볼 때 어느 엔디언에 따라 배열되었느냐에 따라 나타내는 수가 달라짐
  - little-endian이라면 131
  - big-endian이라면 193
- 오늘날 대부분의 CPU는 little-endian 방식
- 하지만 big-endian을 따르는 컴퓨터도 여전히 많이 사용되고 있음
- 그렇기에 little-endian CPU에서 생성된 데이터를 big-endian CPU에서 해석할 때 발생하는<br>**endianness mismatch**를 해결해야 할 때가 있음
- 특히 네트워크 스위치가 출력하는 데이터를 해석하는 일을 한다면 엔디언 불일치 문제를 잘 알아둬야 함
  - 초창기 네트워크 중계기(라우터)가 대부분 big-endian CPU를 사용했기 때문!

### emulator

- 다른 컴퓨터를 위해 설계된 코드를 내 컴퓨터로 실행하고 싶을 때 사용하는 소프트웨어
- 해당 기계와 동일한 CPU, RAM, 기타 하드웨어를 갖고 있는 것처럼 흉내 내는 가상 기계
- 다른 기계를 위해 만들어진 프로그램의 명령어를 해독하여, 가상 기계 위에서 실행
- 한 기계 안에서 다른 아키텍처로 이루어진 기계를 흉내 내려면 매우 복잡한 연산을 수행해야 함
- 컴퓨터가 그만큼 빠른 속도를 갖추도록 발전해왔기 때문에 가능한 것

<br>

## compile이란 무엇이며 왜 필요한가

- 컴퓨터는 프로그램을 통해 MRI 촬영, 음성 인식, 행성 탐사 등 복잡한 작업 수행 가능
  - 이 모든 작업은 간단한 CPU 명령어를 통해 수행된다는 것!
- 그러나 보통은 프로그램을 CPU 명령어로 작성하지 않음
- CPU 명령을 좀 더 자연스럽고 간결하게 나타낼 수 있는 **programming language** 사용
- 프로그래밍 언어로 프로그램을 만들고, 이후에 **compiler**라는 프로그램을 이용해서<br>작성한 코드를 CPU가 실행할 수 있는 기계어 명령어로 번역

**turing-complete**

- 컴퓨터과학의 아버지 Alan Turing이 고안한 컴퓨터의 원형이 되는 기계는 어떤 계산이든 자동으로 수행 가능
- 튜링의 기계는 다음 명령을 담은 프로그램을 실행할 수 있으면 되는 것
  - 메모리에서 데이터를 읽고 쓰기
  - 조건에 따라 분기 실행
- 어떤 기계가 위 기능들을 가짐으로써 범용적인 계산 능력을 갖추었다면, 이는 turing-complete하다고 함
  - 이 기계로 수행하는 문제가 복잡하고 어렵더라도 읽기·쓰기·분기의 간단한 명령어의 형태로 표현 가능하다는 것!
- turing-complete 기계는 모두 같은 계산 능력을 가짐
  - 그러므로 한 turing-complete 기계용으로 만든 프로그램은 다른 turing-complete 기계용으로도 만들 수 있다는 뜻!
- 범용 프로그래밍 언어들 또한 turing-complete
  - 그러므로 한 프로그래밍 언어로 작성한 프로그램은 다른 프로그래밍 언어로도 작성 가능하다는 뜻

⭐ compiler는 복잡한 고수준 프로그래밍 언어로 작성된 프로그램을 단순한 저수준 언어로 번역해주는 고마운 프로그램

### 운영체제 (operating system)

- 컴파일된 프로그램은 운영체제와 소통해야 함
  - 그렇기 때문에 데스크탑 컴퓨터용으로 컴파일된 프로그램은 스마트폰에서 실행되지 않는 것
- 운영체제가 필요한 이유
  - 프로그램은 내부 계산만을 처리하는 것이 아니라 외부 세계와 소통도 해야 하기 때문
  - 컴퓨터들은 저마다 다른 하드웨어로 구성되어 있으며, 하드웨어를 제어하는 방법도 다양
  - 하나의 프로그램이 화면 장치, 사운드 카드, 네트워크 카드 등을 모두 직접 지원하기란 불가능
  - 운영체제가 있기 때문에 프로그램은 외부 장치와 소통할 수 있는 것!
- 프로그램은 운영체제에 **system call**이라는 특별 요청을 해서 하드웨어와 소통
  - 이 요청에 따라 운영체제는 특정한 입출력 연산을 처리해줌
  - 다만 이러한 system call 코드를 개발자가 작성하는 경우는 거의 없음
  - compiler가 알맞은 system call을 알아서 번역해주기 때문!
- 운영체제가 제공하는 system call은 대개 서로 호환되지 않음
  - 그렇기 때문에 윈도우, 맥, 리눅스에서의 system call은 각자 다름
  - 컴파일된 프로그램은 특정 CPU 아키텍처 전용일 뿐 아니라, 특정 운영체제 전용이기도 한 것

### scripting language

- 스크립트 언어로 작성된 코드는 컴파일 없이도 실행 가능
- 대표적인 스크립트 언어는 JavaScript, Python, Ruby 등
- 코드는 CPU가 아닌 interpreter를 통해 실행됨
  - 따라서 스크립트 언어로 된 코드를 실행하려면 인터프리터를 먼저 설치해야 함
- 일반적으로 스크립트 언어로 작성한 코드는 이미 컴파일된 코드에 비해 훨씬 느리게 실행됨
  - 컴파일된 코드는 번역이 미리 이루어진 상태에서 실행되지만 인터프리터는 실시간으로 코드를 변역해서 실행
- 하지만 컴파일 시간 자체가 오래 걸리기 때문에 바로 번역하는 스크립트 언어가 매력을 가짐
- 여담이지만 Google 엔지니어는 그래서 컴파일 속도가 놀라울만큼 빠르고 성능도 좋은 GO 언어를 개발했음

### disassembly / reverse engineering

- 한번 컴파일된 프로그램을 컴파일 이전의 소스코드로 되돌리는 것은 불가능
- 하지만 이진 프로그램의 기계어 코드 배열을 사람이 읽을 수 있는 명령어 배열로 변환하는 것은 어렵지 않음
  - 이러한 작업을 **disassembly(역어셈블리)** 라고 함
- reverse engineering : 이진수 코드를 명령어 코드로 변환 후 기계어들을 읽어서 무슨 작업을 하는지 조사하는 것
- disassembly 프로그램 중에는 system call과 자주 사용되는 함수를 자동으로 탐지해서 표시해주는 것도 있음
- 해커들은 disassembly 도구를 이용해서 이진 코드를 해석할 수 있음
  - 필시 IT 업계의 선두 기업들은 경쟁사의 소프트웨어를 연구하는 역공학 연구소가 비밀리에 있을 것
  - Windows, Photoshop, GTA 등 사용권이 제한된 프로그램에서 해커들인 이진 코드를 검사해서<br>사용권 검사 코드를 찾아낸 뒤, 해당 부분에 JUMP 명령을 배치한 불법 복제 소프트웨어를 만들 수 있는 것
  - 정부의 비밀 첩보 기관에서 만든 Stuxnet은 이란의 지하 핵융합로 제어 컴퓨터에 침입해서 핵 개발 계획을 방해하기도 했음
