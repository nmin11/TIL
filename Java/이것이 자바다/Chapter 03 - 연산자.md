# 연산자와 연산식

- 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 **연산(operations)** 이라고 함
- 연산에 사용되는 표시나 기호를 **연산자(operator)** 라고 함
- 연산되는 데이터는 **피연산자(operand)** 라고 함
- 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것을 **연산식(expressions)** 이라고 부름
- 연산자는 필요로 하는 피연산자의 수에 따라 **단항** , **이항** , **삼항** 연산자로 구분됨

| 연산자 종류 |                               연산자                               | 피연산자 수 |    산출값    | 기능 설명                        |
| :---------: | :----------------------------------------------------------------: | :---------: | :----------: | :------------------------------- |
|    산술     |                        `+` `-` `*` `/` `%`                         |    이항     |     숫자     | 사칙연산 및 나머지 계산          |
|    부호     |                              `+` `-`                               |    단항     |     숫자     | 음수와 양수의 부호               |
|   문자열    |                                `+`                                 |    이항     |    문자열    | 두 문자열을 연결                 |
|    대입     | `=` `+=` `-=` `*=` `/=` `%=`<br>`&=` `^=` `\|=` `<<=` `>>=` `>>>=` |    이항     |     다양     | 우변의 값을 좌변의 변수에 대입   |
|    증감     |                             `++` `--`                              |    단항     |     숫자     | 1만큼 증가/감소                  |
|    비교     |            `==` `!=` `>` `<` `>=` `<=`<br>`instanceof`             |    이항     |   boolean    | 값의 비교                        |
|    논리     |                      `!` `&` `\|` `&&` `\|\|`                      |  단항/이항  |   boolean    | 논리적 NOT, AND, OR 연산         |
|    조건     |                         `(조건식) ? A : B`                         |    삼항     |     다양     | 조건식에 따라 A 또는 B 선택      |
|    비트     |                          `~` `&` `\|` `^`                          |  단항/이항  | 숫자/boolean | 비트 NOT, AND, OR, XOR 연산      |
|   쉬프트    |                          `>>` `<<` `>>>`                           |    이항     |     숫자     | 비트를 좌측/우측으로 밀어서 이동 |

- 연산식은 반드시 하나의 값을 산출
- 연산식은 다른 연산식의 피연산자 위치에도 올 수 있음

```java
boolean result = (x + y) < 5;
// + 연산식의 결과를 피연산자로 활용
```

<br>
<br>

# 연산의 방향과 우선순위

- 기본 산수에서처럼, 산술 연산식에서 덧셈, 뺄셈 연산자보다는 곱셈, 나눗셈 연산자가 우선 처리됨
- 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있음
  - 우선순위를 먼저 따지고, 우선순위가 같다면 연산 방향을 따짐
  - 대부분의 연산자는 왼쪽에서 오른쪽으로 (→)
  - 단항 연산자(++, --, ~, !), 부호 연산자(+, -), 대입 연산자(=, +=, -=)는 오른쪽에서 왼쪽으로 (←)

| 연산자                                                     | 연산 방향 | 우선순위 |
| :--------------------------------------------------------- | :-------: | :------: |
| 증감 (++, --), 부호(+, -), 비트(~), 논리(!)                |     ←     |    1     |
| 산술 (\*, /, %)                                            |     →     |    2     |
| 산술 (+, -)                                                |     →     |    3     |
| 쉬프트 (<<, >>, >>>)                                       |     →     |    4     |
| 비교 (<, >, <=, >=, instanceof)                            |     →     |    5     |
| 비교 (==, !=)                                              |     →     |    6     |
| 논리 (&)                                                   |     →     |    7     |
| 논리 (^)                                                   |     →     |    8     |
| 논리 (\|)                                                  |     →     |    9     |
| 논리 (&&)                                                  |     →     |    10    |
| 논리 (\|\|)                                                |     →     |    11    |
| 조건 (?:)                                                  |     →     |    12    |
| 대입 (=, +=, -=, \*=, /=, %=, &=, ^=, \|=, <<=, >>=, >>>=) |     ←     |    13    |

- 복잡한 연산식에는 `()`를 사용해서 먼저 처리할 연산식을 묶어주는 것이 좋음

```java
int result = (var1 + var2) * var3;
```

⭐ 연산의 방향과 우선순위 정리

1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가짐
2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가짐
3. 단항과 대입 연산자를 제외한 모든 연산의 뱡향은 왼쪽에서 오른쪽으로 (→)
4. 복잡한 연산식에서는 `()`를 사용해서 우선순위를 정해줄 것

<br>
<br>

# 단항 연산자

- 피연산자가 단 하나뿐인 연산자
- 부호 연산자(+, -), 증감 연산자(++, --), 논리 부정 연산자(!), 비트 반전 연산자(~)

<br>
<br>

## 부호 연산자 (+, -)

- 양수 및 음수를 표시
- boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용 가능
- `+` : 피연산자의 부호 유지
- `-` : 피연산자의 부호 변경
- int 타입보다 작은 정수 타입의 경우에는 부호 연산자의 산출 타입이 int가 되므로 주의해야 함

<br>
<br>

## 증감 연산자 (++, --)

- 변수의 값을 1 증가시키거나 1감소시키는 연산자
- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- `++x` : 다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴
- `x++` : 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
  - 연산식에 증감 연산자만 있는 경우에는 증감 연산자가 변수 앞, 뒤 어디에 있든 상관 없음
  - 다른 연산자와 함께 사용하는 경우에는 증감 연산자의 위치에 따라 결과가 다름

```java
int x = 1;
int y = 1;
int result1 = ++x + 10;
int result2 = y++ + 10;
```

변수 result1 에는 12가 저장된다. x의 값이 1 증가되어 2가 된 후 10과 합해지기 때문이다.  
변수 result2 에는 11이 저장된다. y의 값 1과 10이 합해져서 11이 된 후에 y의값이 1 증가하기 때문이다.

- `++i`와 `i=i+1`은 컴파일하면 동일한 바이트 코드가 생성됨

<br>
<br>

## 논리 부정 연산자 (!)

- boolean 타입에만 사용 가능
- 조건식의 값을 부정하도록 해서 실행 흐름을 제어할 때 주로 사용됨

<br>
<br>

## 비트 반전 연산자 (~)

- 정수 타입(byte, short, int, long)의 피연산자에만 사용 가능
- 피연산자를 2진수로 표현했을 때 비트값 0은 1로, 1은 0으로 반전하는 기능
- 최상위 비트인 부호 비트 또한 반전되기 때문에 부호가 반대인 값 산출
- 비트 반전 연산자의 산출 타입은 int 타입으로 변환된 이후에 비트 반전이 일어남
  - 다만, 더 큰 타입인 long 타입은 타입 변환이 일어나지 않음 (int 타입으로 변환은 불가능)
- 비트 반전 연산자의 결과를 응용해서 부호가 반대인 정수를 구할 수 있음
  - 사실 부호 연산자인 `-`를 이용하는 것이 간편하기는 함 😅

```java
byte v1 = 10;
int v2 = ~v1 + 1; //-10
```

- Java는 정수값을 총 32bit의 이진 문자열로 리턴하는 `Integer.toBinaryString()` 메소드를 제공

<br>
<br>

# 이항 연산자

- 피연산자가 2개인 연산자
- 산술 연산자(+, -, _, /, %), 문자열 연결 연산자(+), 대입 연산자(=, +=, -=, _=, /=, %=, &=, ^=, \|=, <<=, >>=, >>>=), 비교 연산자(<, <=, >, >=, ==, !=), 논리 연산자(&&, \|\|, &, \|, ^, !), 비트 논리 연산자(&, \|, ^), 비트 이동 연산자(<<, >>, >>>) 등이 있음

<br>
<br>

## 산술 연산자 (+, -, \*, /, %)

- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- `+` : 덧셈 연산
- `-` : 뺄셈 연산
- `*` : 곱셈 연산
- `/` : 나눗셈 연산
- `%` : 나머지 연산
- 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산 수행
  1. 피연산자들이 모두 정수 타입이고, int 타입보다 작은 타입일 경우, 모두 int 타입으로 변환 후 연산 수행
  2. 피연산자들이 모두 정수 타입이고, 이 중에 long 타입이 존재할 경우, 모두 long 타입으로 변환 후 연산 수행
  3. 피연산자들 중 실수 타입이 하나라도 있을 경우, 실수 타입들 중에서 크기가 큰 실수 타입으로 변환 후 연산 수행

※ 정수 타입 연산의 결과가 int 타입으로 나오는 이유는 JVM이 기본적으로 32bit 단위로 계산하기 때문

```java
int int1 = 10;
int int2 = 4;

int result1 = int1 / int2;
double result2 = int1 / int2;
```

우리는 result1의 결과가 소수점 이하 부분을 버리기 때문에 2가 산출되리라는 것을 이미 알고 있다.  
그러면 result2는 어떨까?  
이 경우 정수끼리의 연산 산출 결과인 2가 먼저 나오고, 이를 실수화하기 때문에 변수의 값은 2.0이 된다.  
만약 2.5를 저장하고 싶다면 2개의 피연산자 중 하나를 강제 타입 변환해야 한다.

- char 타입도 정수 타입이므로 산술 연산이 가능
  - 주의할 점은 char 타입이 산술 연산이 될 경우 int 타입으로 변환되므로 산출 타입은 int 타입

```java
public class CharOperationExample {
  public static void main(String[] args) {
    char c1 = 'A' + 1;
    char c2 = 'A';
    char c3 = c2 + 1; //컴파일 에러
  }
}
```

`'A' + 1`에서 'A'는 65라는 유니코드를 가지므로 이에 1을 더해서 66이라는 유니코드를 가진 'B'가 c1 변수에 저장된다.  
Java에서 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산하기 때문에 이렇게 char 문자와 정수를 연산해도 char 타입에 저장할 수 있다.  
그러나 `c2 + 1`에서는 c2가 int 타입으로 변환되고 산출 타입도 int 타입이 되기 때문에 char 타입에 저장할 수 없게 된다.  
이 문제 또한 강제 타입 변환으로 해결할 수 있다.

```java
char c3 = (char) (c2 + 1);
```
