# 연산자와 연산식

- 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 **연산(operations)** 이라고 함
- 연산에 사용되는 표시나 기호를 **연산자(operator)** 라고 함
- 연산되는 데이터는 **피연산자(operand)** 라고 함
- 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것을 **연산식(expressions)** 이라고 부름
- 연산자는 필요로 하는 피연산자의 수에 따라 **단항** , **이항** , **삼항** 연산자로 구분됨

| 연산자 종류 |                               연산자                               | 피연산자 수 |    산출값    | 기능 설명                        |
| :---------: | :----------------------------------------------------------------: | :---------: | :----------: | :------------------------------- |
|    산술     |                        `+` `-` `*` `/` `%`                         |    이항     |     숫자     | 사칙연산 및 나머지 계산          |
|    부호     |                              `+` `-`                               |    단항     |     숫자     | 음수와 양수의 부호               |
|   문자열    |                                `+`                                 |    이항     |    문자열    | 두 문자열을 연결                 |
|    대입     | `=` `+=` `-=` `*=` `/=` `%=`<br>`&=` `^=` `\|=` `<<=` `>>=` `>>>=` |    이항     |     다양     | 우변의 값을 좌변의 변수에 대입   |
|    증감     |                             `++` `--`                              |    단항     |     숫자     | 1만큼 증가/감소                  |
|    비교     |            `==` `!=` `>` `<` `>=` `<=`<br>`instanceof`             |    이항     |   boolean    | 값의 비교                        |
|    논리     |                      `!` `&` `\|` `&&` `\|\|`                      |  단항/이항  |   boolean    | 논리적 NOT, AND, OR 연산         |
|    조건     |                         `(조건식) ? A : B`                         |    삼항     |     다양     | 조건식에 따라 A 또는 B 선택      |
|    비트     |                          `~` `&` `\|` `^`                          |  단항/이항  | 숫자/boolean | 비트 NOT, AND, OR, XOR 연산      |
|   쉬프트    |                          `>>` `<<` `>>>`                           |    이항     |     숫자     | 비트를 좌측/우측으로 밀어서 이동 |

- 연산식은 반드시 하나의 값을 산출
- 연산식은 다른 연산식의 피연산자 위치에도 올 수 있음

```java
boolean result = (x + y) < 5;
// + 연산식의 결과를 피연산자로 활용
```

<br>
<br>

# 연산의 방향과 우선순위

- 기본 산수에서처럼, 산술 연산식에서 덧셈, 뺄셈 연산자보다는 곱셈, 나눗셈 연산자가 우선 처리됨
- 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있음
  - 우선순위를 먼저 따지고, 우선순위가 같다면 연산 방향을 따짐
  - 대부분의 연산자는 왼쪽에서 오른쪽으로 (→)
  - 단항 연산자(++, --, ~, !), 부호 연산자(+, -), 대입 연산자(=, +=, -=)는 오른쪽에서 왼쪽으로 (←)

| 연산자                                                     | 연산 방향 | 우선순위 |
| :--------------------------------------------------------- | :-------: | :------: |
| 증감 (++, --), 부호(+, -), 비트(~), 논리(!)                |     ←     |    1     |
| 산술 (\*, /, %)                                            |     →     |    2     |
| 산술 (+, -)                                                |     →     |    3     |
| 쉬프트 (<<, >>, >>>)                                       |     →     |    4     |
| 비교 (<, >, <=, >=, instanceof)                            |     →     |    5     |
| 비교 (==, !=)                                              |     →     |    6     |
| 논리 (&)                                                   |     →     |    7     |
| 논리 (^)                                                   |     →     |    8     |
| 논리 (\|)                                                  |     →     |    9     |
| 논리 (&&)                                                  |     →     |    10    |
| 논리 (\|\|)                                                |     →     |    11    |
| 조건 (?:)                                                  |     →     |    12    |
| 대입 (=, +=, -=, \*=, /=, %=, &=, ^=, \|=, <<=, >>=, >>>=) |     ←     |    13    |

- 복잡한 연산식에는 `()`를 사용해서 먼저 처리할 연산식을 묶어주는 것이 좋음

```java
int result = (var1 + var2) * var3;
```

⭐ 연산의 방향과 우선순위 정리

1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가짐
2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가짐
3. 단항과 대입 연산자를 제외한 모든 연산의 뱡향은 왼쪽에서 오른쪽으로 (→)
4. 복잡한 연산식에서는 `()`를 사용해서 우선순위를 정해줄 것

<br>
<br>

# 단항 연산자

- 피연산자가 단 하나뿐인 연산자
- 부호 연산자(+, -), 증감 연산자(++, --), 논리 부정 연산자(!), 비트 반전 연산자(~)

<br>
<br>

## 부호 연산자 (+, -)

- 양수 및 음수를 표시
- boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용 가능
- `+` : 피연산자의 부호 유지
- `-` : 피연산자의 부호 변경
- int 타입보다 작은 정수 타입의 경우에는 부호 연산자의 산출 타입이 int가 되므로 주의해야 함

<br>
<br>

## 증감 연산자 (++, --)

- 변수의 값을 1 증가시키거나 1감소시키는 연산자
- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- `++x` : 다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴
- `x++` : 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
  - 연산식에 증감 연산자만 있는 경우에는 증감 연산자가 변수 앞, 뒤 어디에 있든 상관 없음
  - 다른 연산자와 함께 사용하는 경우에는 증감 연산자의 위치에 따라 결과가 다름

```java
int x = 1;
int y = 1;
int result1 = ++x + 10;
int result2 = y++ + 10;
```

변수 result1 에는 12가 저장된다. x의 값이 1 증가되어 2가 된 후 10과 합해지기 때문이다.  
변수 result2 에는 11이 저장된다. y의 값 1과 10이 합해져서 11이 된 후에 y의값이 1 증가하기 때문이다.

- `++i`와 `i=i+1`은 컴파일하면 동일한 바이트 코드가 생성됨

<br>
<br>

## 논리 부정 연산자 (!)

- boolean 타입에만 사용 가능
- 조건식의 값을 부정하도록 해서 실행 흐름을 제어할 때 주로 사용됨

<br>
<br>

## 비트 반전 연산자 (~)

- 정수 타입(byte, short, int, long)의 피연산자에만 사용 가능
- 피연산자를 2진수로 표현했을 때 비트값 0은 1로, 1은 0으로 반전하는 기능
- 최상위 비트인 부호 비트 또한 반전되기 때문에 부호가 반대인 값 산출
- 비트 반전 연산자의 산출 타입은 int 타입으로 변환된 이후에 비트 반전이 일어남
  - 다만, 더 큰 타입인 long 타입은 타입 변환이 일어나지 않음 (int 타입으로 변환은 불가능)
- 비트 반전 연산자의 결과를 응용해서 부호가 반대인 정수를 구할 수 있음
  - 사실 부호 연산자인 `-`를 이용하는 것이 간편하기는 함 😅

```java
byte v1 = 10;
int v2 = ~v1 + 1; //-10
```

- Java는 정수값을 총 32bit의 이진 문자열로 리턴하는 `Integer.toBinaryString()` 메소드를 제공

<br>
<br>

# 이항 연산자

- 피연산자가 2개인 연산자
- 산술 연산자(+, -, _, /, %), 문자열 연결 연산자(+), 대입 연산자(=, +=, -=, _=, /=, %=, &=, ^=, \|=, <<=, >>=, >>>=), 비교 연산자(<, <=, >, >=, ==, !=), 논리 연산자(&&, \|\|, &, \|, ^, !), 비트 논리 연산자(&, \|, ^), 비트 이동 연산자(<<, >>, >>>) 등이 있음

<br>
<br>

## 산술 연산자 (+, -, \*, /, %)

- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- `+` : 덧셈 연산
- `-` : 뺄셈 연산
- `*` : 곱셈 연산
- `/` : 나눗셈 연산
- `%` : 나머지 연산
- 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산 수행
  1. 피연산자들이 모두 정수 타입이고, int 타입보다 작은 타입일 경우, 모두 int 타입으로 변환 후 연산 수행
  2. 피연산자들이 모두 정수 타입이고, 이 중에 long 타입이 존재할 경우, 모두 long 타입으로 변환 후 연산 수행
  3. 피연산자들 중 실수 타입이 하나라도 있을 경우, 실수 타입들 중에서 크기가 큰 실수 타입으로 변환 후 연산 수행

※ 정수 타입 연산의 결과가 int 타입으로 나오는 이유는 JVM이 기본적으로 32bit 단위로 계산하기 때문

```java
int int1 = 10;
int int2 = 4;

int result1 = int1 / int2;
double result2 = int1 / int2;
```

우리는 result1의 결과가 소수점 이하 부분을 버리기 때문에 2가 산출되리라는 것을 이미 알고 있다.  
그러면 result2는 어떨까?  
이 경우 정수끼리의 연산 산출 결과인 2가 먼저 나오고, 이를 실수화하기 때문에 변수의 값은 2.0이 된다.  
만약 2.5를 저장하고 싶다면 2개의 피연산자 중 하나를 강제 타입 변환해야 한다.

- char 타입도 정수 타입이므로 산술 연산이 가능
  - 주의할 점은 char 타입이 산술 연산이 될 경우 int 타입으로 변환되므로 산출 타입은 int 타입

```java
public class CharOperationExample {
  public static void main(String[] args) {
    char c1 = 'A' + 1;
    char c2 = 'A';
    char c3 = c2 + 1; //컴파일 에러
  }
}
```

`'A' + 1`에서 'A'는 65라는 유니코드를 가지므로 이에 1을 더해서 66이라는 유니코드를 가진 'B'가 c1 변수에 저장된다.  
Java에서 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산하기 때문에 이렇게 char 문자와 정수를 연산해도 char 타입에 저장할 수 있다.  
그러나 `c2 + 1`에서는 c2가 int 타입으로 변환되고 산출 타입도 int 타입이 되기 때문에 char 타입에 저장할 수 없게 된다.  
이 문제 또한 강제 타입 변환으로 해결할 수 있다.

```java
char c3 = (char) (c2 + 1);
```

<br>

### 오버플로우 탐지

- 산술 연산을 할 때 연산 후 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 함
  - 표현할 수 없는 값일 경우, 오버플로우 발생 및 쓰레기값 산출
- try-catch 예외 처리를 통해 이를 방지할 수 있음

```java
public class CheckOverflowExample {

  public static void main(String[] args) {
    try {
      int result = safeAdd(2000000000, 2000000000);
      System.out.println(result);
    } catch(ArithmeticException e) {
      System.out.println("오버플로우가 발생하여 정확하게 계산할 수 없음");
    }
  }

  public static int safeAdd(int left, int right) {
    if (right > 0) {
      if (left > Integer.MAX_VALUE - right) {
        throw new ArithmeticException("오버플로우 발생");
      }
    } else {
      if (left < Integer.MIN_VALUE - right) {
        throw new ArithmeticException("오버플로우 발생");
      }
    }
    return left + right;
  }

}
```

※ ArithmeticException은 **연산 예외** 를 뜻함

<br>

### 정확한 계산은 정수 사용

- 정확한 계산이 필요하다면 부동소수점 타입은 피할 것

```java
public class AccuracyExample1 {
  public static void main(String[] args) {
    int apple = 1;
    double pieceUnit = 0.1;
    int number = 7;

    double result = apple - number * pieceUnit;

    System.out.println("사과 한개에서 ");
    System.out.println("0.7 조각을 빼면, ");
    System.out.println(result + "조각이 남는다.");
  }
}

/*
사과 한개에서
0.7 조각을 빼면,
0.29999999999999993 조각이 남는다.
*/
```

이진 포맷의 가수를 사용하는 부동소수점 타입(float, double)은 0.1을 정확히 표현할 수 없으므로 근사치로 처리한다.  
정확한 계산이 필요하다면 정수 연산으로 변경해서 계산해야 한다.

```java
public class AccuracyExample2 {
  public static void main(String[] args) {
    int apple = 1;

    int totalPieces = apple * 10;
    int number = 7;
    int temp = totalPieces - number;

    double result = temp / 10.0;

    System.out.println("사과 한개에서 ");
    System.out.println("0.7 조각을 빼면, ");
    System.out.println(result + "조각이 남는다.");
  }
}

/*
사과 한개에서
0.7 조각을 빼면,
0.3 조각이 남는다.
*/
```

<br>

### NaN과 Infinity 연산

- `/` 또는 `%` 연산자를 사용할 때 주의해야 할 점
  - 좌측 피연산자가 정수이고 우측 피연산자가 `0`이라면 **ArithmeticException** 발생
  - 실수 타입인 `0.0` 또는 `0.0f`로 나눌 경우 예외가 발생하지 않고, `/` 연산의 결과는 **Infinity** 값을 가지고, `%` 연산의 결과는 **NaN** 을 갖게 됨
    - Infinity와 NaN에 대해서는 다음 연산을 수행하면 안 됨 (어떤 수와 연산하더라도 Infinity와 NaN 산출)
    - `Double.isInfinite` 와 `Double.isNaN` 을 활용해서 값을 확인해볼 수 있음

<br>
<br>

## 문자열 연결 연산자 (+)

- 피연산자 중 한쪽이 문자열이면 `+` 연산자는 문자열 연결 연산자로 사용됨
  - 다른 타입과 함께 써도 해당 값이 문자열 값으로 자동 타입 변환되어 문자열로 결합됨

```java
"JDK" + 3 + 3.0;  //"JDK33.0"
3 + 3.0 + "JDK";  //"6.0JDK"
```

문자열과 숫자가 혼합된 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행되므로, 어떤 것이 먼저 연산되는지 유의할 필요가 있다.

<br>
<br>

## 비교 연산자 (<, <=, >, >=, ==, !=)

- 대소 또는 동등을 비교해서 boolean 타입 값 산출
- 대소 연산자는 boolean 타입을 제외한 모든 기본 타입에 사용 가능
- 동등 연산자는 모든 타입에 사용 가능
- 흐름 제어문인 조건문, 반복문에서 주로 사용됨

| 구분 |  연산식  | 설명                         |
| :--: | :------: | :--------------------------- |
| 동등 | `x == y` | x와 y가 같은지 검사          |
| 동등 | `x != y` | x와 y가 다른지 검사          |
| 대소 | `x > y`  | x가 y보다 큰지 검사          |
| 대소 | `x >= y` | x가 y보다 크거나 같은지 검사 |
| 대소 | `x < y`  | x가 y보다 작은지 검사        |
| 대소 | `x <= y` | x가 y보다 작거나 같은지 검사 |

- 만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산 수행

```java
'A' < 'B' → 65 < 66
```

- 비교 연산자에서도 연산 수행 전에 타입 변환을 통해 피연산자의 타입을 일치시킴
  - 그러나 이진 포맷의 가수를 사용하는 모든 부동소수점 타입은 예외가 있음

```java
'A' == 65 //'A'는 보다 큰 타입인 65의 int 타입으로 자동 변환
3 == 3.0  //3은 보다 큰 타입인 3.0의 double 타입으로 자동 변환

0.1 == 0.1f //false
```

0.1f는 0.1의 근사값으로 표현되어 0.10000000149011612와 같은 값이 되어버린다.  
이를 해결하기 위해서는 두 피연산자 모두 float 타입이 되도록 강제 타입 변환을 하거나 정수로 변환해야 한다.

<br>

- String 타입의 경우 대소 연산자를 사용할 수 없고, 동등 비교 연산자는 사용할 수 있으나, 가지고 있는 문자열 값이 같은지, 다른지를 비교할 수는 없음

```java
String strVar1 = "남궁민";
String strVar2 = "남궁민";
String strVar3 = new String("남궁민");

strVar1 == strVar2  //true
strVar2 == strVar3  //false
```

Java는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어 있다.  
따라서 strVar1과 strVar2는 동일한 String 객체의 번지값을 가지고 있다.  
그러나 strVar3은 객체 생성 연산자인 new로 생성한 새로운 String 객체의 번지값을 가지고 있다.  
만약, 동일한 String 객체이건 다른 String 객체이건 상관없이 String 객체의 문자열만 비교하고 싶다면 `==` 연산자 대신에 `equals()` 메소드를 사용해야 한다.

```java
strVar1.equals(strVar2);  //true
strVar2.equals(strVar3);  //true
```

<br>
<br>

## 논리 연산자 (&&, \|\|, &, \|, ^, !)

- 논리곱(&&), 논리합(\|\|), 배타적 논리합(^), 논리 부정(!) 연산 수행
- 논리 연산자의 피연산자는 boolean 타입만 사용 가능

|        구분         |               연산식                | 결과  |
| :-----------------: | :---------------------------------: | :---: |
|    AND (논리곱)     |    `true && true` `true & true`     | true  |
|    AND (논리곱)     |   `true && false` `true & false`    | false |
|    AND (논리곱)     |   `false && true` `false & true`    | false |
|    AND (논리곱)     |  `false && false` `false & false`   | false |
|     OR (논리합)     |   `true \|\| true` `true \| true`   | true  |
|     OR (논리합)     |  `true \|\| false` `true \| false`  | true  |
|     OR (논리합)     |  `false \|\| true` `false \| true`  | true  |
|     OR (논리합)     | `false \|\| false` `false \| false` | false |
| XOR (배타적 논리합) |            `true ^ true`            | false |
| XOR (배타적 논리합) |           `true ^ false`            | true  |
| XOR (배타적 논리합) |           `false ^ true`            | true  |
| XOR (배타적 논리합) |           `false ^ false`           | false |
|   NOT (논리부정)    |               `!true`               | false |
|   NOT (논리부정)    |              `!false`               | true  |

- `&&`와 `&`는 산출 결과는 같지만 연산 과정이 조금 다름
  - `&&`는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false 산출 (더욱 효율적임)
- `\|\|`와 `\|`의 경우에도 마찬가지
  - `\|\|`는 앞의 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true 산출
