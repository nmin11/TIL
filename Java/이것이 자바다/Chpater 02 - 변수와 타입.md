# 변수

## 변수의 선언

변수의 이름은 Java 언어에서 정한 naming convention을 따라야 한다.

- 첫 글자는 문자이거나 `$`, `_` 이어야 하고, 숫자로 시작할 수 없음
- 영어 대소문자가 구분됨
- 문자 길이 제한 없음
- Java 예약어(타입, 접근 지정자, 제어문 등) 사용 불가
- 첫 글자는 영어 소문자로 시작하고, 다른 단어가 붙을 경우 해당 단어의 첫 글자를 대문자로 함 (관례)

<br>
<br>

## 변수의 사용

변수의 초기값은 코드에서 직접 입력하는 경우가 많은데, 소스 코드 내에서 직접 입력된 값을 **literal** 이라고 부른다.  
리터럴은 값의 종류에 따라 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴로 구분된다.  
이 리터럴들은 정해진 표기법대로 작성되어야 한다.

<br>

### 정수 리터럴

- 소수점이 없는 정수 리터럴은 10진수로 간주

```java
0, 75, -100
```

- 0으로 시작되는 리터럴은 8진수로 간주

```java
02, -04
```

- 0x 또는 0X로 시작하며, A~F 또는 a~f로 구성된 리터럴은 16진수로 간주

```java
0x5, 0xA, 0xB3, 0xAC08
```

※ 정수 리터럴을 저장할 수 있는 타입은 **byte, char, short, int, long** 이렇게 5개이다.

<br>

### 실수 리터럴

- 소수점이 있는 리터럴은 10진수 실수로 간주

```java
0.25, -3.14
```

- E 또는 e가 있는 리터럴은 10진수 지수와 가수로 간주

```java
5E7     //5 * 10⁷
0.12E-5 //0.12 * 10­⁻⁵
```

※ 실수 리터럴을 저장할 수 있는 타입은 **float, double** 이다.

<br>

### 문자 리터럴

- `''` 로 묶은 텍스트는 하나의 문자 리터럴로 간주

```java
'A', '한', '\t', '\n'
```

- `\` 가 붙은 문자 리터럴은 escape 문자라고도 하며 특수한 용도로 사용됨

| escape 문자 |            용도            |    유니코드     |
| :---------: | :------------------------: | :-------------: |
|    '\t'     |          수평 탭           |     0x0009      |
|    '\n'     |          줄 바꿈           |     0x000a      |
|    '\r'     |            리턴            |     0x000d      |
|    '\"'     |            `"`             |     0x0022      |
|    '\''     |            `'`             |     0x0027      |
|    '\\'     |            `\`             |     0x005c      |
| '\u16진수'  | 16진수에 해당하는 유니코드 | 0x0000 ~ 0xffff |

※ 문자 리터럴을 저장할 수 있는 타입은 **char** 뿐이다.

<br>

### 문자열 리터럴

- `""` 로 묶은 텍스트는 문자열로 간주
- 안에 텍스트가 없을 경우에도 문자열로 간주
- 문자열 리터럴 내부에서도 escape 문자 사용 가능

```java
"로코"
"탭 만큼 이동 \t 합니다."
"한줄 내려쓰기 \n 합니다."
```

※ 문자열 리터럴을 저장할 수 있는 타입은 **String** 뿐이다.

<br>

### 논리 리터럴

```java
true, false
```

※ 문자열 리터럴을 저장할 수 있는 타입은 **boolean** 뿐이다.

<br>
<br>

# 데이터 타입

## 원시(primitive) 타입

- 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입
- 정수의 경우, 메모리 사용 크기가 n bit라고 할 때, `-2ⁿ⁻¹ ~ 2ⁿ⁻¹-1` 의 값을 저장할 수 있음
  - 양수에 `-1` 이 붙는 이유는 0이 포함되기 때문

| 값의 종류 | 기본 타입 | 메모리 사용 크기 | 저장되는 값의 범위                              |
| :-------: | :-------: | :--------------: | :---------------------------------------------- |
|   정수    |   byte    |   1byte (8bit)   | -2⁷ ~ 2⁷-1 (-128 ~ 127)                         |
|   정수    |   char    |  2byte (16bit)   | 0 ~ 2¹⁶-1 (유니코드 \u0000 ~ \uFFFF, 0 ~ 65535) |
|   정수    |   short   |  2byte (16bit)   | -2¹⁵ ~ 2¹⁵-1 (-32,768 ~ 32,767)                 |
|   정수    |    int    |  4byte (32bit)   | -2³¹ ~ 2³¹-1 (-2,147,483,648 ~ 2,147,483,647)   |
|   정수    |   long    |  8byte (64bit)   | -2⁶³ ~ 2⁶³-1                                    |
|   실수    |   float   |  4byte (32bit)   | (+/-)1.4E-45 ~ (+/-)3.4028235E38                |
|   실수    |  double   |  8byte (64bit)   | (+/-)4.9E-324 ~ (+/-)1.7976931348623157E308     |
|   논리    |  boolean  |   1byte (8bit)   | true, false                                     |

<br>
<br>

## 정수 타입

### byte 타입

- 색상 정보 및 파일 또는 이미지 등의 이진 데이터를 처리할 때 주로 사용됨
- -128 ~ 127 범위를 초과하는 값을 저장하려고 하면 `Type mismatch: cannot convert from int to byte` 발생
- 이미 범위 안의 값을 저장해두었는데, 해당 변수의 값이 변경되어 범위를 초과할 경우, 127을 넘어선 값이 -128부터 다시 시작하게 됨
  - 이러한 값을 쓰레기값이라고 함
  - 이러한 방식은 short, int, long에도 동일하게 적용됨

<br>

### char 타입

- Java는 모든 문자를 **Unicode** 로 처리
  - 유니코드는 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약
  - 하나의 문자에 대해 하나의 코드값 부여
  - 0 ~ 65535 범위의 2byte 크기를 가진 정수값
  - 0 ~ 127 : ASCII 문자 (특수기호 및 영어 알파벳) 할당
  - 44032 ~ 55203 : 한글 11172자 할당
  - 자세한 정보는 http://www.unicode.org 참고
- `''` 로 감싼 문자가 아닌, 유니코드 정수값을 직접 저장할 수도 있음

```java
char c = 65;
char c = '\u0041'
```

- 반대로 char 변수에 저장된 유니코드의 정수값을 알고 싶다면 char 타입 변수를 int 타입에 저장하면 됨

```java
char c = 'A';
int uniCode = c;
```

- 단순히 초기화 목적으로 `''` 안이 비어있는 빈 문자를 대입하면 컴파일 에러 발생
  - 공백(유니코드 32)을 하나 포함해서 초기화해야 함

```java
char c = '' //컴파일 에러 발생
char c = ' '
```

<br>

### short 타입

- C 언어와의 호환을 위해 사용됨
- Java에서는 잘 사용되지 않는 타입

<br>

### int 타입

- Java에서 정수 연산을 하기 위한 기본 타입
  - 만약 byte 또는 short 타입의 변수를 + 연산하면 int 타입으로 변환됨
- 8진수를 저장할 경우 앞에 `0`을 붙이고, 16진수를 저장할 경우 앞에 `0x`를 붙임

```java
int number = 10;
int octNumber = 012;
int hexNumber = 0xA;
```

<br>

### long 타입

- 범위 : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2⁶³ ~ 2⁶³-1)
- 수치가 큰 데이터를 다루는 프로그램에서 필수적으로 사용됨
  - ex) 은행 및 우주와 관련됨 프로그램들
- 변수를 초기화할 때 정수값 뒤에 `l`이나 `L`을 붙여줘야 함
  - 8byte 정수임을 컴파일러에게 알려주기 위한 목적
  - 일반적으로 소문자 `l`은 숫자 `1`과 혼동되기 쉽기 때문에 대문자 `L`을 주로 사용

<br>
<br>

## 실수 타입

- float과 double의 메모리 사용 크기는 4byte, 8byte로, 각각 int, long의 메모리 사용 크기와 같지만, 다른 저장 방식을 사용하기 때문에 훨씬 더 큰 범위 저장 가능
  - **부동 소수점(floating-point)** 방식으로 저장
- float은 실수값 뒤에 `f`나 `F`를 붙여줘야 함

```java
+ m X 10ⁿ

+ : 부호
m : 가수 (mantissa)
n : 지수 (exponent)
```

- 가수 m은 `0 <= m < 1` 범위의 실수
  - ex) 실수 1.2345를 부동 소수점으로 표시하면 `0.12345 * 10¹` 이 되고, 지수는 1
- float과 double은 가수와 지수를 저장하기 위해 전체 bit를 나누어 사용
  - float : 부호(1bit) + 지수(8bit) + 가수(23bit) = 32bit = 4byte
  - double : 부호(1bit) + 지수(11bit) + 가수(52bit) = 64bit = 8byte
  - double은 float에 비해 가수를 표현하는 데에 있어서 2배가 넘는 자릿수가 배정되어 있기 때문에 더욱 정밀한 값을 얻을 수 있음
- 만약 정수 리터럴에 10의 지수를 나타내는 `E` 혹은 `e`가 있다면 정수 타입에 저장할 수 없으며, 실수 타입에 저장해야만 함

<br>
<br>

## 논리 타입

- 2가지 상태값을 저장할 필요성이 있을 경우에 사용됨
  - 상태값에 따라 조건문과 제어문의 흐름을 변경하는 데에 주로 사용됨
