# Mapping

## Entity and value mapping rule (with JPA)

- aggregate root는 entity이므로 `@Entity`로 매핑
- 한 테이블에 entity와 value가 같이 있다면
  - value는 `@Embeddable`로 매핑
  - value의 property는 `@Embedded`로 매핑

```java
@Entity
@Table(name = "order")
public class Order {
  @Embedded
  private Orderer orderer;

  @Embedded
  private ShippingInfo shippingInfo;
}
```

```java
@Embeddable
public class Orderer {
  @Embedded
  @AttributeOverrides(
    @AttributeOverride(name = "id", column = @Column(name = "order_id"))
  )
  private MemberId memberId;

  @Column(name = "orderer_name")
  private String name;
}
```

```java
@Embeddable
public class ShippingInfo {
  @Embedded
  @AttributeOverrides({
    @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zipcode")),
    @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
    @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
  })
  private Address address;

  @Column(name = "shipping_message")
  private String message;

  @Embedded
  private Receiver receiver;
}
```

## Basic Constructor

- JPA에서는 `@Entity`와 `@Embeddable` 클래스 매핑을 위해 기본 생성자를 제공해야만 함
- JPA의 기본 생성자는 JPA provider가 객체를 생성할 때만 사용

```java
@Embeddable
public class Receiver {
  @Column(name = "receiver_name")
  private String name;
  @Column(name = "receiver_phone")
  private String phone;

  protected Receiver() {}

  public Receiver(String name, String phone) {
    this.name = name;
    this.phone = phone;
  }
}
```

## AttributeConverter

- 2개 이상의 property를 한 개의 column에 매핑할 때 사용

```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {
  @Override
  public Integer convertToDatabaseColumn(Money money) {
    return money == null ? null : money.getValue();
  }

  @Override
  public Money convertToEntityAttribute(Integer value) {
    return value == null ? null : new Money(value);
  }
}
```

```java
@Entity
@Table(name = "purchase_order")
public class Order {
  @Column(name = "total_amounts")
  private Money totalAmounts;
}
```

※ `autoApply` 값이 false인 경우, 해당 column에 직접 `@Convert` 어노테이션을 달아야 함

## Value collection - table mapping

- value collection을 별도의 테이블로 매핑해서 entity에 포함시키는 방법

```java
@Entity
@Table(name = "purchase_order")
public class Order {
  @EmbeddedId
  private OrderNo number;

  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
  @OrderColumn(name = "line_idx")
  private List<OrderLine> orderLines
}

@Embeddable
public class OrderLine {
  @Embedded
  private ProductId productId;

  @Column(name = "price")
  private Money price;

  @Column(name = "quantity")
  private int quantity;

  @Column(name = "amounts")
  private Money amounts;
}
```

- `@OrderColumn`은 지정한 column 리스트의 index 값 지정
- `@CollectionTable`은 value를 저장할 테이블 지정
- `joinColumn` 속성은 외부키를 지정하는데, 여러 개인 경우 `@JoinColumn`을 사용

## Value collection - column mapping

- 예시 - 도메인 모델은 Set으로 보관하고 DB에는 하나의 column에 `,`로 구분해서 저장하는 경우
- `AttributeConverter`를 사용하면 value collection을 하나의 column에 매핑 가능
  - 단 value collection을 표현하는 새로운 value 타입을 추가해야 함

※ value collection 타입 추가

```java
public class EmailSet {
  private Set<Email> emails = new HashSet<>();

  public EmailSet(Set<Email> emails) {
    this.emails.addAll(emails);
  }

  public Set<Email> getEmails() {
    return Collections.unmodifiableSet(emails);
  }
}
```

※ value collection을 위한 AttributeConverter 구현

```java
public class EmailConverter implements AttributeConverter<EmailSet, String> {
  @Override
  public String convertToDatabaseColumn(EmailSet attribute) {
    if (attribute == null) return null;
    return attribute.getEmails().stream()
      .map(email -> email.getAddress())
      .collect(Collectors.joining(","));
  }

  @Override
  public EmailSet convertToEntityAttribute(String dbData) {
    if (dbData == null) return null;
    String[] emails = dbData.split(",");
    Set<Email> emailSet = Arrays.stream(emails)
      .map(value -> new Email(value))
      .collect(toSet());
    return new EmailSet(emailSet);
  }
}
```

※ 실제 column에 사용

```java
@Column(name = "emails")
@Convert(converter = EmailSetConverter.class)
private EmailSet emailSet;
```
