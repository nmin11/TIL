# Concepts

- 도메인 객체 모델이 복잡해지면 각 객체 간의 관계 위주로 이해하게 되고, 전체 구조를 파악하기 어려워짐
- 이 말은 코드의 변경 및 확장이 어려워진다는 뜻!
  - 상위 수준의 모델이 어떻게 되어 있는지를 잘 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 반영할 수 있음
  - 상위 수준을 이해하지 않고 꼼수로 당장 돌아가는 코드를 추가하면 장기적으로 더 코드를 수정하기 어려워짐
- 상위 수준에서 모델을 조망할 수 있는 방법이 바로 aggregate
- 모델을 이해하도록 도움을 주며, 일관성을 관리하는 기준이 됨
- 복잡도가 낮아지는 만큼 개발 리소스도 줄어듦
- 한 aggregate에 속한 객체는 동일하거나 유사한 life-cycle을 가짐
- 한 aggregate에 속한 객체는 다른 aggregate에 속할 수 없음
- aggregate 간의 경계를 설정할 때 도메인 규칙과 요구사항이 기본이 됨
- 포함 관계가 있다면 한 aggregate에 속할 가능성이 높지만, 무조건 그런 것은 또 아님
- 함께 생성되고, 함께 변경되는지 여부를 살펴볼 것!
- 사실, 다수의 aggregate가 하나의 entity 객체만을 갖는 경우가 많음

<br>

# Aggregate Root

- aggregate에 속한 모든 객체가 일관된 상태를 유지하기 위해 전체를 관리할 주체가 필요
- root의 핵심 역할은 aggregate의 일관성이 깨지지 않도록 하는 것
- 그러므로 aggregate에 속한 다른 entity의 주요 로직들도 root에서 구현하는 것이 좋음
- root는 구성요소들의 상태를 참조만 하는 것이 아니라 기능 실행을 위임하기도 함
- aggregate 외부에서는 내부 객체를 변경할 수 없도록 package 단위나 protected 범위로 한정해서 변경되도록 해야 함
- 한 transaction에서는 한 aggregate만 수정되어야 함!
  - 2개 이상을 처리할 경우 충돌이 발생할 가능성이 높아짐
  - 부득이하게 2개를 수정해야 한다면 응용 layer에서 각 aggregate의 상태를 변경하도록 해야 함
