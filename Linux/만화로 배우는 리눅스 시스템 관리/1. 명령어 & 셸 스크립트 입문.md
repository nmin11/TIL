## SSH : 다른 컴퓨터를 리모트로 조작하고 싶어

- SSH는 Secure Shell의 약어
- 다른 PC에 네트워크 경유로 로그인해서 조작할 수 있게 함
- 통신 경로는 암호화
- 인터넷 경유라도 IP 주소만 알면 리모트 조작 가능
- 접속 명령어 예시 : `ssh user@192.168.11.5`
- X를 활용해서 리눅스 화면 표시 및 입력을 다룰 수도 있음
  - 명령어 예시 : `ssh -Y -C user@192.168.11.5` 이후 `nautilus`
  - `-Y`는 X 전송 지정, `-C`는 통신 내용 압축
  - X를 통해 다른 PC에서 동작하는 프로그램을 자기 PC 화면에 표시해서 조작 가능
  - 간단한 리모트 데스크톱 개념
- SSH 접속 끊기 명령어 : `exit`

※ rsh(Remote Shell) : 같은 원격 조작의 기능이지만 통신의 암호화가 없음

<br>

## sudo : 임시로 관리자 권한을 얻고 싶어

- 리눅스의 접근 권한 : 모든 파일이나 폴더에 누구 것인지, 누가 읽고 쓰는지에 대한 권한을 설정함
- 접근 권한은 파일 소유자가 아니면 바꿀 수 없지만 root는 예외
  - root는 관리자 권한을 가진 특별 사용자로, 파일 접근 권한 변경 및 파일 수정 등 모든 것이 가능함
  - 그러므로 root 암호는 철저하게 관리해야 하며, 우분투는 root 로그인을 막기도 함
- root는 미리 정한 특정 사용자에게 root와 같은 권한 부여 가능
- `sudo`를 사용하면 자신의 관리자 권한을 행사할 수 있음
- GUI에서도 `sudo`와 같은 기능 실행 가능
  - 예시 : `gksudo --sync nautilus`

※ 우분투에서 꼭 root로 로그인해야 한다면 `sudo -i` 또는 `sudo su`를 활용하면 됨

<br>

## grep : 다양한 문자열을 한 번에 검색하고 싶어

- global regular expression print
  - 파일 전체에서 정규 표현식과 일치하는 위치를 출력하라
- 파일 내용을 확인해서 찾는 문자열이 포함되었는지 조사
- 예시 : `grep -r "검색할 문자열" /home/docs/`
  - `-r` : 서브 폴더까지 검색하도록 지정
  - `/home/docs` : 찾을 파일이 있는 폴더 경로(검색 시작점)
- 검색 시 `발견된 파일 위치: 발견된 위치의 텍스트` 형태로 출력

※ `-i`를 사용해서 대소문자 구분 없이 검색할 수도 있음

<br>

## vim : 터미널에서도 대화형으로 파일을 편집하고 싶어

- 파일이 열렸으면 `i` 키로 수정하고 `esc` 키로 편집을 끝냄
- vim의 기본이 되는 vi는 일반적인 PC가 없을 때 키보드, 마우스 등이 없던 환경을 위해 만들어졌음
  - 그래서 하나의 키가 여러 역할을 하도록 설계되었던 것
  - 그러다보니 INSERT와 같은 모드가 생겨났음
- vim의 모드들
  - 노멀 모드 : 시작했을 때의 홈 화면
  - `i` : 끼워넣기 모드, 일반 에디터와 같은 조작 방법
  - `shift + r` : 치환 모드
  - `v` : 선택 모드
  - `/` : 검색 모드
  - `esc` : 어떤 모드에서도 처음 화면으로 돌아가게 해줌
  - 주로 사용하는 것은 노멀 모드와 끼워넣기 모드
- 끼워넣기 모드에서 편집이 끝나면 `esc` → `:wq` 로 저장
  - w : write (디스크에 쓰기)
  - q : quit (vim 종료)
- 검색 모드 사용법 `/문자열`
  - 사용 시 노멀 모드 상에서 찾은 곳으로 스크롤됨
  - 편집 후 다시 노멀 노드로 돌아왔으면 `n` 키를 눌러서 다음으로 찾은 위치 검색 가능
  - 반대 방향으로 다음 위치를 찾으려면 `shift + n`
  - 정규 표현식으로 찾을 수도 있음
    - 예시 : `/\v(CP949|EUC-KR)`
    - `\v`를 앞에 두고 정규표현식을 넣어야 함

※ https://vim.rtorr.com/lang/ko/ 사이트에서 더 많은 명령어 확인 가능

<br>

## yank : vim에서도 복사 & 붙이기 & 되돌리기를 하고 싶어

- vim에서 ctrl + c, ctrl + v 가 안 되는 이유
  - GUI 애플리케이션끼리는 복붙을 공통으로 연계하지만<br>콘솔 애플리케이션은 다른 방식으로 작동하기 때문
  - GNOME 단말(터미널)은 콘솔 애플리케이션을 데스크톱에서 보여주는 "창" 같은 것
  - 그러므로 단말에 하는 조작인지, 그 뒤의 콘솔 애플리케이션에 하는 조작인지를 구별해야 함
  - 간단하게 보면 마우스로도 조작이 가능하면 단말 자체 조작<br>키보드로만 할 수 있는 조작이라면 콘솔 애플리케이션 자체 조작
- 복사하기
  - 노멀 모드에서 복사 시작 위치에 커서를 두고 `v` 키 입력
  - 복사 끝 위치까지 화살표 키를 통해 커서 이동
  - `y` 키를 눌러서 클립보드에 텍스트 복사
    - yank : 끌어당기다
- 붙여넣기
  - 붙이고 싶은 위치로 커서 이동
  - `shift + p` 입력
    - paste : 붙이다
    - `1`, `0`, `shift + p` 와 같이 사용하면 10번 반복해서 붙여넣을 수도 있음
- 콘솔 환경에서의 ctrl + z 는 되돌리기가 아닌 **일시 정지**
  - 실행 중이던 애플리케이션을 백그라운드로 보내고 bash 창을 다시 띄움
  - `fg` 명령어로 다시 애플리케이션 창으로 돌아갈 수 있음
    - background에 있던 애플리케이션을 다시 foreground로 되돌린다는 뜻
- 되돌리기를 하고 싶다면 u 키 입력
  - 노멀 모드에서 해야 함
  - `1`, `0`, `u` 와 같이 사용하면 10번 되돌릴 수 있음
- 되돌리기를 되살리고 싶다면 `ctrl + r` 입력
  - r : redo
  - 마찬가지로 앞에 숫자를 넣어서 원하는 횟수만큼 되살릴 수 있음

<br>

## 가상 터미널 (tmux) : 갑작스러운 네트워크 끊김에서 복귀하고 싶어

- GNOME 단말이 데스크톱 환경에서 콘솔 환경을 들여다보는 창이라면<br>가상 단말은 콘솔 환경에서 GNOME 단말이 하는 것과 같은 걸 하는 애플리케이션
- 사실 가상 단말 쪽이 먼저 생기고 그 다음 GNOME 단말이 생겨난 것
- 가상 단말에도 여러 종류가 있는데, 여기서는 **tmux** 이용
  - `tmux` 명령어를 통해 사용 가능
  - 명령어를 찾지 못할 경우 `sudo apt-get install tmux` 명령을 통해 설치할 것
- 가상 단말은 SSH 접속이 끊기더라도 계속 동작하는 특징이 있음
- 그러므로 `tmux attach`를 실행하면 서버에 남아 있는 tmux 가상 단말에 재접속 가능
- tmux 자체 기능을 사용할 때는 `ctrl + b` 입력
  - `ctrl + b` → `d` : detach
  - `ctrl + b` → `c` : create
  - `ctrl + b` → `p` : previous
  - `ctrl + b` → `n` : next
- `ctrl + b`를 이용하는 이유는 이미 존재하는 다른 조작법과 겹치지 않기 위해서
- ctrl 키와 함께 사용하는 다른 조작법 예시
  - `ctrl + r` : 되살리기
  - `ctrl + c` : 프로세스 종료
  - `ctrl + z` : 프로세스 일시 정지
- tmux의 create, previous, next를 사용하면 새 탭을 열기도 하고 다른 탭으로 이동하기도 함
  - GNOME 단말 탭을 사용하면 그때마다 SSH 접속을 해야되므로 비효율적
  - 반면에 tmux를 사용하면 SSH 접속은 한번만 해도 되고, attach로 끊긴 작업도 접근 가능

※ 다른 가상 단말들

- screen
  - 오래 되었고 유명함
  - 설정을 변경하지 않으면 사용하기 불편
- byobu
  - 이름의 유래는 병풍
  - tmux나 screen을 확장해서 보다 편리하고 간단하게 사용 가능
  - 그러나 가상 단말을 통해 실행하는 다른 애플리케이션에 영향을 많이 끼침

<br>

## 화면 분할 (tmux) : 다른 화면도 보면서 작업하고 싶어

- 가로 분할 : `ctrl + b` → `"`
- 세로 분할 : `ctrl + b` → `%`
- 화면 포커스 이동 : `ctrl + b` → `←↓↑→`
- 분할 해제 : 명령어 `exit`
- 범위 선택 시작 : `ctrl + b` → `[`
- 범위 선택 종료 : `q` or `esc`
- 분할된 화면 크기 조절 : `ctrl + b` → `ctrl` 키를 누른 채로 `←↓↑→`

※ 범위 선택은 원래 복붙을 위한 기능이지만 스크롤을 위해서도 사용할 수 있음

<br>

## 명령어 이력 : 최근 실행한 명령어를 호출하고 싶어

- 명령어 이력 확인 : `vim ~/.bash_history`
- 이전 명령어 : `↑`
- 다음 명령어 : `↓`
- 명령어 이전 이력 검색 : `ctrl + r` → (검색할 문자열 입력)
- 명령어 전방 검색을 위해선 추가 설정이 필요함
  - `vim ~/.bashrc`로 bash 설정 파일 열기
  - `stty stop undef` 추가 입력
  - 이후 `ctrl + s`를 누르면 전방 검색 가능

※ 셸은 사람이 조금만 실수해도 시스템이 망가질 수 있으므로<br>조개처럼 속을 감추고 간단한 명령어로 대화식으로 조작할 수 있게 한 것에서 유래한 말

<br>

## 명령어 이력 검색 : 오래전에 실행한 명령어를 호출하고 싶어

- 명령어 이력의 명령어들은 오랫동안 재실행하지 않으면 오래된 것부터 지워짐
- 이력 개수 늘리는 방법
  - `vim ~/.bashrc`로 bash 설정 파일 열기
  - `export HISTSIZE 10000`, `export HISTFILESIZE=10000`
    - 두 값의 숫자를 마음대로 지정할 수 있지만 둘 다 같은 값을 가져야 함
    - HISTSIZE : 메모리에 저장할 이력의 최대 건수
    - HISTFILESIZE : .bash_history에 저장할 이력의 최대 건수

※ .bash_history와 메모리 복사본을 자주 동기화하도록 .bashrc에 추가하기

```sh
function share_history {
  history -a
  history -c
  history -r
}
PROMPT_COMMAND='share_history'
shopt -u histappend
```

※ SSH에서 실행할 명령어가 하나 뿐이라면?

```sh
mint@mintpc:~$ ssh mint@server /scripts/do_backup.sh
```

=> 위 명령어와 같이 서버명 뒤에 바로 실행할 명령어를 적어주면 됨

<br>

## scp : 네트워크 건너서 파일을 복사하고 싶어

- Secure Copy의 약자
- 네트워크를 통해서 파일을 복사하는 명령어
- CentOS 등의 배포판에서는 `yum install openssh-clients` 로 설치해야 함
- 예시 : `scp ./file.ext mint@192.168.1.10:/tmp/`
- `cp` 명령어와 비슷하지만 복사할 곳으로 다른 컴퓨터를 지정할 수 있음
- `scp` 실행 시 SSH 호출하고 이 통신 경로를 통해 파일을 보냄
- 사용법 : `scp (원본 위치) (복사 위치)`
- 와일드카드 혹은 `-r` 옵션으로 디렉토리 전체 복사도 가능
  - 예시 : `scp -r ./directory user@host:/tmp/`

<br>

## top : 시스템 과부하를 파악하고 싶어

- 시스템 부하 관련 정보를 수초 간격으로 갱신하면서 표시해줌
- load average : CPU가 처리하는 걸 기다리는 작업 개수, 1분당 평균 몇 개의 일이 쌓이는지
  - 코어 수에 맞게 처리 가능
  - 예를 들어 4코어면 load average가 4일 때 충분히 감당 가능함
  - 우측으로 1분간 평균, 5분간 평균, 15분간 평균 순으로 표시됨
- %CPU : 어느 프로세스가 CPU를 많이 쓰는지 표시
- TIME+ : 프로세스가 실제로 CPU를 사용한 시간을 시:분.초 형태로 표시해줌
- COMMAND : 프로세스를 실행했을 때 실행한 명령어 표시
  - 단축되어서 표시되는데, `c`를 눌러서 자세한 명령어 표시 가능
- `q` : 정보를 보는 화면에서 빠져나옴
- 과부하 상태의 프로세스 종료를 원할 때 명령어 : `sudo kill (PID)`
  - PID는 top 화면 왼쪽 끝에 쓰여 있음
  - `kill` 명령어는 성공해도 아무 메시지 표시가 없음
  - `sudo kill 111 222 333 444 555` 와 같이 사용해서 한번에 여러 프로세스를 끌 수 있음

<br>

## top 표시 전환 : 시스템 메모리 부족을 파악하고 싶어

- load average가 높다는 것이 CPU 부하량에 늘 비례하는 건 아님
- 메모리 부족이 원인일 수도 있음
- 대표적으로 디스크 I/O 작업은 오래 걸림
  - HDD에 저장한 파일을 찾거나 읽거나 저장할 때는 시간이 오래 걸림
- CPU는 보통 작업 장소로 메인 메모리를 사용하지만 여유 공간이 부족하면<br>최근에 사용하지 않은 데이터를 정리해서 메모리 빈 공간을 만들어 냄
  - 정리된 데이터는 HDD에 옮기는데 이를 스왑아웃이라고 함
  - 반대로 스왑아웃한 데이터가 필요해지면 HDD에서 메모리로 데이터를 되돌리는데,<br>이를 스왑인이라고 함
  - 양쪽을 다 어우러서 스왑이라고 부름
  - 그리고 스왑은 OS가 알아서 관리하므로 신경 쓰지 않아도 되긴 하지만<br>스왑이 너무 빈번해지면 load average가 높아짐
- %MEM : 프로세스가 사용하는 메모리량
  - `shift + m` : 메모리 소비량이 큰 것이 상위에 표시됨
  - `shift + t` : 시간 순서로 나열
  - `shift + p` : CPU 사용량 순서로 복귀
- 프로그램은 필요할 때만 사용하는 것과 계속 실행시켜야 하는 것이 있으므로 잘 가려서 꺼야 함
- 상주형 프로세스는 서비스라고 부르는데, 서비스 전용 실행, 종료 방법은 **기동 스크립트**
  - service 명령어 예시 : `sudo service apache2 restart`
- OOM Killer : 스왑이 너무 많아져서 HDD도 가득 차면 OS가 정지되지 않도록<br>적당히 프로세스를 골라서 강제 종료시킴
  - Out of Memory Killer의 약어
  - SSH 접속을 받는 서비스까지 종료시킬 때가 있음

<br>

## 파이프라인 : 로그 파일에서 필요한 줄만 뽑고 싶어

- 사용 방법 : `(출력을 넘기는 명령어) | (출력을 받는 명령어)`
- `grep`와 함께 사용하여 검색 범위를 좁힐 수 있음
- 파이프라인을 다루기 위한 여러 그룹들
  - 파일 내용을 출력하는 시작 그룹
    - `cat` : 비압축 텍스트 파일용 읽기
    - `zcat` : gzip용 읽기(.gz .tgz)
    - `xzcat` : xz용 읽기(.xz)
    - `tail -F` : 실시간으로 추가되는 내용 확인
  - 출력을 가공하는 중간 그룹
    - `grep` : 조건에 해당하는 줄만 출력
    - `sort` : 재정렬
    - `cut` : 내용 잘라내기
    - `uniq` : 중복 제거
    - `sed` `awk` : 내용 변경
  - 이전 명령어 출력을 가공하는 최종 그룹
    - `less` : 스크롤할 수 있게 출력
    - `tee` : 파일 저장
    - `wc` : 줄 수나 문자 수 카운트
    - `head` : 첫 부분만 출력

※ GUI 애플리케이션 대다수는 파이프라인에 대응하지 않음

<br>

## 셸 스크립트 : 작업 절차를 자동화하고 싶어

- 셸 스크립트는 셸 작업을 자동화하도록 만든 각본 같은 것
- 실제로는 단순한 텍스트 파일이지만 내부에 명령어 실행 절차가 적혀 있음
- 파이프라인이 명령어를 가로로 연결한다면 셸 스크립트는 세로로 연결함
- 작업 전체가 하나의 스크립트, 작성해두면 몇 번이라도 재사용 가능
- `#!/bin/bash`
  - shebang : 스크립트를 실행할 프로그램(인터프리터) 지정
  - Hash-Bang이라고도 부름
  - 프로그램 경로를 적으면 셸이 스크립트 실행 프로그램을 자동으로 전환해줌
  - 프로그램 종류 : bash, zsh, perl, python, ruby, node
- 셸 스크립트라는 건 bash나 zsh 같이 셸로 실행하는 스크립트의 총칭
- `chmod +x setup.sh`와 같이 작성한 셸 스크립트에 실행 권한 주기
- 셸 스크립트 실행 시 파일명만 적지 말고 실행 경로를 명시해야 함
  - 파일명으로 실행 가능한 건 /bin이나 /usr/bin 같은 특별한 장소뿐
- `if [ $? != 0 ]; then exit; fi`
  - 이전 명령어가 정상 종료했는지 확인해서 이상이 있으면 스크립트 실행 중단
  - 어떤 명령어가 실패했을 때 그 뒷 작업에 영향이 간다면 그 다음 줄에 넣어둘 것
  - 셸 스크립트 실행 시 별도 프로세스가 생기며,<br>`exit` 명령어는 스크립트 실행용으로 생성된 프로세스를 종료하게 됨

<br>

## 셸 변수 : 같은 문자열을 스크립트에서 재사용하고 싶어

- 일괄 치환 : `:%s/원문/수정문`
- 셸 변수 지정 방법 : `변수명=변수내용`
- 셸 변수 사용 방법 : `$변수명` 또는 `${변수명}`
- `tar` 사용법
  - 파일 압축 풀기 : `tar xfv (경로)`
  - 파일 압축 : `tar cfv (경로)`
  - 헷갈리니 `tar_extract="tar xfv"` `tar_compress="tar cfv"` 같은 변수를 사용해줘도 좋음
- `eval` : 문자열로 된 명령어를 실행 가능하게 해줌
  - 예시 : `eval "$tar_extract file.tar.gz"`
- 스크립트는 80자 이내가 되도록 정리하는 게 매너

<br>

## 환경 변수 : 작업 환경과 상태를 정해서 스크립트를 실행하고 싶어

- `env` : 사용 가능한 환경 변수 목록 확인
- 셸 스크립트에서 사용하기 편한 환경 변수
  - `HOME` : 사용자의 홈 디렉토리 경로
  - `PWD` : 현재 디렉토리 경로
  - `EDITOR` : 정해진 텍스트 에디터 경로
  - `PAGER` : 정해진 페이저 경로
  - `USER` : 현재 사용자의 사용자명
  - `GROUP` : 현재 사용자의 그룹명
  - `HOSTNAME` : 머신의 호스트명
- 명령어 치환
  - `$(명령어열)` 혹은 \`명령어열\`로 치환
  - 예시 : `mv result.txt result-$(date +%Y-%m-%d).txt`
  - 파이프라인이나 변수 활용도 가능

<br>

## cut : 로그 파일에서 필요한 줄만 뽑고 싶어

- 파이프로 넘어온 내용의 각 줄마다 필요한 부분만 잘라내고 싶을 때 유용
- 넘어온 내용의 각각의 줄을 `-d` 옵션으로 지정한 구분자로 분할하고<br>`-f` 옵션으로 지정한 위치 부분을 추출한 결과를 모아서 출력
- 예시 : `cut -d " " -f 7`
  - 로그를 공백을 기준으로 나눠서 7번째에 해당하는 내용들만 출력
  - 혹은 `cut --delimiter " " --fields 7`

※ cat : catenate(연결하다)에서 유래한 이름, 원래는 파일을 연결하기 위한 명령어

※ tac : cat과 유사하지만 마지막부터 첫 줄까지 출력하고 끝나는 방식

<br>

## sort / uniq : 같은 내용의 줄을 세어보고 싶어

- sort : 입력된 내용을 알파벳 순서로 재정렬
- uniq : 중복된 내용 제거
  - 하지만 이어진 중복만을 제거함
- 그러므로 sort를 먼저하고 uniq를 쓰면 확실하게 중복을 제거할 수 있음
- uniq는 `--count` 또는 `-c` 옵션을 통해 중복을 제거함과 동시에 몇 번 등장했는지도 알 수 있음
- uniq의 `-c` 옵션은 앞쪽에 표시되므로 이를 다시 sort해서 등장횟수별로 정렬 가능
- sort는 `--reverse` 또는 `-r` 옵션을 통해 내림차순 정렬로 바꿀 수 있음
- head : 앞부분 10줄만 출력
- tail : 뒷부분 10줄만 출력
- head와 tail의 출력 라인 수는 `-n` 옵션으로 변경 가능

※ 첫 N줄, 마지막 N줄을 제외하기

- `tail -n +6`
  - 첫 6줄을 제외한 모든 텍스트
- `head -n -5`
  - 마지막 5줄을 제외한 모든 텍스트

<br>

## sort와 리다이렉트 : CSV 파일을 열의 내용에 따라 정렬하고 싶어

- CSV 파일은 Comma Separated File이므로 `cut` 명령어에 구분자를 `,`로 써서 잘라내기 가능
- `cut -d "," -f 1,3,4,6` 같은 방식으로 사용해서 여러 개의 열을 출력할 수 있음
- 혹은 `cut -d "m" -f 1-3`으로 이어진 열을 함께 출력할 수 있음
- `sort` 명령어도 `cut`과 유사하게,
  - `--field-seperator` 또는 `-t` 옵션을 통해 구분자를 지정하고,
  - `--key` 또는 `-k` 옵션을 통해 열 번호를 지정하면,
  - 해당 열 내용으로 재정렬
- `sort` 명령어는 기본적으로 문자열을 기준으로 정렬함
  - 숫자값으로 정렬하고 싶다면 `--number` 또는 `-n` 옵션을 사용할 것
  - `uniq -c`의 경우에는 숫자가 오른쪽 정렬이었으므로 문자열 기준으로도 잘 정렬되었던 것
  - `--ignore-leading-blanks` 또는 `-b` 옵션을 통해 오른쪽 정렬을 무시하는 문자열 정렬도 가능<br>(참고만 해둘 것)
- `>` : 리다이렉트
  - 이미 파일이 존재하는 경우 지우고 새 파일을 만듦
  - `>>`를 사용하면 기존 파일에 추가
  - 예시1 : `cat items.csv | cut -d "," -f 1-3 | sort -t "," -k 3 -n > ./items-sorted.csv`
  - 예시2 : `echo "12345,추가항목,0" >> ./items-sorted.csv`

※ 탭으로 구분된 파일을 cut하려면

- `-d` 옵션 자체를 지정하지 않으면 탭문자를 구분자로 사용

<br>

## 명령줄 인수 : 명령줄 지정으로 작업 내용을 바꾸고 싶어

- 명령어 라인 인수 : 명령어에 대해 추가 지시를 내리기 위해 스페이스 입력 후 지시 사항을 적는 것
- sh 파일 안에 특정 부분을 변수로 만들고, 실행 시점에 변수의 값들을 전달해주는 방식
- 지정한 순서대로 값 참조
  - `$ script.sh filename1 filename2`

```sh
#!/bin/bash
source=$1
target=$2
```

- 옵션 이름으로 값 참조
  - `$ script.sh -s filename1 -t filename2`

```sh
#!/bin/bash
while getopts s:t: OPT
do
  case $OPT int
    s) source="$OPTARG" ;;
    t) target="$OPTARG" ;;
  esac
done
```

<br>

## 조건 분기 : 조건에 따라 처리 흐름을 바꾸고 싶어

```sh
if [ $# = 2 ]
then
  echo "Hello World!"
fi
```

- `$#`은 실행 시 받은 인수의 개수를 뜻함
- `[`도 하나의 명령어이기 때문에 띄어쓰기를 꼭 지켜줘야 함

```sh
if [ 조건 ]
then
  조건에 맞으면 처리
else
  조건에 맞지 않으면 처리
fi
```

<br>

## 종료 상태 : 명령어 이상 종료에 대응하고 싶어

- 전에도 사용했던 `if [ $? != 0 ]; then exit; fi`에서 `$?`는 바로 이전 명령어의 종료 상태를 나타냄
  - `$?` 값이 0이면 정상 종료, 그 외의 값이면 이상 종료
  - 그리고 줄바꿈 대신 `;`을 이용해서 한 줄에 여러 명령어들을 처리할 수 있음
- `exit` 뒤에 숫자를 적어서 종료 상태를 지정할 수 있음
  - 그냥 `exit`만 적을 경우 `exit 0`와 같은 의미
  - 특별히 에러 종류를 구분할 필요가 없다면 `exit 1`로 지정
  - 종료 상태 범위 : 0 ~ 255

<br>

## for : 같은 처리를 반복해서 실행하고 싶어

```sh
for filename in redmine.log kintai.log download.log notice.log
do
  ./create-report.sh $filename
done
```

- for문 안에서 명령어 치환도 사용 가능

```sh
for filename in `cd /var/log; ls *.log`
```

※ 한 줄로 작성할 경우 주의할 점

- `for ~` `do ~` `if ~` `then ~` 부분은 뒷 내용까지 적고 `;` 붙이기

<br>

## 셸 함수 : 공통 처리를 계속 재사용하고 싶어

```sh
#!/bin/bash

main() {
  report marketing.log mail-$(today).csv /shared/marketing/reports
  report system.log $(today).csv /shared/system/mail-reports
  report develop.log $(today).txt /shared/develop/reports/mail
}

report() {
  source=$1
  report=$2
  outdir=$3
  ./analyze_mail_log.sh $source $report
  mkdir -p $outdir
  mv /tmp/${report} ${outdir}/
  echo "$source 처리 완료"
}

today() {
  date +%Y-%m-%d
}

main
```

- **함수가 받은 인수는 sh 파일 실행 시 받는 인수와는 다름**
- 함수 종료 시에는 `exit` 대신 `return`을 사용해야 함
  - `exit` 사용 시 sh 파일 실행 자체가 종료됨
  - 함수도 `return 1`과 같이 종료 상태값을 지정할 수 있음
