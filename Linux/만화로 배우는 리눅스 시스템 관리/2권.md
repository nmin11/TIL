## crontab : 정기적인 작업을 자동으로 처리하고 싶어

- crond : 리눅스의 지정된 시각에 명령어를 자동 실행하는 서비스
- cronjob : crond로 실행하고 싶은 명령어와 실행 시각
- crontab : cronjob을 관리하는 명령어
- 등록된 cronjob 확인하기 : `sudo crontab -l`
- cronjob 표시 규칙
  - 예시 : `0 3 * * * /scripts/do_backup.sh`
  - 포인트는 분, 시, 일, 월, 요일
  - 시간은 24시간을 기준으로 표시
  - 요일은 일, 월, 화, 수, 목, 금, 토, 일을 0, 1, 2, 3, 4, 5, 6, 7로 표시 (일요일은 0과 7 모두 가능)
  - 즉, 위 예시는 매일 3시 정각에 실행됨
  - `30 2,14 * * * /scripts/do_update.sh` → 오전 2시와 오후 2시에 실행되도록 설정
- cronjob 설정하기
  - 명령어 : `crontab -e`
  - 스크립트를 실행해야 한다면 홈 디렉토리에서의 상대 경로 혹은 절대 경로를 사용해야 함
  - 환경 변수, 표시 화면, 사용자 조작의 차이로 잘 안 될 때가 있으므로 꼭 먼저 테스트해볼 것
  - `MAILTO=nmin1124@gmail.com` 열을 앞에 붙여서 출력 내용을 메일로 보낼 수도 있음
    - 단, MTA가 설정되어 있어야 함

<br>

## 공개키 인증 : 키 인증으로 안전하게 로그인하고 싶어

- 데이터를 공개키를 통해 암호화하고, 비밀키를 통해 복호화하는 방식
- 공개키를 공유하면 제3자는 비밀 정보를 안전하게 보낼 수 있게 되며,<br>비밀키를 가진 본인만 해당 정보를 확인할 수 있게 됨
- 암호 인증과 달리 비밀키 자체가 네트워크에 노출될 일이 없음
- key-pair 생성 방법
  - 명령어 `ssh-keygen` 입력
  - 비밀키의 passphrase 입력
    - 키 인증도 비밀키가 털리면 치명적이므로 한 번 더 암호화하는 과정

<br>

## 패스프레이즈 없는 비밀키

- cronjob에서 scp를 하려고 할 때 발생할 수 있는 문제점
  - scp를 하기 위해 접속하는 서버에 비밀키 패스프레이즈를 입력해야 함
- 이 문제를 해결하기 위해서 비밀키 패스프레이즈를 생략하기도 함
- 대신 해당 공개키 앞줄에 `command=(명령어)`를 적어서 특정 명령어만 사용할 수 있는 방식으로 설정
- 이후 `scp -i` 명령어를 통해 비밀키를 지정해서 실행하면 됨

<br>

## 처리 분산과 느슨한 결합 연계 : 여러 서버에 있는 파일을 효율적으로 수집하고 싶어

- 자동 인증으로 scp하려면 다운로드 허가 대신 업로드 허가를 하는 편이 안전
- 처리 크기는 작게, 처리 사이는 느슨한 결합으로, 커다란 문제는 작은 문제로 쪼개서 생각하기
- 여러 서버가 엮인 처리 과정은 각 서버 단위에서 처리가 완료되도록 해서 서버끼리의 통신 줄이기

<br>

## wc와 산술 확장 : 조건에 해당하는 로그 줄 수를 집계하고 싶어

- Word Count의 약자
- 지정한 파일이나 파이프라인으로 넘어온 내용의 문자수와 줄 수를 세서 그 결과를 돌려줌
- `wc -l` 또는 `wc --lines` : 줄 수 출력
- `wc -w` 또는 `wc --words` : 단어수 출력
- `wc -m` 또는 `wc --chars` : 문자수 출력

※ 예시 : 2022년 3월 20일에서 4월 10일까지의 로그 집계하기

```sh
#!/bin/bash

total_count=0
for log in /oldlog/2014/access.*.gz
do
  pattern="([23][0-9]/Mar|(0[0-9]|10)/Apr)/2022"
  count=$(zcat $log | grep "/campaign" | grep -E $pattern | wc -l)
  total_count=$(($total_count + $count))
done
echo "合計 : ${total_count}"
```

- `$(())` 안에는 계산식을 넣을 수 있음

<br>

## sed : 여러 텍스트 파일을 일괄 편집하고 싶어

- Stream Editor의 약자
- gedit이나 vim은 실시간 대화식으로 편집하는 스크린 에디터
- sed는 텍스트를 어떻게 편집할지를 명령줄 옵션으로 지정해서 지시하는 방식
- `-e` 또는 `--expression` 옵션 하나가 sed에 대한 하나의 지시가 됨
  - 이 옵션은 여러 번 사용 가능
- 일괄 치환 예시 : `sed -e "s/치환전 문자열/치환후 문자열/"`
- 주의사항 : sed 작업 후 리다이렉트해서 저장하려고 할 때,<br>같은 파일을 동시에 작업하려고 하면 충돌이 발생해서 파일이 지워질 수 있음
  - 그러므로 변경 전에 파일을 백업해두고 백업에서의 작업을 원본으로 리다이렉트할 것
- `-i` 옵션으로 파일 저장 가능
  - 옵션 뒤에 확장자명 지정 가능

※ 예시

```sh
#!/bin/bash
for file in *.csv
do
  backup=${file}.$(data +%Y-%m-%d).bak
  mv $file $backup
  cat $backup | sed -e "s/반환중/회수완료/" $file
done
```

※ 스크린 에디터와 스트림 에디터 외에 명령어를 써서 줄 단위로 텍스트를 편집하는 라인 에디터가 있음

- 전자계산기처럼 한 줄만 출력되는 디스플레이를 사용하거나<br>한 줄만 인쇄되는 프린터를 디스플레이 대신에 사용할 때 한 줄씩 대화식으로 편집 가능
- 단말에서 `ed` 명령어를 실행하면 써볼 수 있음

<br>

## 정규 표현식 - 치환, 일치 결과 역참조

- 정규 표현식의 규칙들 : 기본 정규 표현식, 확장 정규 표현식, Perl 호환 정규 표현식 등
- vim 검색이나 치환에서 확장 정규 표현식을 사용할 때 `\v` 뒤에 작성
- sed로 치환할 때 확장 정규 표현식을 사용하려면 `-r` 또는 `-E` 옵션 지정
- 역참조
  - 치환 후를 지정하는 부분에서 번호를 써서 치환 전 내용을 다시 참조하는 방법
  - 예시 : `sed -r -e "s/(Windows XP.+) 사용중 (.+)/\1회수완료\2파기예정/"`
  - 인용하고 싶은 부분을 `()`로 감싸면 됨
  - `()`가 2개 이상이면 순서대로 번호를 적을 것
  - `.` : 임의의 한 문자
  - `+` : 직전 문자가 1회 이상 반복됨을 의미

<br>

## 정규 표현식 - 대소문자 무시, 문자 범위 지정

- `g` 플래그
  - global replacement
  - 한 줄 안에서 해당하는 모든 부분을 치환
  - 예시 : `sed -e "s/Ubuntu 8.04LTS/Ubuntu 12.04LTS/g"`
- `i` 플래그
  - ignore case
  - 대소문자 차이를 무시하고 치환
  - 예시 : `sed -e "s/Windows XP/Windows/i"`
- `gi`를 사용하면 `g` 플래그와 `i` 플래그를 함께 사용할 수 있음
- `[]`
  - 브래킷 표현
  - 연속된 범위를 `-`를 활용해서 적어두어서 범위를 표시
  - 예시 : `sed -e "s/([G-IKMO-R])-/\1-1/"`

<br>

## 정규 표현식 - 범위 밖 문자 지정, 줄 시작과 끝 지정

- `[]` 표현과 `+` `*`를 조합해서 특정 종류 문자만 연속된 문자열 표현 가능
  - `*` : 직전 표현식 0회 이상 반복
  - `+` : 직전 표현식 1회 이상 반복
- `[]` 표현 안에서 `^`로 시작하는 표현은 부정형
  - 특정 종류 문자가 등장하지 않는 조건으로 한정
- `^` : 줄 시작에만 있는 치환 대상을 치환
- `$` : 줄 끝에만 있는 치환 대상을 치환
- 치환할 때 쓰는 `/`는, 만약 치환할 때도 같은 `/`를 사용한다면 `#`으로 대체 가능

※ 책 속의 예제

```sh
#!/bin/bash
cat pclist.csv.bak | \
  sed -r -e "s/Windows XP/Windows/gi" \
  > pclist.csv
cat itemlist.csv.bak | \
  sed -r -e "s/([A-F])-/\1-0/" \
         -e "s/([G-IKMO-R])-/\1-1/" \
  > itemlist.csv
cat setup-manual.md.bak | \
  sed -r -e "s/Ubuntu 8.04LTS/Ubuntu 12.04LTS/g" \
         -e "s/category([0-9]+)/category-\1-/g" \
         -e "s#(://[^:]+):3000/#\1:13000/#"g \
         -e "s/^( +)- /\1* /" \
         -e "s/.$.  /" \
  > setup-manual.md
```

※ `^`와 `$`는 vim에서도 커서를 시작과 끝으로 옮기는 데에 사용 가능

<br>

## find : 오래된 파일 찾아서 지우기

- 이름대로 다양한 조건으로 파일을 검색하는 명령어
- 날짜 기반으로 검색하기
  - 예시 : `find /backup/daily -ctime +30`
  - `-ctime` : changed time, 최종 갱신 시각
  - `+30` : 최종 갱신일보다 30일 이상 오래된 파일들
  - 만약 `30`으로 검색하면 딱 30일 전 파일들을 찾아냄

※ find를 활용해서 최종 갱신이 30일이 넘어간 파일들 지우기

```sh
#!/bin/bash

remove_files="$(find /backup/daily -ctime +30)"
for file in $remove_files
do
  rm "$file"
done
```

- `-30`과 같이 써서, 반대로 30일 이내에 변경된 최신 파일들을 조회할 수도 있음

※ `-atime`과 `-mtime`

- `-atime` : access time, 최종 접근 시각
- `-mtime` : 최종 변경 시각, `-ctime`은 파일 이동, 권한을 아우르는 최종 변경인데,<br>`-mtime`은 파일의 내용이 변경된 최종 변경 시각만을 다룸
- 대부분의 경우에는 `-ctime`을 사용하게 됨

<br>

## find : 더욱 다양한 검색 조건들

- `-name` : 파일명으로 검색
- `-and` : 양옆의 검색 조건을 만족하도록 검색
- `-or` : 양옆 중 하나라도 맞는 조건으로 검색
- 검색 조건은 3개 이상도 조합 가능하며, 우선순위를 지정하려면 `\( \)`로 감싸면 됨
- 예시 조건들
  - `-ctime -8 -and -name "*.log"`<br>일주일 전에 변경된 파일 중 이름이 .log로 끝나는 파일
  - `-ctime +30 -and -ctime -60 -and \(-name "*report*" -or name "*error*"\)`<br>30일보다는 오래되고 60일보다는 새로운 파일 중 이름에 report 또는 error를 포함하는 파일
  - `-name "*.tar.gz" -or \(-ctime +7 -and -name "*.log"\)`<br>이름이 tar.gz로 끝나거나, 일주일 이내에 변경된 이름이 .log로 끝나는 파일

<br>

## df와 숫자 크기 차이로 조건 분기 : 디스크가 가득 차기 전에 파일을 삭제하고 싶어

- `df`
  - Disk Free의 약어
  - 디스크 사용 상태를 표시해주며, 디스크 빈 공간은 이걸로 확인하는 게 정석
  - 디스크 이름 - 디스크 총용량(KB) - 사용량(KB) - 빈 용량(KB) - 사용률 - 디렉토리 위치

※ 용량을 체크해서 오래된 파일을 제거하는 스크립트 예시

```sh
#!/bin/bash

free_size=$(df /data/backup | \
  sed -r -e "s/[^ ]+ +[^ ]+ +[^ ]+ +([^ ]+).+/\1/" | \
  tail -n 1)
required_size=$((10 * 1000 * 1000))

if [ $free_size -lt $required_size ]
then
  files=$(find /data/backup -ctime +30)
  for file in $files
  do
    rm "$file"
  done
fi
```

※ `df`를 더 깔끔하게 해주는 옵션 `--human-readable` 또는 `-h`

- 옵션의 이름 그대로 출력 결과를 사람이 보기 편하게 해줌
- T(테라바이트), G(기가바이트), M(메가바이트) 단위도 유동적으로 표현해줌
