_내가 안다는 걸 안다. 즉, 안다는 사실을 자각한다는 뜻이다._  
_내가 모른다는 걸 안다. 즉, 자신이 모른다는 사실을 아는 상태다._  
_하지만 모른다는 걸 모를 수도 있다. 즉, 자신이 모른다는 사실조차 모르는 상태를 말하는 것이다._

― 도널드 럼즈펠드

<br>

- 소프트웨어 개발자가 되기 위해 알아야 하는 것은 충격적일 만큼 많음
  - 프로그래밍 언어, 소스 제어, 테스트, 지속적 통합, 웹 개발, HTML, CSS, 디자인 패턴, 데이터베이스, 디버깅, 방법론, 스크럼, 애자일 등
- 3부는 소프트웨어 개발자가 되기 위해 알아야 할 모든 것의 기본에 대해 알려줌

<br>
<br>

# 프로그래밍 언어 개요

- 프로그래밍 언어를 다양하게 배울수록 좋은 것은 아님
  - 그러나 주요 프로그래밍 언어는 무엇이고, 각각 어떤 차이가 있는지 정도는 알아두는 게 좋음

<br>

## C

- 1969~1973년 사이에 Dennis Ritchie가 Bell Labs에서 개발한 언어
- 상당히 오래된 프로그래밍 언어이지만 아직도 사용되고 있을 뿐 아니라 인기도 여전함
  - **아마도 세계에서 가장 많이 쓰인 프로그래밍 언어**
- C++, C#, Java, JavaScript 등 주요 프로그래밍 언어 다수가 C에 뿌리를 두고 있음
- **너무 강력하기에 까다로운 언어**
  - 개발자가 컴퓨터 메모리에 접근해서 저수준 영역까지 조작할 수 있게 해주는 low level 언어
- 수많은 운영 체제, 저수준 하드웨어, 임베디드 시스템, 게임 등에서 사용됨
- C를 시스템 프로그래밍 언어로 분류하는 경우가 많음

<br>

## C++

- Bell Labs의 Bjarne Stroustrup이 C 언어에서 Simula의 객체지향성, 클래스, 가상 함수 등과 같은 유용한 기능을 활용하려고 C를 확장한 데서 비롯됨
- 종종 C와 경계가 모호해지는 언어
  - 많은 C++ 개발자가 C++의 객체지향 개념을 이해하지 못해서 C++ 기능으로 C에서 쓸 법한 코드를 작성하기 때문
- 엄밀히 말해 C++는 C의 상위 집합
  - C 프로그램은 C++ 컴파일러로 컴파일해야 하기 때문 (일부 예외는 있음)
- 특히 게임 개발에 많이 쓰임
- 업데이트도 꾸준히 이루어지고 있고 현재는 '모던 C++'라고도 불림
- 매우 복잡한 언어이므로 초보자에게는 추천하지 않음 / 매우 강력한 만큼 조심히 다루어야 함

<br>

## C#

- 마이크로소프트가 .NET Runtime 환경을 대표하는 언어로 만듦
- 훌륭한 표현력에 비해 사용하기 쉬움
- 초기 C#은 Java와 아주 많이 유사했지만 요즘은 꽤 멀어졌음
  - 그럼에도 둘 중 한 언어를 아는 사람이라면 반대편 언어를 이미 90퍼센트 정도 아는 거나 다름없다고 할 수 있음
- C++와 비슷하다고 할 수 있는 객체지향 언어이지만, 훨씬 더 간단하고 기능도 훨씬 많음

<br>

## Java

- 1995년 Sun Microsystems의 James Gosling이 한 번 작성한 코드를 여러 플랫폼에서 실행할 수 있게 만든 언어
  - Java를 모든 컴퓨팅 플랫폼에서 구동되는 가상 머신에서 실행할 수 있게 만들었음
- C와 C++에 기반하는 객체지향적인 언어지만 C#처럼 매우 단순하며, 문제를 일으킬 소지가 있는 메모리 조작 등 저수준 동작은 허용하지 않음
- 현재 Java는 Oracle의 소유이며 여전히 성장하고 있지만, 최근 위원회의 관리를 받고 있는데 여기에 소속된 위원들은 Java의 발전 속도를 늦추고 싶어 함

<br>

## Python

- 1989년 Van Rossum이 만듦
- **가독성을 중요하게 고려해서 만든 우아하고 단순한 언어**
- 객체지향적으로도 절차지향적으로도 심지어 함수형으로도 쓸 수 있으며, Interpreted language, 즉, 컴파일하지 않는 언어
- C++, Java, C#과 비교했을 때 Python의 코드는 훨씬 간결함
  - 더 적은 코드로 더 많은 걸 표현할 수 있음
- 지금도 인기를 끌고 있는데 점점 더 인기가 올라가고 있음
- Google에서 사용하는 주요 프로그래밍 언어 중 하나이기도 하고, 초보가 배우기 좋은 언어

<br>

## Ruby

- Yukihiro 'Matz' Matsumoto가 1993년 일본에서 만듦
- 객체지향적인 스크립트 언어를 만들겠다는 아이디어에서 탄생한 언어
- 초창기에는 그다지 관심을 받지 못했지만 최근에 인기가 높아졌음
- David Heinemeier Hansson이 2003년에 만든 Ruby on Rails(RoR)는 Ruby가 큰 성공을 거두는 데 큰 기폭제 역할을 했음
  - 쉽고 재미있게 프로그래밍을 할 수 있어서 여전히 큰 인기를 누리는 언어이며, 초심자가 배우기 아주 좋은 언어

<br>

## JavaScript

- 1995년 Brendan Eich가 단 10일만에 개발한 언어
  - 아주 짧은 기간에 개발된 탓에 문제가 많음
- C#, Java, C++와 비슷해 보이지만 매우 다르게 작동
- 애초에 단순한 웹용 스크립트 언어였지만 이제는 웹을 넘어서 광범위하게 쓰이는 기본 언어가 되었음
- JavaScript의 최신 버전인 ECMAScript는 기존 단점을 많이 수정한 덕에 대규모 개발에 적합한 형태가 되었음
- 워낙 광범위하게 쓰이는 언어라서 요즘 웹 개발자라면 JavaScript에 대한 지식을 조금이라도 갖춰야 함

<br>

## Perl

- 1987년 Larry Wall이 유닉스용으로 만든 스크립트 언어
- 유연성과 문자열 구문 분석을 할 수 있는 능력 덕분에 웹 초창기에 널리 인기를 끌었음
- 인기가 예전 같지는 않지만 여전히 널리 사용되는 언어
- '스크립트 언어계의 스위스 아미 전기톱'
  - 엄청 유연하고 강력하며 정확성을 갖춤
- 가독성이 떨어져서 내가 혹은 다른 누군가가 이틀 전에 쓴 코드조차 알아보기 힘듦

<br>

## PHP

- 1994년 Rasmus Lerdorf가 만들었고 2014년까지 명문화된 명세 하나 없이 진화했음
- 약간 지저분하다고 느껴지는 언어이지만, JavaScript와 함께 오늘날 웹의 많은 부분을 구성하는 언어
- 애초에 PHP는 프로그래밍 언어가 될 운명은 아니었고, 처음에는 간단한 웹 페이지를 동적으로 만들 수 있는 도구 모음에 불과했음
  - 세상의 빛을 본 후 처음 의도와 다르게 흘러갔음
- 온갖 단점이 있지만 배우기 쉽고 사용하기 쉽다는 큰 장점이 있음
  - 길 잃기 딱 좋은 후미진 골목이 많이 도사리고 있기는 함
- 기존의 PHP 코드를 수정하면서 경험을 쌓는 초보자가 많음

<br>

## Objective-C

- 1980년대 초 Bred Cox, Tom Love가 C에 SmallTalk의 객체지향 기능을 더하겠다는 생각으로 만듦
  - 그 후 잊혀져서 거의 없어질 뻔한 Objective-C를 Apple이 Mac OS X 운영 체제에 쓰면서 부활했음
    - 그렇다고 해서 널리 인기를 끈 것은 아니지만 맥 개발자는 이 언어를 사용해야 했음
    - 그러다가 Apple이 아이폰과 iOS를 소개하면서 수백만 명의 개발자가 이 언어의 낯선 문법과 씨름하게 되었음
- 배우기 어렵고, 아주 간단한 것을 하는 데도 꽤 장황한 코드를 써야 함
- 다행히 요즘 iOS 개발자는 Objective-C보다 약간 더 친절한 Swift를 쓸 수 있음

<br>

## Swift

- Apple이 선택한 새로운 iOS용 대표 언어
- iOS, OS X 개발에 쓰이는 애플의 Cocoa, Cocoa Touch 프레임워크용으로 만들어졌음
- 기존의 많은 Objective-C 코드와도 쉽게 통합될 수 있도록 설계되었음
- Objective-C를 동적이고 유연하게 하는 인기 있는 기능 대부분을 지원하는 동시에 훨씬 더 단순하고 간결함
- iOS 개발을 해볼 생각이라면 Objective-C를 거르고 바로 Swift로 시작해도 좋음

<br>

## Go

- 2007년 Google의 Robert Griesemer, Rob Pike, Ken Thompson이 만들었음
- C와 매우 비슷하지만 몇 가지 훌륭한 추가 기능이 있고 훨씬 단순함
- C와는 달리 Garbage Collection 기능이 있어서 메모리를 관리하지 않아도 됨 / Concurrent(동시성) Programming 기능이 있어서 성능이 크게 좋아졌음
- 잘 설계되어서 문법이 아주 간결함
- 원래는 C처럼 시스템 프로그래밍 언어로 만들어진 언어이지만 나중에 웹을 비롯한 다른 영역까지 퍼져나갔음

<br>

## Erlang

- Ericsson의 Joe Armstrong, Robert Virding, Mike Williams가 1986년에 만들었고 1998년에 오픈 소스로 공개한 언어
- 동시 및 분산 처리를 위해 설계된 기능적이고 매우 흥미로운 프로그래밍 언어
- 코드 hot swapping을 지원하므로 애플리케이션을 멈추지 않고 코드를 변경할 수 있음
- 원래는 전화 통신 애플리케이션 개발을 돕기 위해 만들어졌음
- 오늘날 가장 안정적인 프로그래밍 언어이자 프로그래밍 환경으로 여겨짐

<br>

## Haskell

- 1987년 당시 존재하던 여러 함수형 언어의 공개 표준으로 삼기 위해 설계한 순수 함수형 프로그래밍 언어
  - 학구적인 성격이 매우 강한 언어
- Haskell 1.0은 1990년 위원회에서 만들어졌음
- 최근에는 학구적인 영역을 넘어 점점 더 인기를 얻고 있음
- 순수 함수형 언어이자 강력한 정적 체계를 갖추고 있어서 배우기도, 사용하기도 어렵지만 매우 강력하며, 부작용 없이 예측 가능한 코드를 만들 수 있음

<br>
<br>

# 웹 개발이란 무엇인가?

- 데스크톱 앱이나 모바일 앱에 비해 까다로움
  - 데스크톱이나 모바일 개발에서는 대체로 런타임 환경이 뚜렷하기 때문
  - 윈도우 앱을 만들 때는 .NET을, 맥 OS용 앱을 만들 때는 Objective-C를 사용하면 됨
- 웹 개발을 할 때는 런타임 환경에 대한 통제력이 떨어짐
  - 웹 브라우저 세계에는 IE, Edge, Chrome, Safari, Firefox라는 다섯 강자가 존재하기 때문
  - Opera와 같이, 상대적으로 '약한' 주자도 많음
  - 심지어 모바일 기기, 웹 TV, 비디오 게임 콘솔 등도 고려해야 함
- 맞춰야 할 입맛이 많고, 실수할 여지도 많음
- 그러나 소프트웨어 개발자라면 웹 개발의 기본이라도 알고 있어야 함
  - 오늘날 소프트웨어 개발자 대부분은 웹 개발자
  - 웹 개발은 세상을 점령한 개발 플랫폼계의 킹콩

<br>

## 웹의 간략사

- 초창기 웹은 정적 HTML 페이지를 만드는 데 집중했으며, 모든 탐색은 하이퍼링크를 통해 이루어졌음
  - 웹 개발자의 존재는 필요 없었고 '웹마스터'만 있었음
- 이후 웹 페이지를 인터렉티브하게 만들 방법을 찾아야만 했음
  - 이에 따라 최초의 웹 애플리케이션을 만들 때는 CGI(Common Gateway Interface) 기술이 사용되었음
- 웹 개발자는 웹 브라우저에서 받은 요청을 분석하고 응답을 생성하는 동시에 HTTP 프로토콜을 정확하게 구현해야 했고 유효한 HTML도 작성해야 했음
  - ColdFusion이나 ASP와 같은 웹 개발 프레임워크의 등장으로 이 과정이 쉬워짐
    - 이 때부터 웹 개발자가 특별한 태그, 마크업, 로직을 써서 조건부 HTML을 생성할 수 있게 되었으며, 처음으로 진짜 웹 애플리케이션을 만들 수 있게 되었음
- 하지만 웹 페이지를 보다 더 인터랙티브하게 만들 방법이 필요했음
  - JavaScript를 사용해서 웹 애플리케이션의 능력을 신장시키기 시작
  - CSS(Cascading Style Sheets)를 쓰기 시작하면서 스타일을 쉽게 만들고 변경할 수 있게 됨
- 동적으로 생성되는 예쁜 웹 페이지만으로 만족하지 못했고, 더 인터랙티브하게 더 멋지게 만들 방법이 있어야만 했음
  - 서버에 있는 것을 렌더링하는 건 느려서 즉각 반응한다는 느낌을 받지 못했고,<br>그래서 새로고침을 하지 않아도 웹 페이지가 동적으로 업데이트되게 하는 **AJAX** (Asynchronous JavaScript and XML) 같은 기술이 발명되었음
    - 이런 웹 애플리케이션은 **SPA** (Single Page Application) 라고 불림

<br>
<br>

# 모바일 개발

- 혼자서도 단기간 내에 앱을 개발할 수 있는 아주 특별한 기회 제공
- 게임도 단순한 게임들이 모바일에서는 꽤 많은 사랑을 받음
- 모바일 개발이 개발의 미래가 될 것이라는 의견이 우세

<br>

## 모바일 개발 주요 플랫폼

- 꽤나 최근까지도 모바일 개발이 주목을 받거나 주도적인 플랫폼이 등장하지 않았었음
- 2007년 아이폰이 등장하면서 변화
- 이후 많은 모바일 플랫폼이 나왔다가 사라졌고, 현재 이 시장은 **두 강자** 와 나머지로 나눌 수 있게 됨

<br>

### iOS

- 모바일 기기와 모바일 소프트웨어라는 개념을 완전히 바꾸고 마침내 현시대에 모바일 개발을 등장시킨 주역
- 현재는 아이폰, 아이팟, 아이패드, 애플 워치, 애플 TV에 쓰이지만 앞으로 iOS에서 구동되는 기기는 더 많아질 것
- BSD 계열인 Darwin과 M을 기반으로 하고 있어서 근본적으로 유닉스와 유사함
- 맥 OS와 주요 프레임워크 일부를 공유함
  - iOS의 사용자 인터페이스는 맥 OS에 사용되는 애플 코코아 UI에 기반함
- iOS 애플리케이션은 보통 Objective-C나 Swift를 써서 만드는데 대세는 Swift

<br>

### 안드로이드

- 안드로이드는 iOS보다 약 1년 늦은 2008년 9월에 등장했음에도 시장의 지분을 크게 차지함
  - iOS의 지분이 18퍼센트이고 안드로이드의 지분은 80퍼센트에 달함
- Google이 지원하는 안드로이드는 오픈 소스 (iOS는 그렇지 않음)
- 서로 다른 폼 팩터와 기능을 가진 다양한 하드웨어 플랫폼 기기에서 작동할 수 있게 설계되었음
  - 반면에 iOS는 오로지 애플 기기에서만 작동하도록 설계되었음
- Linux kernel을 기반으로 하며, 안드로이드 OS 애플리케이션 네이티브 개발 플랫폼은 Java

<br>

## 모바일 개발 방법

- 모바일 앱 개발에 쓸 수 있는 프레임워크, 툴, 플랫폼, 생태계가 셀 수 없이 많음
- 거의 모든 프로그래밍 언어가 어떤 형태로든 지원됨

<br>

### 네이티브 개발

- 모바일 OS 판매사가 제공하는 툴을 사용하는 방법
- iOS용 네이티브 툴은 XCode와 Objectiv-C만 있었다가 최근 iOS 개발 언어인 Swift를 새로 만들었음
- 안드로이드 세계에는 Google에서 안드로이드 개발 스튜디오 IDE를 내놓았다는 사실 외에는 큰 변화가 없었음
  - Java를 선호하는 경향은 여전함
- 네이티브로 개발하려면 iOS용 코드와 안드로이드용 코드를 완전히 다르게 써야 함
  - 아주 큰 문제는 아니지만 유지 보수를 생각해야 함
- 안드로이드 개발과 iOS 개발은 서로 비슷한 구석이 없음
  - 도구, 언어, 프레임워크가 다르고 심지어 개발 패러다임도 다름
  - 두 버전 다 만드려면 아주 다른 방향으로 진화하고 있는 두 개의 플랫폼을 따로 공부하겠다는 마음의 준비가 필요함
- 가장 큰 장점은 속도
  - 사실 이마저도 Xamarin 같은 크로스 플랫폼 프레임워크가 네이티브 코드까지 컴파일해주기 때문에 거의 비슷한 속도를 내주긴 함
  - 하지만 네이티브 코드까지 컴파일하는 프레임워크를 사용하지 않는 한 네이티브 코드가 대체로 빠름
- 네이티브로 개발하면 여러 추상 레이어를 다룰 필요가 없으므로 더 나은 디버깅 툴 사용 가능
- 플랫폼의 네이티브 기능을 잘 활용할 수 있게 됨 (크로스 플랫폼에서도 좋은 기능을 활용하면 커버할 수도 있긴 함)
- 전반적으로 네이티브 모바일 개발 방법을 알아두는 건 유용하지만, 여러 플랫폼에서 쓸 앱을 만들고 싶다면 최고의 방법이라고 보기는 어려움

<br>

### 크로스 플랫폼 프레임워크와 툴

- 일부 솔루션은 네이티브 언어와 도구에 얹힌 추상화 레이어에 불과할 때도 있음
  - 실제로는 네이티브 코드를 생성하고 네이티브 라이브러리를 활용하는 것
  - 네이티브 라이브러리와 프레임워크를 이해하고 사용할 수 있어야 함
- 하이브리드 앱을 만드는 솔루션은 네이티브 컴포넌트와 웹 기반 컴포넌트, HTML 컴포넌트가 복합적으로 쓰이며 내장된 모바일 브라우저가 애플리케이션의 사용자 인터페이스와 기능을 만드는 역할을 함
- 솔루션을 선택할 때 고려해야 할 중요한 사항들

  - 어떤 프로그래밍 언어를 사용할 것인가?
    - 솔루션 대부분은 하나의 프로그래밍 언어만 지원
    - 그러므로 쓸 줄 아는 언어를 지원하는 크로스 플랫폼 솔루션을 선택하는 것이 좋음
  - 네이티브와 하이브리드 중 어느 쪽을 원하는가?
    - 보통 네이티브 앱이 속도는 더 빠르고 앱이 구동되는 모바일 플랫폼과도 더욱 유사해 보임
    - 그러나 Xamarin, Cordova 같은 크로스 플랫폼 하이브리드 솔루션은 네이티브와 구별하기 어려울 정도로 네이티브에 가까워 보이게 해줌
  - 지원하고자 하는 플랫폼의 종류는 몇 가지인가?
    - iOS와 안드로이드는 대부분의 크로스 플랫폼 솔루션을 지원
    - 하지만 맥 OS나 윈도우 같은 데스크톱 OS, 전화용 OS, 심지어 라즈베리 파이까지 지원되는 솔루션도 존재
    - 그렇지만 iOS나 안드로이드 외의 플랫폼을 꼭 지원해야 할 이유가 있는 게 아니라면 굳이 크로스 플랫폼 지원까지 신경 쓸 필요는 없음
    - 하지만 게임이라면 최대한 많은 플랫폼을 지원하는 툴을 선택하는 게 좋음 (Unity 3D)
  - 코드를 재사용할 생각인가?
    - 크로스 플랫폼 프레임워크를 사용했다고 해서 한번 작성한 코드를 지원하는 모든 플랫폼에서 그대로 쓸 수 있는 것은 아님
    - 네이티브를 지원하는 크로스 플랫폼 솔루션은 네이티브 프레임워크, 라이브러리, 사용자 인터페이스 요소나 패러다임과 더 긴밀하게 연동되기 때문에 재사용할 수 있는 코드도 줄어듦
    - 네이티브에 더 가깝게 만들 것이냐 아니면 코드를 최대한 많이 재활용할 수 있게 만들 것이냐 둘 중 하나를 선택해야 함
    - 최근에 등장한 Xamarin 같은 크로스 플랫폼 솔루션은 양쪽의 혜택을 모두 누릴 수 있게 해줌
      - Xamarin은 Xamarin Forms라는 공통의 UI 라이브러리를 써서 OS의 네이티브 UI와 프레임워크 위에 추상 레이어를 만듦
    - 궁극적으로 코드 재사용 문제는 어떤 유형의 앱을 만들지, 해당 플랫폼과 네이티브 앱과 어느 정도 어우러지기 원하는지에 따라 각자 판단해야 함

  <br>

### 모바일 웹 앱

- 수년 동안 모바일 브라우저의 능력과 기능이 증가하고 적응형 웹 기술이 발전한 덕에 모바일 웹 앱을 만들 수 있는 길이 열림
- 다른 웹 애플리케이션을 만드는 것과 똑같은 방법을 따르되 모바일 기기에서 작동할 수 있게 설계하면 됨
- 많은 모바일 OS 브라우저가 위치 데이터 얻기, 기기 카메라에 접근하기 등의 작업을 할 수 있도록 웹 브라우저 내부에서 네이티브 기능을 호출할 수 있게 해줌
- 모바일 웹 앱 제작을 도와주는 프레임워크가 꽤 많음
- 모바일 웹 앱이 미래이며, 그 세상이 도래하기까지 시간이 조금 더 필요한 것 뿐

<br>
<br>

# DBA와 DevOps

- 코드 작성을 마쳤다고 소프트웨어 제작이 완료되는 게 아니고, DB가 필요하며, 빌드하고 테스트하고 배포도 해야 함
  - 이 지점에서 DBA(database administrator)와 DevOps 등장
- 소프트웨어 개발이 팀 단위로 이루어지는 경우가 점점 많아지고 있기 때문에 등장 (애자일 환경에서 특히 이런 경향이 강함)
- 지난 수년간 소프트웨어를 만드는 점점 더 좋은 방법을 깨우쳐온 덕에 권장 업무 진행 절차나 '이렇게 해야 마땅하다'라고 주장하는 방법이 굉장히 많이 등장했음
- 스타트업이나 작은 회사에서는 그냥 소프트웨어 개발자가 해당 업무를 같이 하기도 함
  - 하지만 해당 기술 분야에 대한 이해도는 반드시 필요함

<br>

## DBA

- 주요 업무는 DB를 설치하고 유지 보수하고 보호하고 최적화하고 감시하는 일
- 간혹 DB 스키마를 설치하거나 저장 프로시저를 작성하기도 함
- DB를 작동하도록 하는 업무만 하는 DBA도 있고, 작동 업무와 함께 DB 프로그래머에 가깝게 일하는 DBA도 있음

<br>

### DB에는 양육의 손길이 필요하다

- 모든 개발팀에 DBA가 있는 건 아니지만, 누가 되었든 이 업무를 맡는 사람이 있어야 한다는 점은 분명함
  - DB를 설치하고 유지 보수하는 기본적인 방법을 알아두어야 함
- DB는 시간이 지날수록 커지기 때문에 나중에 리소스를 과하게 쓰게 되기도 함
  - DB를 작동할 하드웨어를 잘 골라야 함
  - 때가 되면 업그레이드를 해줘야 함
- DB에는 매우 중요한 데이터가 들어 있으므로 백업을 정기적으로 해야 함
  - 혹여 망가졌을 때 복구해서 작동하게 할 재난 대비책도 필요
- 시간이 지나면 설계나 조율이 잘 되지 않은 DB는 효율이 떨어지고 느려지므로 성능에도 신경 써야 함
  - 처리 속도를 높일 수 있게 평소 DB의 성능을 분석하고 데이터 인덱스를 만들고 정리해야 함

<br>

### DBA가 되어야 할까?

그럴 필요는 없지만 다음 항목을 배워두면 좋다.

- DB 설치 및 설정
- 백업 만들고 복구하기
- 테이블과 스키마 만들기
  - 스키마는 DB의 청사진
    - DB를 어떤 테이블로 나눌지, 데이터를 어떤 양식으로 저장할지 정의 (DB에 대한 거의 모든 것을 정의)
  - 스키마가 있으면 완전히 똑같은 구조의 빈 DB를 만드는 것도 가능
- 저장 프로시저 만들기
  - 저장 프로시저는 DB의 함수나 메소드 또는 프로시저
    - DB 상에서 바로 실행되어 특정 명령을 수행하는 SQL 코드
    - DB에서 하게 될 일반적인 작업을 정리하는 논리적 방법
- 테이블 인덱스 만들기와 인덱스 작동법
- 조회, 삽입, 갱신 등과 같은 기본적인 동작을 수행하는 기초적인 SQL 코드 작성
- 테이블 join
  - 한 개 이상의 다른 테이블에서 가져온 데이터의 교집합, 합집합 또는 그 밖의 조합 방식을 사용하여 DB에 있는 여러 테이블을 조합하는 것을 의미함

<br>

## DevOps: 새로운 직군

- IT 분야에서 완전히 새로운 역할이 만들어지는 일은 드문데도 만들어진 직군
- 역할이 독특하며, 아직 명확하게 정의되지 않았음
- 개발과 운영의 복합체 혹은 매시업이라고 볼 수 있음
- 쉽게 보자면, 코드를 빌드하고 테스트하고 배포하고 실제 서비스를 운영하는 데 필요한 일이라면 뭐든지 하는 직군

<br>

### 운영: 기존 방식

1. 개발자와 운영팀(IT) 존재
2. 개발자는 코드를 작성해서 QA에게 넘김
3. QA는 코드가 엉망이라며 되돌려 보냄
4. 그 둘이 코드를 몇 차례 더 코드를 주고받다가 어느 정도 합의되면 코드를 운영팀으로 보냄
5. 운영팀은 코드가 비효율적이라며 되돌려 보냄
6. 역시 둘이 코드를 주고받다가 결국 운영팀이 코드를 받아들여서 서버에 배포

- 핵심은 과거에는 소프트웨어 개발 세계가 각기 분명히 구분된 팀으로 구성되어 있었다는 것
- 그래도 애자일 소프트웨어 개발 등장 전까지는 견딜 만했음
  - 애자일 이후, 과거에는 6개월에 한 번씩 배포하던 새로운 코드를 요즘은 일주일에도 몇 차례 배포
  - 개발팀은 하루에도 여러 차례 빌드한 코드를 자동으로 테스트하고 품질을 확인하게 됐음
- 코드를 작성하고 빌드하고 배포하는 단순한 구조로는 부족한 시대가 되었으며, 이로 인해 코드를 개발에서 생산까지 빠르게 보낼 수 있게 해줄 완전히 새로운 운영 방식과 절차 탄생

<br>

### DevOps란 무엇인가?

- 코드를 개발해서 생산하기까지의 각 단계를 관리하는 종합적인 공정
- 배포 절차를 자동화하는 빌드 배포 시스템을 만들 때 필요한 코드를 빌드하고 배포할 수 있는 개발자에게 DevOps 역할을 맡기는 조직도 있음
- 개발자, 테스터, 운영 역할은 분리해두되 상호 이해를 바탕으로 협력해서 DevOps 역할을 해내는 조직도 있음

<br>

### 나에게 의미하는 것

- 소프트웨어 개발자는 엄밀히 말해 DevOps에 속함
- 코드 작성 능력만 갖추는 걸로는 부족함
  - 자신이 만든 코드를 다른 사람에게 넘긴 이상 그 사람 문제라고 생각할 수 있는 시절은 지나갔음

⭐ 따라서 소프트웨어 개발자에게 다음과 같은 역량들이 필요함

- 코드를 개발에서 생산까지 보내는 데 쓰이는 절차와 도구 알기
- 소스를 제어하는 방법 알기
- 지속적 통합의 기초, 빌드 서버 작동법의 기초 알기
- 테스트에 대한 기초 지식과 유형 익히기, 다양한 유형의 자동 테스트가 코드 빌드, 배포의 큰 그림에 어떻게 적용되는지 배우기
- 애플리케이션을 패키징하고 배포를 준비하는 법 알기, 배포 절차, 코드를 빌드 서버에서 스테이징 서버나 프로덕션 서버로 자동으로 옮기는 방법, 다양한 서버에서 환경 설정을 관리하는 법 알기
- 모니터링하는 방법 알기

→ 자신이 야구팀 투수라고 상상해보자.  
팀 내 모든 역할에 대해 모든 걸 알 필요는 없다.  
하지만 어떤 역할이 존재하고 각 역할이 어떤 일을 하는지 정도는 알아야 팀의 전략을 세울 때 의견을 낼 수 있다.

<br>
<br>

# 소프트웨어 개발 방법론

- 소프트웨어 개발 커뮤니티에서 소프트웨어 개발 방법론과 이를 구현할 방법이라는 주제보다 더 많은 논쟁을 불러일으키는 주제는 없을 것
- 소프트웨어 개발 방법론은 소프트웨어 제작 절차를 정의함
- 소프트웨어를 만드는 방법, 팀을 이끄는 방법을 구체적으로 알려줌

<br>

## 전통적인 폭포수 개발

- 당시에는 폭포수라는 이름도 없었고 이를 비웃는 일도 없었지만, 그냥 그렇게 하는 것이 당연했음
- 바닥에 닿을 때까지 한 단계가 끝나면 다음에 있는 아래 단계로 내려가며 소프트웨어를 한 번에 한 단계씩 만들어가는 방식
- **SDLC(Software Development Life Cycle)** 가 포함되어 있음
  - 거의 모든 방법론에 SDLC가 등장하지만, 폭포수의 SDLC는 순차적이며, SDLC를 점진적으로 따라갈 뿐이라고 봐도 될 정도

<br>

### SDLC를 반대하는가?

- SDLC란 소프트웨어를 개발하기 위한 `요구사항 분석 - 소프트웨어 설계 - 구현 - 테스트 - 배포 - 유지 보수`로 끝나는 일련의 과정
- 한 번에 한 단계씩 앞으로 전진하고 절대 뒤로 가지 않음
- **요구사항 분석**
  - 무엇을 해야 할까? 어떤 기능이 있어야 할까? 어떻게 보이고 어떻게 동작해야 할까?
  - 고객이나 이해 당사자와 대화를 하면서 알아내거나 직접 생각해내기도 함
  - 어떤 방법을 쓰든 제작에 들어가기 전에 알아야 함 (당연히 그게 늘 가능하지는 않음)
- **소프트웨어 디자인**
  - 어떻게 만들지 알아낼 단계
  - 요구사항을 바탕으로 시스템 아키텍처 설계, 저수준 알고리즘, UML 다이어그램 만들기 → 그 시스템을 어떻게 만들고 동작하게 할지 결정
  - 어느 수준까지 설계해야 할지에 대해서는 의견이 분분하지만 어느 정도 수준의 설계는 늘 필요함
  - 폭포수 방식에서는 **big upfront design(방대한 사전 설계)** 라고 알려진 방법을 사용함
    - 방대한 사전 설계란 세부 사항 대부분에 대한 계획을 아주 낮은 수준까지 설계 단계에서 정해두는 걸 가리킴
  - 일정은 정해져 있고 절대 뒤로 돌아오는 일 없이 앞으로만 나아갈 수 있다면 모든 것을 미리 정해두는 게 이치에 맞겠지만 현실에서는 요구사항이 바뀌고 예측하지 못하는 일들이 일어남
- **구현**
  - 설계를 코드로 바꾸는 단계
- **테스트**
  - 테스터는 테스트를 하고 버그를 찾아냄
    - 몇 번의 논쟁과 속임수를 거친 후에 모두가 다음 단계로 넘어가도 좋다고 동의할 때까지 최대한 많은 버그를 수정
- **배포**
  - 별도로 개발한 컴포넌트가 여러 개라면 하나로 '통합'하여 배포
- **유지 보수**
  - 대부분의 경우 다른 단계보다 유지 보수 단계에 더 오랜 시간이 듦
  - 고객이 찾아내는 버그를 고치고 새로운 기능을 추가하고 다른 모든 일이 순조롭게 흘러가게 해야 함

<br>

## 애자일

- 애자일은 소프트웨어 개발 업계의 판도를 뒤바꿔놓았음
- 애자일은 확실한 형태가 없음

<br>

### 애자일 선언문

- 모든 일은 유타 주에 있는 로지 앳 스노버드 스키 리조트에서 시작되었음
- 서로 다른 개발 방법론을 입안한 이들과 업계 선두주자들 총 17명이 모여서 소프트웨어 개발이 어떤 방식으로 이루어져야 하는지에 대해 공통 기반을 찾으려 한 시도라고 볼 수 있음
- 이들은 소프트웨어 개발에 영향을 미치는 몇 가지 문제에 대해 논의하던 중 **애자일 선언문** 을 만들었음

> 우리는 소프트웨어를 개발하고 다른 사람의 개발을 도와주면서 소프트웨어 개발의 더 나은 방법을 찾아나가는 과정에 있다.  
> 이 작업을 통해 우리는 과정이나 도구보다 개인이나 상호작용을, 포괄적인 문서보다 작동하는 소프트웨어를, 계약 협상보다 고객과의 협력을, 계획을 따르는 것보다 변화에 대응하는 것을 가치 있게 여긴다는 결론에 이르렀다.  
> 이 말인즉 먼저 언급한 것도 가치가 있지만, 우리는 뒤에 언급한 것에 더 높은 가치를 둔다는 뜻이다.

이는 다음에 정의된 12가지 원칙을 기반으로 한다.

1. 우리는 가치 있는 소프트웨어를 빠르게 그리고 지속적으로 제공해서 고객을 만족시키는 것을 가장 중요하게 생각한다.
2. 개발의 후반부일지라도 요구사항 변경을 환영하라. 애자일 프로세스는 변화를 활용해서 고객의 경쟁력을 높이는 데 기여한다.
3. 새로운 소프트웨어는 몇 주나 몇 달의 주기로 자주 제공하라. 간격은 짧을수록 좋다.
4. 프로젝트가 진행되는 동안 사업부서 사람들과 개발자는 매일 만나서 함께 일해야 한다.
5. 의욕 있는 사람들 위주로 팀을 구성하라. 그들이 필요로 하는 환경과 지원을 제공하고 그들이 맡은 일을 완수할 거라고 믿어라.
6. 개발팀으로, 혹은 개발팀 내에서 정보를 전달하는 가장 효율적이고 효과적인 방법은 서로 얼굴을 보고 하는 소통이다.
7. 업무 진척을 측정하는 기본 척도는 작동하는 소프트웨어다.
8. 애자일 프로세스는 지속 가능한 개발을 장려한다. 후원자, 개발자, 사용자는 일정한 속도를 계속 유지할 수 있어야 한다.
9. 기술적 우수성과 좋은 설계에 대한 꾸준한 관심이 기민성을 높인다.
10. 해야 할 일의 양을 최소화하는 단순성이 꼭 필요하다.
11. 최고의 아키텍처, 요구사항, 설계는 자기 조직적인 팀에서 나온다.
12. 팀은 정기적으로 더 효과적으로 일할 방법을 고민하고 이를 통해 이른 결론에 따라서 팀이 어떻게 움직일지 조율하고 조정한다.

<br>

### 애자일은 방법론이 아니다

- 애자일은 소프트웨어 개발이 어떻게 이루어져야 하는지를 매우 높은 수준에서 정의함
  - 그래서 애자일 자체를 방법론으로 보기는 어려움
  - 그보다 애자일이라고 여겨지는 특성을 지닌 다른 여러 방법론의 부모 격이라고 볼 수 있음
- 애자일은 소프트웨어 개발은 점증적으로 이루어져야 한다는 아이디어에 불을 붙였음
- 애자일은 개발이 이루어지는 동안 요구사항 또한 바뀔 수 있고 오히려 바뀌어야 마땅하다는 아이디어를 수용했음
- 두꺼운 서류와 엄격한 규칙보다 서로 얼굴을 보고 하는 소통, 자기 조직적인 팀에 가치를 둠으로써 소프트웨어 개발팀의 다양한 구성원 간 관계를 새롭게 정의했음

<br>

### 폭포수 방식의 문제

- 요구사항 변화가 문제가 됨
  - 더 정확히는 프로젝트 후반이 될 때까지 요구사항의 변화를 알 수 없음
- 소프트웨어 개발자 입장에서는 아무것도 바뀌지 않는 게 좋지만, 세상은 그렇게 돌아가지 않음

<br>

## 스크럼

- 1990년대 초반 Ken Schwaber와 Jeff Sutherland가 함께 만들었음
  - 두 사람은 1995년에 2가지 방법론을 합쳐서 완성한 스크럼 방법론을 정의하는 공동 논문을 작성했음
- 스크럼은 **소프트웨어 개발팀의 특정 역할** , **소프트웨어를 개발하는 작업 흐름** , **개발의 반복 주기마다 여는 sprint라고도 부르는 회의** 를 까다로운 규범에 따라 정의한 정형화된 방법론

<br>

### 스크럼 직책

- **제품 책임자(Product Owner)** : 고객의 소리를 전달하고 작업의 우선순위를 결정하는 역할을 함. 사업과 관련된 이해 당사자 및 고객과 소통하는 역할도 함
- **개발팀** : 코드 작성 외에도 분석, 설계, 테스트 등 소프트웨어 배포와 관련된 모든 일을 맡음
- **스크럼 마스터(Scrum Master)** : 팀이 하는 일을 지연시키는 장애물을 제거하고 제품 책임자와 소통하며 스크럼 프로세스가 문제없이 진행될 수 있게 돕는, 팀의 코치 역할

<br>

### 스크럼 진행 방식

- 소프트웨어 개발을 스프린트라고 부르는 작은 반복 주기로 나누는 것이 스크럼의 기본 아이디어
  - 스프린트로 정해둔 기간 내에 해야 할 일의 양을 정해두고, 각 스프린트를 마칠 때마다 나오는 결과를 점진적으로 고객에게 전달함
- 소프트웨어를 위해 개발해야 할 모든 기능을 **제품 백로그(Product Backlog)** 에 넣어둠
- 제품 백로그에는 **우선순위** 를 정해둠
- 각 스프린트마다 **스프린트 백로그** 를 만들어 제품 백로그 항목 중에서 해당 스프린트에 작업할 항목을 모아둠 (스프린트는 보통 1~2주 정도로 나뉨)
- 각 스프린트가 시작될 무렵 **계획 회의** 를 엶
  - 이 회의를 통해 그 스프린트에 처리한 백로그 항목을 정하고 그 백로그를 달성하기 위해 필요한 노력의 수준은 어떠한지 추산
  - 엄밀히 말해 해당 스프린트가 진행되는 동안 백로그에 있는 모든 항목을 완료하기 위해 헌신해야 함
- 매일 모든 팀원이 한데 모여 자신이 진행하는 업무에 대해 아주 짧게 공유하는 **스크럼 회의** 를 엶
  - 이 회의는 서서 진행함
  - 업무 진행 상황을 전체 팀원과 공유하고 업무를 지연시키는 장애물을 제거하는 것이 목적
  - 매일 같은 장소에서 같은 시간에 엶
  - 각 팀원은 3가지 질문에 답해야 함
    1. 어제는 팀의 스프린트 목표 달성에 도움이 될 만한 어떤 일을 했는가?
    2. 오늘은 팀의 스프린트 목표 달성에 도움이 될 만한 어떤 일을 할 것인가?
    3. 본인이나 팀의 스프린트 목표 달성을 막는 장애물이 있는가?
- 스프린트가 진행되는 동안 팀은 백로그에 있는 모든 항목을 수행하기 위해 함께 노력
- 업무 진행 상황과 속도를 추적하기 위해 보통 **소멸 차트(burndown chart)** 를 사용함
  - 소멸 차트는 남은 시간, story point, 업무 난이도를 비롯해 남은 업무의 양을 확인할 때 필요한 거라면 무엇이든 추적함
- 스프린트가 끝나면 스프린트가 진행되는 동안 완료한 목표를 이해 관계자에게 보여주는 **리뷰** 를 수행함
- 마지막으로 지난 스프린트를 돌아보고 다음 스프린트에 대한 아이디어를 떠올리는 **회고 회의** 를 엶

<br>

### 스크럼 관련 문제

- 제대로 수행하기만 한다면 소프트웨어를 매우 효과적으로 개발할 수 있게 해주는 좋은 방법
  - 하지만 안타깝게도 현실에서는 제대로 구현하지 않는 경우가 많음
  - 실패를 벌충하거나 변칙을 쓰기 위해 모른 척 넘어가는 경우도 많음
- 스크럼이 성공적으로 구현되지 못하는 가장 큰 이유는 **헌신이 부족해서**
  - 백로그 항목을 스프린트에 포함시켜 두고 모든 일이 계획에 따라 착착 진행되면 그 임무를 완수하겠다고 말하기는 정말 쉽지만 실제로 헌신해서 그 임무를 완수하는 건 무척 어려운 일
  - 헌신하지 못한다면 책임의 수준은 낮아지고 스프린트의 의미는 퇴색됨
  - 매일 할 일 목록을 만들고 이를 지키기 위해 최선을 다해도 대부분 실패하는 상황과 무척 비슷함
