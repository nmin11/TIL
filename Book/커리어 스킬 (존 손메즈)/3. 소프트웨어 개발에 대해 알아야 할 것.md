_내가 안다는 걸 안다. 즉, 안다는 사실을 자각한다는 뜻이다._  
_내가 모른다는 걸 안다. 즉, 자신이 모른다는 사실을 아는 상태다._  
_하지만 모른다는 걸 모를 수도 있다. 즉, 자신이 모른다는 사실조차 모르는 상태를 말하는 것이다._

― 도널드 럼즈펠드

<br>

- 소프트웨어 개발자가 되기 위해 알아야 하는 것은 충격적일 만큼 많음
  - 프로그래밍 언어, 소스 제어, 테스트, 지속적 통합, 웹 개발, HTML, CSS, 디자인 패턴, 데이터베이스, 디버깅, 방법론, 스크럼, 애자일 등
- 3부는 소프트웨어 개발자가 되기 위해 알아야 할 모든 것의 기본에 대해 알려줌

<br>
<br>

# 프로그래밍 언어 개요

- 프로그래밍 언어를 다양하게 배울수록 좋은 것은 아님
  - 그러나 주요 프로그래밍 언어는 무엇이고, 각각 어떤 차이가 있는지 정도는 알아두는 게 좋음

<br>

## C

- 1969~1973년 사이에 Dennis Ritchie가 Bell Labs에서 개발한 언어
- 상당히 오래된 프로그래밍 언어이지만 아직도 사용되고 있을 뿐 아니라 인기도 여전함
  - **아마도 세계에서 가장 많이 쓰인 프로그래밍 언어**
- C++, C#, Java, JavaScript 등 주요 프로그래밍 언어 다수가 C에 뿌리를 두고 있음
- **너무 강력하기에 까다로운 언어**
  - 개발자가 컴퓨터 메모리에 접근해서 저수준 영역까지 조작할 수 있게 해주는 low level 언어
- 수많은 운영 체제, 저수준 하드웨어, 임베디드 시스템, 게임 등에서 사용됨
- C를 시스템 프로그래밍 언어로 분류하는 경우가 많음

<br>

## C++

- Bell Labs의 Bjarne Stroustrup이 C 언어에서 Simula의 객체지향성, 클래스, 가상 함수 등과 같은 유용한 기능을 활용하려고 C를 확장한 데서 비롯됨
- 종종 C와 경계가 모호해지는 언어
  - 많은 C++ 개발자가 C++의 객체지향 개념을 이해하지 못해서 C++ 기능으로 C에서 쓸 법한 코드를 작성하기 때문
- 엄밀히 말해 C++는 C의 상위 집합
  - C 프로그램은 C++ 컴파일러로 컴파일해야 하기 때문 (일부 예외는 있음)
- 특히 게임 개발에 많이 쓰임
- 업데이트도 꾸준히 이루어지고 있고 현재는 '모던 C++'라고도 불림
- 매우 복잡한 언어이므로 초보자에게는 추천하지 않음 / 매우 강력한 만큼 조심히 다루어야 함

<br>

## C#

- 마이크로소프트가 .NET Runtime 환경을 대표하는 언어로 만듦
- 훌륭한 표현력에 비해 사용하기 쉬움
- 초기 C#은 Java와 아주 많이 유사했지만 요즘은 꽤 멀어졌음
  - 그럼에도 둘 중 한 언어를 아는 사람이라면 반대편 언어를 이미 90퍼센트 정도 아는 거나 다름없다고 할 수 있음
- C++와 비슷하다고 할 수 있는 객체지향 언어이지만, 훨씬 더 간단하고 기능도 훨씬 많음

<br>

## Java

- 1995년 Sun Microsystems의 James Gosling이 한 번 작성한 코드를 여러 플랫폼에서 실행할 수 있게 만든 언어
  - Java를 모든 컴퓨팅 플랫폼에서 구동되는 가상 머신에서 실행할 수 있게 만들었음
- C와 C++에 기반하는 객체지향적인 언어지만 C#처럼 매우 단순하며, 문제를 일으킬 소지가 있는 메모리 조작 등 저수준 동작은 허용하지 않음
- 현재 Java는 Oracle의 소유이며 여전히 성장하고 있지만, 최근 위원회의 관리를 받고 있는데 여기에 소속된 위원들은 Java의 발전 속도를 늦추고 싶어 함

<br>

## Python

- 1989년 Van Rossum이 만듦
- **가독성을 중요하게 고려해서 만든 우아하고 단순한 언어**
- 객체지향적으로도 절차지향적으로도 심지어 함수형으로도 쓸 수 있으며, Interpreted language, 즉, 컴파일하지 않는 언어
- C++, Java, C#과 비교했을 때 Python의 코드는 훨씬 간결함
  - 더 적은 코드로 더 많은 걸 표현할 수 있음
- 지금도 인기를 끌고 있는데 점점 더 인기가 올라가고 있음
- Google에서 사용하는 주요 프로그래밍 언어 중 하나이기도 하고, 초보가 배우기 좋은 언어

<br>

## Ruby

- Yukihiro 'Matz' Matsumoto가 1993년 일본에서 만듦
- 객체지향적인 스크립트 언어를 만들겠다는 아이디어에서 탄생한 언어
- 초창기에는 그다지 관심을 받지 못했지만 최근에 인기가 높아졌음
- David Heinemeier Hansson이 2003년에 만든 Ruby on Rails(RoR)는 Ruby가 큰 성공을 거두는 데 큰 기폭제 역할을 했음
  - 쉽고 재미있게 프로그래밍을 할 수 있어서 여전히 큰 인기를 누리는 언어이며, 초심자가 배우기 아주 좋은 언어

<br>

## JavaScript

- 1995년 Brendan Eich가 단 10일만에 개발한 언어
  - 아주 짧은 기간에 개발된 탓에 문제가 많음
- C#, Java, C++와 비슷해 보이지만 매우 다르게 작동
- 애초에 단순한 웹용 스크립트 언어였지만 이제는 웹을 넘어서 광범위하게 쓰이는 기본 언어가 되었음
- JavaScript의 최신 버전인 ECMAScript는 기존 단점을 많이 수정한 덕에 대규모 개발에 적합한 형태가 되었음
- 워낙 광범위하게 쓰이는 언어라서 요즘 웹 개발자라면 JavaScript에 대한 지식을 조금이라도 갖춰야 함

<br>

## Perl

- 1987년 Larry Wall이 유닉스용으로 만든 스크립트 언어
- 유연성과 문자열 구문 분석을 할 수 있는 능력 덕분에 웹 초창기에 널리 인기를 끌었음
- 인기가 예전 같지는 않지만 여전히 널리 사용되는 언어
- '스크립트 언어계의 스위스 아미 전기톱'
  - 엄청 유연하고 강력하며 정확성을 갖춤
- 가독성이 떨어져서 내가 혹은 다른 누군가가 이틀 전에 쓴 코드조차 알아보기 힘듦

<br>

## PHP

- 1994년 Rasmus Lerdorf가 만들었고 2014년까지 명문화된 명세 하나 없이 진화했음
- 약간 지저분하다고 느껴지는 언어이지만, JavaScript와 함께 오늘날 웹의 많은 부분을 구성하는 언어
- 애초에 PHP는 프로그래밍 언어가 될 운명은 아니었고, 처음에는 간단한 웹 페이지를 동적으로 만들 수 있는 도구 모음에 불과했음
  - 세상의 빛을 본 후 처음 의도와 다르게 흘러갔음
- 온갖 단점이 있지만 배우기 쉽고 사용하기 쉽다는 큰 장점이 있음
  - 길 잃기 딱 좋은 후미진 골목이 많이 도사리고 있기는 함
- 기존의 PHP 코드를 수정하면서 경험을 쌓는 초보자가 많음

<br>

## Objective-C

- 1980년대 초 Bred Cox, Tom Love가 C에 SmallTalk의 객체지향 기능을 더하겠다는 생각으로 만듦
  - 그 후 잊혀져서 거의 없어질 뻔한 Objective-C를 Apple이 Mac OS X 운영 체제에 쓰면서 부활했음
    - 그렇다고 해서 널리 인기를 끈 것은 아니지만 맥 개발자는 이 언어를 사용해야 했음
    - 그러다가 Apple이 아이폰과 iOS를 소개하면서 수백만 명의 개발자가 이 언어의 낯선 문법과 씨름하게 되었음
- 배우기 어렵고, 아주 간단한 것을 하는 데도 꽤 장황한 코드를 써야 함
- 다행히 요즘 iOS 개발자는 Objective-C보다 약간 더 친절한 Swift를 쓸 수 있음

<br>

## Swift

- Apple이 선택한 새로운 iOS용 대표 언어
- iOS, OS X 개발에 쓰이는 애플의 Cocoa, Cocoa Touch 프레임워크용으로 만들어졌음
- 기존의 많은 Objective-C 코드와도 쉽게 통합될 수 있도록 설계되었음
- Objective-C를 동적이고 유연하게 하는 인기 있는 기능 대부분을 지원하는 동시에 훨씬 더 단순하고 간결함
- iOS 개발을 해볼 생각이라면 Objective-C를 거르고 바로 Swift로 시작해도 좋음

<br>

## Go

- 2007년 Google의 Robert Griesemer, Rob Pike, Ken Thompson이 만들었음
- C와 매우 비슷하지만 몇 가지 훌륭한 추가 기능이 있고 훨씬 단순함
- C와는 달리 Garbage Collection 기능이 있어서 메모리를 관리하지 않아도 됨 / Concurrent(동시성) Programming 기능이 있어서 성능이 크게 좋아졌음
- 잘 설계되어서 문법이 아주 간결함
- 원래는 C처럼 시스템 프로그래밍 언어로 만들어진 언어이지만 나중에 웹을 비롯한 다른 영역까지 퍼져나갔음

<br>

## Erlang

- Ericsson의 Joe Armstrong, Robert Virding, Mike Williams가 1986년에 만들었고 1998년에 오픈 소스로 공개한 언어
- 동시 및 분산 처리를 위해 설계된 기능적이고 매우 흥미로운 프로그래밍 언어
- 코드 hot swapping을 지원하므로 애플리케이션을 멈추지 않고 코드를 변경할 수 있음
- 원래는 전화 통신 애플리케이션 개발을 돕기 위해 만들어졌음
- 오늘날 가장 안정적인 프로그래밍 언어이자 프로그래밍 환경으로 여겨짐

<br>

## Haskell

- 1987년 당시 존재하던 여러 함수형 언어의 공개 표준으로 삼기 위해 설계한 순수 함수형 프로그래밍 언어
  - 학구적인 성격이 매우 강한 언어
- Haskell 1.0은 1990년 위원회에서 만들어졌음
- 최근에는 학구적인 영역을 넘어 점점 더 인기를 얻고 있음
- 순수 함수형 언어이자 강력한 정적 체계를 갖추고 있어서 배우기도, 사용하기도 어렵지만 매우 강력하며, 부작용 없이 예측 가능한 코드를 만들 수 있음

<br>
<br>

# 웹 개발이란 무엇인가?

- 데스크톱 앱이나 모바일 앱에 비해 까다로움
  - 데스크톱이나 모바일 개발에서는 대체로 런타임 환경이 뚜렷하기 때문
  - 윈도우 앱을 만들 때는 .NET을, 맥 OS용 앱을 만들 때는 Objective-C를 사용하면 됨
- 웹 개발을 할 때는 런타임 환경에 대한 통제력이 떨어짐
  - 웹 브라우저 세계에는 IE, Edge, Chrome, Safari, Firefox라는 다섯 강자가 존재하기 때문
  - Opera와 같이, 상대적으로 '약한' 주자도 많음
  - 심지어 모바일 기기, 웹 TV, 비디오 게임 콘솔 등도 고려해야 함
- 맞춰야 할 입맛이 많고, 실수할 여지도 많음
- 그러나 소프트웨어 개발자라면 웹 개발의 기본이라도 알고 있어야 함
  - 오늘날 소프트웨어 개발자 대부분은 웹 개발자
  - 웹 개발은 세상을 점령한 개발 플랫폼계의 킹콩

<br>

## 웹의 간략사

- 초창기 웹은 정적 HTML 페이지를 만드는 데 집중했으며, 모든 탐색은 하이퍼링크를 통해 이루어졌음
  - 웹 개발자의 존재는 필요 없었고 '웹마스터'만 있었음
- 이후 웹 페이지를 인터렉티브하게 만들 방법을 찾아야만 했음
  - 이에 따라 최초의 웹 애플리케이션을 만들 때는 CGI(Common Gateway Interface) 기술이 사용되었음
- 웹 개발자는 웹 브라우저에서 받은 요청을 분석하고 응답을 생성하는 동시에 HTTP 프로토콜을 정확하게 구현해야 했고 유효한 HTML도 작성해야 했음
  - ColdFusion이나 ASP와 같은 웹 개발 프레임워크의 등장으로 이 과정이 쉬워짐
    - 이 때부터 웹 개발자가 특별한 태그, 마크업, 로직을 써서 조건부 HTML을 생성할 수 있게 되었으며, 처음으로 진짜 웹 애플리케이션을 만들 수 있게 되었음
- 하지만 웹 페이지를 보다 더 인터랙티브하게 만들 방법이 필요했음
  - JavaScript를 사용해서 웹 애플리케이션의 능력을 신장시키기 시작
  - CSS(Cascading Style Sheets)를 쓰기 시작하면서 스타일을 쉽게 만들고 변경할 수 있게 됨
- 동적으로 생성되는 예쁜 웹 페이지만으로 만족하지 못했고, 더 인터랙티브하게 더 멋지게 만들 방법이 있어야만 했음
  - 서버에 있는 것을 렌더링하는 건 느려서 즉각 반응한다는 느낌을 받지 못했고,<br>그래서 새로고침을 하지 않아도 웹 페이지가 동적으로 업데이트되게 하는 **AJAX** (Asynchronous JavaScript and XML) 같은 기술이 발명되었음
    - 이런 웹 애플리케이션은 **SPA** (Single Page Application) 라고 불림

<br>
<br>

# 모바일 개발

- 혼자서도 단기간 내에 앱을 개발할 수 있는 아주 특별한 기회 제공
- 게임도 단순한 게임들이 모바일에서는 꽤 많은 사랑을 받음
- 모바일 개발이 개발의 미래가 될 것이라는 의견이 우세

<br>

## 모바일 개발 주요 플랫폼

- 꽤나 최근까지도 모바일 개발이 주목을 받거나 주도적인 플랫폼이 등장하지 않았었음
- 2007년 아이폰이 등장하면서 변화
- 이후 많은 모바일 플랫폼이 나왔다가 사라졌고, 현재 이 시장은 **두 강자** 와 나머지로 나눌 수 있게 됨

<br>

### iOS

- 모바일 기기와 모바일 소프트웨어라는 개념을 완전히 바꾸고 마침내 현시대에 모바일 개발을 등장시킨 주역
- 현재는 아이폰, 아이팟, 아이패드, 애플 워치, 애플 TV에 쓰이지만 앞으로 iOS에서 구동되는 기기는 더 많아질 것
- BSD 계열인 Darwin과 M을 기반으로 하고 있어서 근본적으로 유닉스와 유사함
- 맥 OS와 주요 프레임워크 일부를 공유함
  - iOS의 사용자 인터페이스는 맥 OS에 사용되는 애플 코코아 UI에 기반함
- iOS 애플리케이션은 보통 Objective-C나 Swift를 써서 만드는데 대세는 Swift

<br>

### 안드로이드

- 안드로이드는 iOS보다 약 1년 늦은 2008년 9월에 등장했음에도 시장의 지분을 크게 차지함
  - iOS의 지분이 18퍼센트이고 안드로이드의 지분은 80퍼센트에 달함
- Google이 지원하는 안드로이드는 오픈 소스 (iOS는 그렇지 않음)
- 서로 다른 폼 팩터와 기능을 가진 다양한 하드웨어 플랫폼 기기에서 작동할 수 있게 설계되었음
  - 반면에 iOS는 오로지 애플 기기에서만 작동하도록 설계되었음
- Linux kernel을 기반으로 하며, 안드로이드 OS 애플리케이션 네이티브 개발 플랫폼은 Java

<br>

## 모바일 개발 방법

- 모바일 앱 개발에 쓸 수 있는 프레임워크, 툴, 플랫폼, 생태계가 셀 수 없이 많음
- 거의 모든 프로그래밍 언어가 어떤 형태로든 지원됨

<br>

### 네이티브 개발

- 모바일 OS 판매사가 제공하는 툴을 사용하는 방법
- iOS용 네이티브 툴은 XCode와 Objectiv-C만 있었다가 최근 iOS 개발 언어인 Swift를 새로 만들었음
- 안드로이드 세계에는 Google에서 안드로이드 개발 스튜디오 IDE를 내놓았다는 사실 외에는 큰 변화가 없었음
  - Java를 선호하는 경향은 여전함
- 네이티브로 개발하려면 iOS용 코드와 안드로이드용 코드를 완전히 다르게 써야 함
  - 아주 큰 문제는 아니지만 유지 보수를 생각해야 함
- 안드로이드 개발과 iOS 개발은 서로 비슷한 구석이 없음
  - 도구, 언어, 프레임워크가 다르고 심지어 개발 패러다임도 다름
  - 두 버전 다 만드려면 아주 다른 방향으로 진화하고 있는 두 개의 플랫폼을 따로 공부하겠다는 마음의 준비가 필요함
- 가장 큰 장점은 속도
  - 사실 이마저도 Xamarin 같은 크로스 플랫폼 프레임워크가 네이티브 코드까지 컴파일해주기 때문에 거의 비슷한 속도를 내주긴 함
  - 하지만 네이티브 코드까지 컴파일하는 프레임워크를 사용하지 않는 한 네이티브 코드가 대체로 빠름
- 네이티브로 개발하면 여러 추상 레이어를 다룰 필요가 없으므로 더 나은 디버깅 툴 사용 가능
- 플랫폼의 네이티브 기능을 잘 활용할 수 있게 됨 (크로스 플랫폼에서도 좋은 기능을 활용하면 커버할 수도 있긴 함)
- 전반적으로 네이티브 모바일 개발 방법을 알아두는 건 유용하지만, 여러 플랫폼에서 쓸 앱을 만들고 싶다면 최고의 방법이라고 보기는 어려움

<br>

### 크로스 플랫폼 프레임워크와 툴

- 일부 솔루션은 네이티브 언어와 도구에 얹힌 추상화 레이어에 불과할 때도 있음
  - 실제로는 네이티브 코드를 생성하고 네이티브 라이브러리를 활용하는 것
  - 네이티브 라이브러리와 프레임워크를 이해하고 사용할 수 있어야 함
- 하이브리드 앱을 만드는 솔루션은 네이티브 컴포넌트와 웹 기반 컴포넌트, HTML 컴포넌트가 복합적으로 쓰이며 내장된 모바일 브라우저가 애플리케이션의 사용자 인터페이스와 기능을 만드는 역할을 함
- 솔루션을 선택할 때 고려해야 할 중요한 사항들

  - 어떤 프로그래밍 언어를 사용할 것인가?
    - 솔루션 대부분은 하나의 프로그래밍 언어만 지원
    - 그러므로 쓸 줄 아는 언어를 지원하는 크로스 플랫폼 솔루션을 선택하는 것이 좋음
  - 네이티브와 하이브리드 중 어느 쪽을 원하는가?
    - 보통 네이티브 앱이 속도는 더 빠르고 앱이 구동되는 모바일 플랫폼과도 더욱 유사해 보임
    - 그러나 Xamarin, Cordova 같은 크로스 플랫폼 하이브리드 솔루션은 네이티브와 구별하기 어려울 정도로 네이티브에 가까워 보이게 해줌
  - 지원하고자 하는 플랫폼의 종류는 몇 가지인가?
    - iOS와 안드로이드는 대부분의 크로스 플랫폼 솔루션을 지원
    - 하지만 맥 OS나 윈도우 같은 데스크톱 OS, 전화용 OS, 심지어 라즈베리 파이까지 지원되는 솔루션도 존재
    - 그렇지만 iOS나 안드로이드 외의 플랫폼을 꼭 지원해야 할 이유가 있는 게 아니라면 굳이 크로스 플랫폼 지원까지 신경 쓸 필요는 없음
    - 하지만 게임이라면 최대한 많은 플랫폼을 지원하는 툴을 선택하는 게 좋음 (Unity 3D)
  - 코드를 재사용할 생각인가?
    - 크로스 플랫폼 프레임워크를 사용했다고 해서 한번 작성한 코드를 지원하는 모든 플랫폼에서 그대로 쓸 수 있는 것은 아님
    - 네이티브를 지원하는 크로스 플랫폼 솔루션은 네이티브 프레임워크, 라이브러리, 사용자 인터페이스 요소나 패러다임과 더 긴밀하게 연동되기 때문에 재사용할 수 있는 코드도 줄어듦
    - 네이티브에 더 가깝게 만들 것이냐 아니면 코드를 최대한 많이 재활용할 수 있게 만들 것이냐 둘 중 하나를 선택해야 함
    - 최근에 등장한 Xamarin 같은 크로스 플랫폼 솔루션은 양쪽의 혜택을 모두 누릴 수 있게 해줌
      - Xamarin은 Xamarin Forms라는 공통의 UI 라이브러리를 써서 OS의 네이티브 UI와 프레임워크 위에 추상 레이어를 만듦
    - 궁극적으로 코드 재사용 문제는 어떤 유형의 앱을 만들지, 해당 플랫폼과 네이티브 앱과 어느 정도 어우러지기 원하는지에 따라 각자 판단해야 함

  <br>

### 모바일 웹 앱

- 수년 동안 모바일 브라우저의 능력과 기능이 증가하고 적응형 웹 기술이 발전한 덕에 모바일 웹 앱을 만들 수 있는 길이 열림
- 다른 웹 애플리케이션을 만드는 것과 똑같은 방법을 따르되 모바일 기기에서 작동할 수 있게 설계하면 됨
- 많은 모바일 OS 브라우저가 위치 데이터 얻기, 기기 카메라에 접근하기 등의 작업을 할 수 있도록 웹 브라우저 내부에서 네이티브 기능을 호출할 수 있게 해줌
- 모바일 웹 앱 제작을 도와주는 프레임워크가 꽤 많음
- 모바일 웹 앱이 미래이며, 그 세상이 도래하기까지 시간이 조금 더 필요한 것 뿐

<br>
<br>

# DBA와 DevOps

- 코드 작성을 마쳤다고 소프트웨어 제작이 완료되는 게 아니고, DB가 필요하며, 빌드하고 테스트하고 배포도 해야 함
  - 이 지점에서 DBA(database administrator)와 DevOps 등장
- 소프트웨어 개발이 팀 단위로 이루어지는 경우가 점점 많아지고 있기 때문에 등장 (애자일 환경에서 특히 이런 경향이 강함)
- 지난 수년간 소프트웨어를 만드는 점점 더 좋은 방법을 깨우쳐온 덕에 권장 업무 진행 절차나 '이렇게 해야 마땅하다'라고 주장하는 방법이 굉장히 많이 등장했음
- 스타트업이나 작은 회사에서는 그냥 소프트웨어 개발자가 해당 업무를 같이 하기도 함
  - 하지만 해당 기술 분야에 대한 이해도는 반드시 필요함

<br>

## DBA

- 주요 업무는 DB를 설치하고 유지 보수하고 보호하고 최적화하고 감시하는 일
- 간혹 DB 스키마를 설치하거나 저장 프로시저를 작성하기도 함
- DB를 작동하도록 하는 업무만 하는 DBA도 있고, 작동 업무와 함께 DB 프로그래머에 가깝게 일하는 DBA도 있음

<br>

### DB에는 양육의 손길이 필요하다

- 모든 개발팀에 DBA가 있는 건 아니지만, 누가 되었든 이 업무를 맡는 사람이 있어야 한다는 점은 분명함
  - DB를 설치하고 유지 보수하는 기본적인 방법을 알아두어야 함
- DB는 시간이 지날수록 커지기 때문에 나중에 리소스를 과하게 쓰게 되기도 함
  - DB를 작동할 하드웨어를 잘 골라야 함
  - 때가 되면 업그레이드를 해줘야 함
- DB에는 매우 중요한 데이터가 들어 있으므로 백업을 정기적으로 해야 함
  - 혹여 망가졌을 때 복구해서 작동하게 할 재난 대비책도 필요
- 시간이 지나면 설계나 조율이 잘 되지 않은 DB는 효율이 떨어지고 느려지므로 성능에도 신경 써야 함
  - 처리 속도를 높일 수 있게 평소 DB의 성능을 분석하고 데이터 인덱스를 만들고 정리해야 함

<br>

### DBA가 되어야 할까?

그럴 필요는 없지만 다음 항목을 배워두면 좋다.

- DB 설치 및 설정
- 백업 만들고 복구하기
- 테이블과 스키마 만들기
  - 스키마는 DB의 청사진
    - DB를 어떤 테이블로 나눌지, 데이터를 어떤 양식으로 저장할지 정의 (DB에 대한 거의 모든 것을 정의)
  - 스키마가 있으면 완전히 똑같은 구조의 빈 DB를 만드는 것도 가능
- 저장 프로시저 만들기
  - 저장 프로시저는 DB의 함수나 메소드 또는 프로시저
    - DB 상에서 바로 실행되어 특정 명령을 수행하는 SQL 코드
    - DB에서 하게 될 일반적인 작업을 정리하는 논리적 방법
- 테이블 인덱스 만들기와 인덱스 작동법
- 조회, 삽입, 갱신 등과 같은 기본적인 동작을 수행하는 기초적인 SQL 코드 작성
- 테이블 join
  - 한 개 이상의 다른 테이블에서 가져온 데이터의 교집합, 합집합 또는 그 밖의 조합 방식을 사용하여 DB에 있는 여러 테이블을 조합하는 것을 의미함

<br>

## DevOps: 새로운 직군

- IT 분야에서 완전히 새로운 역할이 만들어지는 일은 드문데도 만들어진 직군
- 역할이 독특하며, 아직 명확하게 정의되지 않았음
- 개발과 운영의 복합체 혹은 매시업이라고 볼 수 있음
- 쉽게 보자면, 코드를 빌드하고 테스트하고 배포하고 실제 서비스를 운영하는 데 필요한 일이라면 뭐든지 하는 직군

<br>

### 운영: 기존 방식

1. 개발자와 운영팀(IT) 존재
2. 개발자는 코드를 작성해서 QA에게 넘김
3. QA는 코드가 엉망이라며 되돌려 보냄
4. 그 둘이 코드를 몇 차례 더 코드를 주고받다가 어느 정도 합의되면 코드를 운영팀으로 보냄
5. 운영팀은 코드가 비효율적이라며 되돌려 보냄
6. 역시 둘이 코드를 주고받다가 결국 운영팀이 코드를 받아들여서 서버에 배포

- 핵심은 과거에는 소프트웨어 개발 세계가 각기 분명히 구분된 팀으로 구성되어 있었다는 것
- 그래도 애자일 소프트웨어 개발 등장 전까지는 견딜 만했음
  - 애자일 이후, 과거에는 6개월에 한 번씩 배포하던 새로운 코드를 요즘은 일주일에도 몇 차례 배포
  - 개발팀은 하루에도 여러 차례 빌드한 코드를 자동으로 테스트하고 품질을 확인하게 됐음
- 코드를 작성하고 빌드하고 배포하는 단순한 구조로는 부족한 시대가 되었으며, 이로 인해 코드를 개발에서 생산까지 빠르게 보낼 수 있게 해줄 완전히 새로운 운영 방식과 절차 탄생

<br>

### DevOps란 무엇인가?

- 코드를 개발해서 생산하기까지의 각 단계를 관리하는 종합적인 공정
- 배포 절차를 자동화하는 빌드 배포 시스템을 만들 때 필요한 코드를 빌드하고 배포할 수 있는 개발자에게 DevOps 역할을 맡기는 조직도 있음
- 개발자, 테스터, 운영 역할은 분리해두되 상호 이해를 바탕으로 협력해서 DevOps 역할을 해내는 조직도 있음

<br>

### 나에게 의미하는 것

- 소프트웨어 개발자는 엄밀히 말해 DevOps에 속함
- 코드 작성 능력만 갖추는 걸로는 부족함
  - 자신이 만든 코드를 다른 사람에게 넘긴 이상 그 사람 문제라고 생각할 수 있는 시절은 지나갔음

⭐ 따라서 소프트웨어 개발자에게 다음과 같은 역량들이 필요함

- 코드를 개발에서 생산까지 보내는 데 쓰이는 절차와 도구 알기
- 소스를 제어하는 방법 알기
- 지속적 통합의 기초, 빌드 서버 작동법의 기초 알기
- 테스트에 대한 기초 지식과 유형 익히기, 다양한 유형의 자동 테스트가 코드 빌드, 배포의 큰 그림에 어떻게 적용되는지 배우기
- 애플리케이션을 패키징하고 배포를 준비하는 법 알기, 배포 절차, 코드를 빌드 서버에서 스테이징 서버나 프로덕션 서버로 자동으로 옮기는 방법, 다양한 서버에서 환경 설정을 관리하는 법 알기
- 모니터링하는 방법 알기

→ 자신이 야구팀 투수라고 상상해보자.  
팀 내 모든 역할에 대해 모든 걸 알 필요는 없다.  
하지만 어떤 역할이 존재하고 각 역할이 어떤 일을 하는지 정도는 알아야 팀의 전략을 세울 때 의견을 낼 수 있다.

<br>
<br>

# 소프트웨어 개발 방법론

- 소프트웨어 개발 커뮤니티에서 소프트웨어 개발 방법론과 이를 구현할 방법이라는 주제보다 더 많은 논쟁을 불러일으키는 주제는 없을 것
- 소프트웨어 개발 방법론은 소프트웨어 제작 절차를 정의함
- 소프트웨어를 만드는 방법, 팀을 이끄는 방법을 구체적으로 알려줌

<br>

## 전통적인 폭포수 개발

- 당시에는 폭포수라는 이름도 없었고 이를 비웃는 일도 없었지만, 그냥 그렇게 하는 것이 당연했음
- 바닥에 닿을 때까지 한 단계가 끝나면 다음에 있는 아래 단계로 내려가며 소프트웨어를 한 번에 한 단계씩 만들어가는 방식
- **SDLC(Software Development Life Cycle)** 가 포함되어 있음
  - 거의 모든 방법론에 SDLC가 등장하지만, 폭포수의 SDLC는 순차적이며, SDLC를 점진적으로 따라갈 뿐이라고 봐도 될 정도

<br>

### SDLC를 반대하는가?

- SDLC란 소프트웨어를 개발하기 위한 `요구사항 분석 - 소프트웨어 설계 - 구현 - 테스트 - 배포 - 유지 보수`로 끝나는 일련의 과정
- 한 번에 한 단계씩 앞으로 전진하고 절대 뒤로 가지 않음
- **요구사항 분석**
  - 무엇을 해야 할까? 어떤 기능이 있어야 할까? 어떻게 보이고 어떻게 동작해야 할까?
  - 고객이나 이해 당사자와 대화를 하면서 알아내거나 직접 생각해내기도 함
  - 어떤 방법을 쓰든 제작에 들어가기 전에 알아야 함 (당연히 그게 늘 가능하지는 않음)
- **소프트웨어 디자인**
  - 어떻게 만들지 알아낼 단계
  - 요구사항을 바탕으로 시스템 아키텍처 설계, 저수준 알고리즘, UML 다이어그램 만들기 → 그 시스템을 어떻게 만들고 동작하게 할지 결정
  - 어느 수준까지 설계해야 할지에 대해서는 의견이 분분하지만 어느 정도 수준의 설계는 늘 필요함
  - 폭포수 방식에서는 **big upfront design(방대한 사전 설계)** 라고 알려진 방법을 사용함
    - 방대한 사전 설계란 세부 사항 대부분에 대한 계획을 아주 낮은 수준까지 설계 단계에서 정해두는 걸 가리킴
  - 일정은 정해져 있고 절대 뒤로 돌아오는 일 없이 앞으로만 나아갈 수 있다면 모든 것을 미리 정해두는 게 이치에 맞겠지만 현실에서는 요구사항이 바뀌고 예측하지 못하는 일들이 일어남
- **구현**
  - 설계를 코드로 바꾸는 단계
- **테스트**
  - 테스터는 테스트를 하고 버그를 찾아냄
    - 몇 번의 논쟁과 속임수를 거친 후에 모두가 다음 단계로 넘어가도 좋다고 동의할 때까지 최대한 많은 버그를 수정
- **배포**
  - 별도로 개발한 컴포넌트가 여러 개라면 하나로 '통합'하여 배포
- **유지 보수**
  - 대부분의 경우 다른 단계보다 유지 보수 단계에 더 오랜 시간이 듦
  - 고객이 찾아내는 버그를 고치고 새로운 기능을 추가하고 다른 모든 일이 순조롭게 흘러가게 해야 함

<br>

## 애자일

- 애자일은 소프트웨어 개발 업계의 판도를 뒤바꿔놓았음
- 애자일은 확실한 형태가 없음

<br>

### 애자일 선언문

- 모든 일은 유타 주에 있는 로지 앳 스노버드 스키 리조트에서 시작되었음
- 서로 다른 개발 방법론을 입안한 이들과 업계 선두주자들 총 17명이 모여서 소프트웨어 개발이 어떤 방식으로 이루어져야 하는지에 대해 공통 기반을 찾으려 한 시도라고 볼 수 있음
- 이들은 소프트웨어 개발에 영향을 미치는 몇 가지 문제에 대해 논의하던 중 **애자일 선언문** 을 만들었음

> 우리는 소프트웨어를 개발하고 다른 사람의 개발을 도와주면서 소프트웨어 개발의 더 나은 방법을 찾아나가는 과정에 있다.  
> 이 작업을 통해 우리는 과정이나 도구보다 개인이나 상호작용을, 포괄적인 문서보다 작동하는 소프트웨어를, 계약 협상보다 고객과의 협력을, 계획을 따르는 것보다 변화에 대응하는 것을 가치 있게 여긴다는 결론에 이르렀다.  
> 이 말인즉 먼저 언급한 것도 가치가 있지만, 우리는 뒤에 언급한 것에 더 높은 가치를 둔다는 뜻이다.

이는 다음에 정의된 12가지 원칙을 기반으로 한다.

1. 우리는 가치 있는 소프트웨어를 빠르게 그리고 지속적으로 제공해서 고객을 만족시키는 것을 가장 중요하게 생각한다.
2. 개발의 후반부일지라도 요구사항 변경을 환영하라. 애자일 프로세스는 변화를 활용해서 고객의 경쟁력을 높이는 데 기여한다.
3. 새로운 소프트웨어는 몇 주나 몇 달의 주기로 자주 제공하라. 간격은 짧을수록 좋다.
4. 프로젝트가 진행되는 동안 사업부서 사람들과 개발자는 매일 만나서 함께 일해야 한다.
5. 의욕 있는 사람들 위주로 팀을 구성하라. 그들이 필요로 하는 환경과 지원을 제공하고 그들이 맡은 일을 완수할 거라고 믿어라.
6. 개발팀으로, 혹은 개발팀 내에서 정보를 전달하는 가장 효율적이고 효과적인 방법은 서로 얼굴을 보고 하는 소통이다.
7. 업무 진척을 측정하는 기본 척도는 작동하는 소프트웨어다.
8. 애자일 프로세스는 지속 가능한 개발을 장려한다. 후원자, 개발자, 사용자는 일정한 속도를 계속 유지할 수 있어야 한다.
9. 기술적 우수성과 좋은 설계에 대한 꾸준한 관심이 기민성을 높인다.
10. 해야 할 일의 양을 최소화하는 단순성이 꼭 필요하다.
11. 최고의 아키텍처, 요구사항, 설계는 자기 조직적인 팀에서 나온다.
12. 팀은 정기적으로 더 효과적으로 일할 방법을 고민하고 이를 통해 이른 결론에 따라서 팀이 어떻게 움직일지 조율하고 조정한다.

<br>

### 애자일은 방법론이 아니다

- 애자일은 소프트웨어 개발이 어떻게 이루어져야 하는지를 매우 높은 수준에서 정의함
  - 그래서 애자일 자체를 방법론으로 보기는 어려움
  - 그보다 애자일이라고 여겨지는 특성을 지닌 다른 여러 방법론의 부모 격이라고 볼 수 있음
- 애자일은 소프트웨어 개발은 점증적으로 이루어져야 한다는 아이디어에 불을 붙였음
- 애자일은 개발이 이루어지는 동안 요구사항 또한 바뀔 수 있고 오히려 바뀌어야 마땅하다는 아이디어를 수용했음
- 두꺼운 서류와 엄격한 규칙보다 서로 얼굴을 보고 하는 소통, 자기 조직적인 팀에 가치를 둠으로써 소프트웨어 개발팀의 다양한 구성원 간 관계를 새롭게 정의했음

<br>

### 폭포수 방식의 문제

- 요구사항 변화가 문제가 됨
  - 더 정확히는 프로젝트 후반이 될 때까지 요구사항의 변화를 알 수 없음
- 소프트웨어 개발자 입장에서는 아무것도 바뀌지 않는 게 좋지만, 세상은 그렇게 돌아가지 않음

<br>

## 스크럼 (Scrum)

- 1990년대 초반 Ken Schwaber와 Jeff Sutherland가 함께 만들었음
  - 두 사람은 1995년에 2가지 방법론을 합쳐서 완성한 스크럼 방법론을 정의하는 공동 논문을 작성했음
- 스크럼은 **소프트웨어 개발팀의 특정 역할** , **소프트웨어를 개발하는 작업 흐름** , **개발의 반복 주기마다 여는 sprint라고도 부르는 회의** 를 까다로운 규범에 따라 정의한 정형화된 방법론
- 가장 흔하게 쓰이지만, 자기들 방식대로 곡해되어서 쓰이는 경우도 많음

<br>

### 스크럼 직책

- **제품 책임자(Product Owner)** : 고객의 소리를 전달하고 작업의 우선순위를 결정하는 역할을 함. 사업과 관련된 이해 당사자 및 고객과 소통하는 역할도 함
- **개발팀** : 코드 작성 외에도 분석, 설계, 테스트 등 소프트웨어 배포와 관련된 모든 일을 맡음
- **스크럼 마스터(Scrum Master)** : 팀이 하는 일을 지연시키는 장애물을 제거하고 제품 책임자와 소통하며 스크럼 프로세스가 문제없이 진행될 수 있게 돕는, 팀의 코치 역할

<br>

### 스크럼 진행 방식

- 소프트웨어 개발을 스프린트라고 부르는 작은 반복 주기로 나누는 것이 스크럼의 기본 아이디어
  - 스프린트로 정해둔 기간 내에 해야 할 일의 양을 정해두고, 각 스프린트를 마칠 때마다 나오는 결과를 점진적으로 고객에게 전달함
- 소프트웨어를 위해 개발해야 할 모든 기능을 **제품 백로그(Product Backlog)** 에 넣어둠
- 제품 백로그에는 **우선순위** 를 정해둠
- 각 스프린트마다 **스프린트 백로그** 를 만들어 제품 백로그 항목 중에서 해당 스프린트에 작업할 항목을 모아둠 (스프린트는 보통 1~2주 정도로 나뉨)
- 각 스프린트가 시작될 무렵 **계획 회의** 를 엶
  - 이 회의를 통해 그 스프린트에 처리한 백로그 항목을 정하고 그 백로그를 달성하기 위해 필요한 노력의 수준은 어떠한지 추산
  - 엄밀히 말해 해당 스프린트가 진행되는 동안 백로그에 있는 모든 항목을 완료하기 위해 헌신해야 함
- 매일 모든 팀원이 한데 모여 자신이 진행하는 업무에 대해 아주 짧게 공유하는 **스크럼 회의** 를 엶
  - 이 회의는 서서 진행함
  - 업무 진행 상황을 전체 팀원과 공유하고 업무를 지연시키는 장애물을 제거하는 것이 목적
  - 매일 같은 장소에서 같은 시간에 엶
  - 각 팀원은 3가지 질문에 답해야 함
    1. 어제는 팀의 스프린트 목표 달성에 도움이 될 만한 어떤 일을 했는가?
    2. 오늘은 팀의 스프린트 목표 달성에 도움이 될 만한 어떤 일을 할 것인가?
    3. 본인이나 팀의 스프린트 목표 달성을 막는 장애물이 있는가?
- 스프린트가 진행되는 동안 팀은 백로그에 있는 모든 항목을 수행하기 위해 함께 노력
- 업무 진행 상황과 속도를 추적하기 위해 보통 **소멸 차트(burndown chart)** 를 사용함
  - 소멸 차트는 남은 시간, story point, 업무 난이도를 비롯해 남은 업무의 양을 확인할 때 필요한 거라면 무엇이든 추적함
- 스프린트가 끝나면 스프린트가 진행되는 동안 완료한 목표를 이해 관계자에게 보여주는 **리뷰** 를 수행함
- 마지막으로 지난 스프린트를 돌아보고 다음 스프린트에 대한 아이디어를 떠올리는 **회고 회의** 를 엶

<br>

### 스크럼 관련 문제

- 제대로 수행하기만 한다면 소프트웨어를 매우 효과적으로 개발할 수 있게 해주는 좋은 방법
  - 하지만 안타깝게도 현실에서는 제대로 구현하지 않는 경우가 많음
  - 실패를 벌충하거나 변칙을 쓰기 위해 모른 척 넘어가는 경우도 많음
- 스크럼이 성공적으로 구현되지 못하는 가장 큰 이유는 **헌신이 부족해서**
  - 백로그 항목을 스프린트에 포함시켜 두고 모든 일이 계획에 따라 착착 진행되면 그 임무를 완수하겠다고 말하기는 정말 쉽지만 실제로 헌신해서 그 임무를 완수하는 건 무척 어려운 일
  - 헌신하지 못한다면 책임의 수준은 낮아지고 스프린트의 의미는 퇴색됨
  - 매일 할 일 목록을 만들고 이를 지키기 위해 최선을 다해도 대부분 실패하는 상황과 무척 비슷함

<br>

## 칸반 (Kanban)

- 스크럼과 유사하지만 훨씬 더 느슨하게 정의된 방법론
- 구체적인 지시보다 원칙에 의존함
- 원래 칸반은 제조 생산 업무를 제한해서 효율을 높이고 재고를 줄이기 위해 만들어졌음
- 소프트웨어 개발에 적용할 때는 **Kanban board** 에 주로 초점을 맞춤
  - 칸반 보드는 몇 개의 칼럼이 있는 간단한 보드
  - 개발 프로세스가 진행되는 업무 단계를 표현함
  - 병목현상이 발생하는 구간을 알아내서 제거할 수 있도록 프로젝트에서 해야 하는 일을 시각화하고, 동시에 진행하는 업무의 양을 제한하는 것이 핵심
  - 진행하는 업무를 WIP(Work in progress)라고 부름
- 스크럼처럼 다양한 분야의 사람들이 모인 자기 조직적인 팀을 기반으로 함
- 기존 시스템이나 프로세스에 쉽게 적용됨
  - 시스템의 업무 흐름이 칸반 보드에 공개적으로 드러나면서 정형화, 시각화됨
- **피드백 루프를 통해 끊임없이 더 나아지는 데 집중함**
- 소프트웨어 개발팀이 칸반을 사용하는 방식이 딱히 정해진 게 아니므로 팀에 따라 프로세스는 달라질 수 있음
  - 보통은 백로그나 해야 할 일을 적은 업무 목록을 만들고 우선순위를 정해둠
  - 그러면 팀원들은 자신이 할 일을 고르고 이를 칸반 보드에 올림
  - 업무가 단계별로 진행됨에 따라 보드에서도 위치를 옮김

<br>

## 익스트림 프로그래밍

- 1996년경 Kent Beck이 만들었고, 1999년 이 프로세스를 자세히 설명하는 첫 번째 책, 『익스트림 프로그래밍』을 출간했음
- 규범이 매우 까다로워서 소프트웨어 개발에 있어 매우 높은 수준의 전문성과 정확성을 끌어냄
- XP는 단위 테스트, 테스트 주도 개발, 객체지향 프로그래밍, 고객 중심 등 당시 모범 사례를 많이 가져와서 극단의 경지라고 부를 수준까지 끌어올렸음
- 극단적이고 엄격하다는 특성 때문에 그렇게 큰 인기를 끌지는 못했지만 오늘날에도 여전히 쓰는 팀이 있음
- XP도 다른 애자일 방법론처럼 변화를 수용하고 개발 주기나 반복 주기를 짧게 적용하는 방식으로 소프트웨어를 점차 진화시킴
- XP 프로젝트의 개발 프로세스는 아주 빡빡한 원칙을 중심으로 진행됨
  - 해야 할 일을 먼저 정한 다음 그 일의 완료 기준을 설정함
  - 업무가 실제로 완료되면 테스트를 시작함
  - 합격 판정 테스트에서 그 업무가 실제 완료되었는지 확인하기 위해 통과해야 하는 완료 기준을 정의함
  - 실제 코드를 작성하기 전에 코드가 다양한 상황에서 해야 할 일을 정확히 정의하는 단위 테스트를 만듦
  - 그리고 실제 코드 개발은 이에 맞춰서 진행
- XP는 Pair programming에 크게 의존함
  - 페어 프로그래밍이란 개발자 2명이 함께 앉아서 공동으로 작업해 모든 코드를 함께 만드는 것
  - 미래보다는 현재의 필요를 염두에 두고 기능을 최대한 단순하게 설계해서 구현하는 것이 목표
  - 미리 최적화를 해둔다거나 당장 필요하지 않은 유연성을 제공하려고 하기보다 실제로 더 복잡한 상황이 발생했을 때 이를 코드가 처리할 수 있게 진화시키는 것이 핵심
    - 보통 미리 해두려고 하면 복잡성이 증가하기 때문
  - 코드 공동 소유와 코딩 표준이라는 개념이 XP에서 매우 중요
- XP는 프로젝트에 참여하는 개발자가 초과 근무를 하지 못하도록 못 박고 있을 정도로 규범이 까다로움
- 모든 팀원이 이 원칙을 지키겠다고 결심하지 않는 한 따르기도 무척 어려움

<br>

## 다른 방법론과 비방법론

- 자신이 몸담았던 개발팀이 어떤 방법론을 따른다고 주장하긴 했지만 제대로 따르지 않았거나 아예 어떤 방법론도 따르지 않는 척하지 않았는가?
- **이제는 상황에 맞게 진화하고 적응할 수 있는 반복과 측정이 가능한 프로세스를 갖추는 게 특정 방법론을 따르는 것보다 중요함**
- 무엇보다 내용이 잘 정리되어 있고 반복이 가능한 프로세스를 갖추는 것이 핵심

<br>
<br>

# 테스트와 QA(Quality Assurance) 기초

## 테스트의 핵심 목표

- **위험 부담을 줄이는 것**
  - 소프트웨어를 사용할 고객에게 가장 큰 영향을 미칠 문제를 사전에 찾아 제거함으로써 위험을 감소시키는 것
  - 의도대로 작동하지 않는 일이 얼마나 자주 발생하는지, 혹은 그 문제가 얼마나 심각한 수준으로 발생하는지
  - 극도로 단순한 애플리케이션이 아닌 이상 버그와 결함을 전부 찾아내거나 모든 입력을 테스트해보는 건 불가능함

1. 소프트웨어의 어떤 영역이 가장 큰 위험 요소인지 우선순위를 정함
2. 위험 요소가 있다고 판단한 영역에 원하는 기능이 제대로 구현되었는지를 어떤 테스트를 통해 확인할지 정함
3. 의도대로 작동하지 않으면 발생한 결함을 기록에 남기고 심각성에 따라 우선순위를 매김
4. 문제가 되는 결함은 고치고 그다지 큰 영향을 미치지 않는 결함은 기록과 함께 그대로 시스템에 남김

<br>

## 일반적인 테스트 유형

### 블랙박스 테스트

- 아주 흔히 쓰이는 방식
- 상위 개념으로, 하위 개념의 여러 테스트가 있다고 보면 됨
- 소프트웨어를 내부가 보이지 않는 검은 상자라 생각하고 진행하는 테스트
- 입력과 출력만 신경쓰면 됨
  - 어떻게 그런 출력이 나왔는지에 대해서는 신경 쓸 필요가 없음
- 편견이 개입할 여지가 적기 때문에 대부분의 테스트가 차용하는 방식
- 쓸 수 있을 때도 있고 없을 때도 있음

<br>

### 화이트박스 테스트

- 소프트웨어의 작동 방식을 어느 정도 알아야 함
  - 시스템의 내부 구조를 이해하고 소스 코드에 접근할 권한이 있어야만 제대로 해볼 수 있음

<br>

### 인수 테스트(acceptance test)

- 때에 따라 사용자 인수 테스트, 시스템 테스트 등 다양한 이름으로 불림
- 소프트웨어가 고객의 요구사항이나 기대에 맞게 제작되었는지 확인하는 테스트, 시스템을 전체적으로 점검하는 테스트
- 시스템의 기능이 될 수도, 사용성이 될 수도 있고 둘 다가 될 수도 있음
- 기대한 만큼의 결과가 나왔느냐를 확인하는 것이 핵심

<br>

### 자동 테스트

- 테스트 실행이나 결과 검증이 자동으로 이루어지는 테스트
- 웹 애플리케이션을 자동으로 테스트하려면 웹 페이지를 열고 데이터를 입력하고 버튼을 누르고 페이지에 출력되는 결과를 확인하는 스크립트를 실행하면 됨
- API를 자동으로 테스트하려면 다양한 데이터로 API를 호출한 후 반환되는 결과를 확인하는 스크립트를 쓰면 됨
- 자동 테스트는 점점 늘어나는 추세
  - 수동으로 테스트 케이스를 계속해서 실행하는 건 지루할 뿐 아니라 에러가 나기 쉽고 비용도 많이 듦
  - 특히 애자일 환경에서는 테스트 주기가 2주 정도로 짧아질 수 있기 때문에 자동 테스트를 수행하는 것이 나음

<br>

### 회귀 테스트(regression test)

- 시스템이 과거에 작동했던 방식 그대로 작동하고 있는지 확인하는 테스트
- 애자일 방법론에서는 새로운 기능을 꾸준히 추가하며 소프트웨어를 점진적으로 발전시키기 때문에 신기능이 기존 기능을 망가뜨릴 위험이 항상 도사리고 있으므로 회귀 테스트가 중요함
- 자동 테스트는 대부분 회귀 테스트

<br>

### 기능 테스트(functional test)

- "나 참, 시스템의 기능이 아니면 뭘 테스트한다는 거야?"라고 생각할 수 있음
  - 하지만 기능 외에도 성능, 사용성, 회복성, 보안, 확장성 등 온갖 것을 대상으로 테스트할 수 있음
- 시스템이 기능적 측면에서 해야 할 일을 잘하고 있는지에 초점을 맞추어 진행하는 테스트

<br>

### 탐색적 테스트(exploratory test)

- 탐색적 테스트를 제대로 수행하려면 애플리케이션의 어떤 영역을 어떤 방식으로 테스트할지에 대한 기본 계획과 가이드라인부터 세워야 함
- 테스트 케이스 없이 애플리케이션을 탐색하면서 예상치 못한 문제를 찾아봄
- 테스터가 밟은 단계를 되짚어보며 문제를 재현할 수 있도록 진행 과정을 녹화하기도 함

<br>

### 그 외 테스트 유형

- 부하 테스트(load test) : 과부하 상태에서 애플리케이션이 어떤 성능을 보이는지 확인
- 성능 테스트(performance test) : 특정 시나리오에서 애플리케이션의 성능을 확인
- 회복 테스트(recovery test) : 문제가 생겼을 때 어떻게 회복하는지 확인
- 보안 테스트(security test)
- 스트레스 테스트(stress test)
- 사용성 테스트(usability test)

<br>

## 테스트 절차

1. 테스트는 보통 테스트 계획을 세우는 것으로 시작함

- 어떤 방식으로 테스트할 것인가?
- 테스트 전략은 무엇인가?
- 어떤 유형의 테스트를 할 것인가?
- 어떤 기능을 테스트할 것인가?
- 일정은 어떻게 되는가?

<br>

2. 시스템의 요구사항 혹은 기능을 기반으로 테스트를 설계하는 단계

- 실행 가능한 테스트 케이스 목록, 테스트 실행 조건의 유형, 테스트 실행에 필요한 사항 정리

<br>

3. 테스트를 만들고 실행

- 이 단계는 한 번에 이루어지기도 하고, 테스트 관리 소프트웨어에서 작성한 후 나중에 별도로 실행하기도 함

<br>

4. 테스트 실행 결과 녹화 및 평가

- 버그나 결함은 보통 버그 추적 시스템에 기록됨

<br>

5. 버그는 우선순위를 매겨서 개발자에게 보내 수정하게 함

<br>

6. 수정된 버그 다시 테스트

→ 소프트웨어가 배포용 코드의 품질 기준에 부합하는 수준에 이를 때까지 이 과정을 반복

<br>

## 애자일 팀의 테스트 방식

- 표준 테스트 절차를 애자일 소프트웨어 개발 생명주기에 맞게 변형해서 사용해야 함
- 코드를 작성하기 전에 테스트 케이스와 테스트 시나리오부터 개발하고 테스트 절차를 더 작은 단계로 나누어서 줄여야 함
  - 테스트 단계를 더 잘게 나누어서 피드백을 더 자주 받아야 한다는 뜻
- 사전에 복잡한 테스트 설계를 갖추기보다 기능 수준에서 테스트를 실행해야 함
  - 각 기능을 미니 프로젝트라고 생각하고 코드 작성 전부터 미니어처 버전의 테스트 실행
- 사실 아예 코드를 작성하기 전에 테스트 케이스를 만드는 게 이상적
- 애자일 테스트에서 고려해야 할 중요한 부분은 자동화

<br>

## 테스트, 당신 그리고 개발자

- 소프트웨어 개발자는 자신이 만든 코드의 품질에 그 누구보다 신경을 써야 함
  - 자신의 버그는 자신이 직접 고치겠다는 책임감
  - 그 이유는 버그가 늦게 발견될수록 고치는 데 더 많은 비용이 들기 때문

<br>
<br>

# 테스트 주도 개발과 단위 테스트

## 단위 테스트란 무엇인가?

- 코드를 가능한 한 작은 '단위'로 실행해보는 테스트를 작성하는 것
- 단위 테스트는 사실 진짜 테스트가 아니며, 아무것도 테스트하지 않음
  - 단위 테스트를 실행해서 작동하지 않는 코드를 찾는 일은 거의 없고, 단위 테스트를 작성하는 도중에 알 수 있게 되기 때문
- 단위 테스트는 코드의 특정 단위가 아주 낮은 수준에서 지켜야 하는 절대적 요구사항을 명시하는 것
  - 특정한 코드의 단위에 특정 상황에서 특정 입력을 넣을 때 어떤 결과가 출력되어야 하는지 명시함
  - 진정한 단위 테스트는 대부분의 프로그래밍 언어에서 최소로 작은 코드 단위인(적어도 객체지향 언어에서는) 클래스를 테스트함

<br>

## 단위 테스트의 가치

1. **코드 설계가 개선됨**

- 코드를 가능한 한 작은 단위로 고립시키는 과정에서 코드 설계의 문제점을 파악하게 해줌
  - 의존성이 포함되지 않게 클래스를 고립시키기 어렵다면 코드가 너무 강하게 결합되어 있는 것
  - 기본적인 기능이 여러 단위에 걸쳐 퍼져 있다면 코드의 응집력이 부족한 것
- 단위 테스트 때문에 엣지 케이스를 생각해내거나 굳이 하지 않아도 되는 다양한 입력을 넣어보다가 버그를 찾아내는 일도 있음
- 단위 테스트는 소프트웨어 개발 생명주기에서 볼 때 테스트보다는 **평가 활동** 에 가까움

2. **자동화된 회귀 테스트를 만들 수 있음**

- 소프트웨어의 동작이 저수준에서 반드시 지켜야 할 명세가 되기도 함
- 코드를 변경하더라도 기능에 문제가 생겨서는 안 됨
- 하지만 실제 단위 테스트를 통해 발견되는 회귀 문제의 수는 아주 적으므로 단위 테스트의 주 목적은 아님
- 테스트할 코드의 단위를 바꿀 때 단위 테스트 자체가 바뀌는 일도 흔하게 일어남
- 회귀 테스트는 고수준에서 블랙박스 테스트로 쓰기에 훨씬 더 효과적임
  - 겉으로 드러나는 행위에 변화가 없더라도 고수준의 코드 내부 구조는 바뀔 수 있기 때문
- 단위 테스트는 내부 구조를 테스트함
  - 그 구조가 변하면 단위 테스트를 그대로 통과하며, 이는 유효하지 않는 단위 테스트가 됨

<br>

## 테스트 주도 개발(TDD)이란 무엇인가?

- TDD의 기본 개념은 코드를 작성하기 전에 테스트부터 작성해서 그 코드가 해야 할 일을 명확하게 정의하는 명세로 쓰는 것
- 굉장히 효과적인 개념인데 종종 잘못 사용됨
- 일반적으로 TDD는 프로덕션 코드 생산을 단위 테스트가 주도하는 것을 의미함
- 단위 테스트를 먼저 작성하고 그 테스트를 통과할 코드를 나중에 작성하는 방식
- 새로운 기능이 필요할 땐 그 기능을 정의하는 테스트부터 작성 후, 해당 테스트를 통과할 수 있도록 코드를 변경하거나 추가함

<br>

## TDD의 목적은 무엇인가?

- **자신이 어떤 일을 하고 있고 그 일이 어떤 가치를 지니는지 이해하지 못하는 상태로 무작정 모범 사례를 따라 하면서 TDD를 하고 있다고 착각하기 쉬움**
- **TDD의 가장 큰 가치는 테스트를 명세로 쓸 수 있게 해주는 것**
- 테스트는 특정 환경에서 정확히 어떤 일이 일어나야 하는지 명시함
  - 그래서 TDD를 쓰려면 무언가 구현하기 전에 무엇을 구현할 생각인지부터 제대로 이해하는 과정이 선행되어야 함
  - 막상 TDD를 하려고 보니 무엇을 테스트해야 할지 감이 오지 않는다면 아직 대상을 제대로 이해하지 못한 것
- TDD는 코드를 가볍고 간결하게 만들어주기도 함
  - 코드를 간결하게 쓰는 사람, 코드의 부피를 줄일 방법을 아는 사람이 최고의 프로그래머

<br>

## TDD의 일반적인 작업 흐름

1. 로그인 기능을 구현하기 위해 로그인 프로세스를 담당할 로직을 처리하는 `Login`이라는 클래스를 만들기로 함
2. 자신이 좋아하는 편집기를 열고 `로그인_정보가_없으면_로그인이_되지_않는다`와 같은 이름으로 단위 테스트를 만듦
3. `Login` 클래스의 인스턴스를 만드는 데 쓸 단위 테스트 코드를 작성(`Login` 클래스 인스턴스는 아직 만들지 않았음)
4. `Login` 클래스 메소드를 호출하면서 사용자명과 패스워드를 빈 문자열로 전달할 테스트 코드를 작성함
5. 사용자가 진짜 로그인하지 않았는지 확인하는 단언문 작성
6. `Login` 클래스를 만들고 그 클래스에 로그인 과정을 구현할 때, 사용자가 로그인했는지 확인할 때 각각 사용할 빈 메소드를 추가하여 컴파일 에러만 해결
7. 테스트를 겨우 통과할 정도로만 기능 구현
8. 다음 테스트, `사용자가_유효한_사용자명과_비밀번호를_가지고_있으면_로그인한다`라는 테스트를 작성해보기로 함
9. `Login` 클래스의 인스턴스를 생성하는 단위 테스트를 작성하고 사용자명과 비밀번호를 넣어서 로그인 시도
10. `Login` 클래스를 통해 사용자가 로그인했음을 확인하는 단언문을 단위 테스트에 작성
11. `Login` 클래스에서 사용자가 로그인했는지 확인하는 코드를 작성

<br>

## 이 정도는 기본이다

- 코드 단위를 고립시키려고 하면 할수록 더 복잡해짐
  - 완전히 고립시킨 상태로 존재할 수 있는 클래스는 거의 없음
    - 클래스는 의존적이고 그러한 의존성이 계속 더 많은 의존성을 낳음
      - 이런 문제를 해결하기 위해 mock(모의 객체)을 사용함
        - mock은 미리 설정한 값을 써서 의존성이 있는 기능을 흉내 내어 테스트하고자 하는 개별 클래스를 고립시킬 수 있게 도와줌

<br>
<br>

# 소스 제어

## 소스 제어란 무엇인가?

- 버전 제어라고도 불림
- 파일의 버전과 소프트웨어 프로젝트의 소스 코드를 추적하는 방법
- 여러 개발자가 똑같은 파일을 가지고 작업할 때 이를 조율하는 역할
- 소프트웨어 개발 프로젝트의 소스 코드를 잘 관리할 수 있게 도와주는 것

<br>

## 소스 제어가 중요한 이유는 무엇인가?

- 코드를 '분실'할 가능성이 크게 낮아짐
- 여러 개발자가 한 코드 베이스에 있는 여러 파일에서 함께 작업할 수 있음
  - 좋은 소스 제어 시스템을 쓰면 여러 개발자가 같은 파일로 동시에 작업하고 나중에 한꺼번에 병합할 수 있음
- 여러 버전을 가지고 작업하는 문제도 해결해줌

<br>

## 저장소

- 코드를 저장해두는 장소
- 소스 코드를 쓸 때는 저장소에서 코드를 가져와서 작업한 후 수정 사항을 체크인
- 어떤 코드 베이스든지 기록 시스템 역할을 하는 하나의 중앙 장소 혹은 저장소가 있음

<br>

## 코드 체크아웃

- 소스 제어 시스템에서는 로컬 버전 코드를 자신의 컴퓨터나 로컬 저장소에 가져오는 방식으로 코드를 '체크아웃'할 수 있음
- 체크아웃한 코드가 로컬 버전이 되고 자신이 만든 수정 사항은 자신의 컴퓨터나 로컬 저장소에만 저장됨
- 본인이 수정한 사항을 다른 개발자에게 보여주려면 코드를 '체크인'하거나 중앙 저장소에 병합해야 함

<br>

## 리비전 (revision)

- 소스 제어에 저장된 파일의 이전 버전을 가리킴
- 수정하면서 코드를 망쳤다면 이전 리비전으로 되돌아가거나 그 리비전을 체크아웃한 후 본인이 수정한 일은 없던 걸로 여기면 됨
- 리비전 기록을 살펴보면서 시간이 지남에 따라 파일이 어떻게 변화하는지 수정 사항을 비교해볼 수도 있음

<br>

## 분기

- 기존의 코드 베이스에서 **branch** 를 만들어 **trunk** 로부터 독립적으로 진화한 새로운 코드 베이스를 만들 수 있게 해줌
- 배포 시 고객에게 보여줄 준비가 안된 기능은 분기해서 따로 작업할 수 있게 해줌

<br>

## 병합

- 말 그대로 어떤 코드에 있는 변경 사항을 다른 코드에 합치는 것을 가리킴
- 분기로 나누었던 코드를 다시 trunk에 합쳐줌

<br>

## 충돌

- 보통 소스 제어 시스템은 한 파일에 생긴 간단한 수정 사항을 다른 파일에 자동으로 병합
- 하지만 2명의 개발자가 파일의 같은 부분을 수정한다면 결국 수작업으로 두 변경 사항을 조정해야 함
- 컴퓨터는 어떤 수정 사항이 우선인지 모름

<br>

## 중앙 집중형 소스 제어

- 중앙 서버에는 한 개의 저장소가 있음
- 그 코드를 가지고 작업하는 모든 개발자가 그 저장소를 통해 필요한 파일의 사본을 구하고 수정 사항을 체크인
- 각 개발자에게는 중앙 저장소에 코드를 체크인, 체크아웃하는 것을 관리하는 소스 제어 클라이언트가 있음
  - 파일의 모든 버전 기록과 리비전은 이 중앙 저장소에 저장됨

<br>

## 분산 제어형 소스 제어

- 각 개발자가 자신의 컴퓨터에 전체 저장소의 완전한 사본을 가지고 있다는 게 DVCS 시스템의 가장 큰 특징
- 그래도 저장 시스템 역할을 하는 저장소 중앙 버전 혹은 마스터 저장소가 있어야 함
- 수정 사항을 적용할 때에는 **pull** 과 **push** 를 이용

<br>

## CVS (Concurrent Versions System)

- 서브버전의 전신
- 꽤 튼튼하고 강력한 중앙 집중형 소스 제어 시스템
  - 그 대신 조금 느리기 때문에 CVS를 쓰는 대부분의 조직은 결국 서브버전으로 전향함
- 태그와 분기, 커밋의 롤백 처리 방식이 조금 다름

<br>

## Subversion

- 중앙 집중형 소스 제어 시스템 중에는 가장 나음
- 맡은 역할을 잘 해내고 사용하기 쉬운 편

<br>

## Git

- 소스 제어의 동의어가 되어버림
- 아주 강력하지만 기본은 꽤 단순하고, 빠르고 효율적이며 보편적
- 오픈 소스를 지원
- 깃 프로젝트 호스팅을 관리한 꽤 큰 회사인 Github 운영

<br>

## Mercurial

- 깃이 맥가이버라면 머큐리얼은 제임스 본드
- 깃보다 조금 더 우아하고 세련된 느낌
- 깃과 기본 기능과 특징이 같지만 조금 더 이해하기 쉽고 사용하기도 쉬움
  - 깃은 조금 더 난해한 대신 뭔가 다른 일을 해볼 여지가 있음

<br>
<br>

# CI (Continuous Integration)

- 개발자들이 각기 작업 중인 코드를 더 자주 병합함으로써 병합 지옥에 빠지지 않도록 하기 위한 장치
- 빠른 피드백을 제공해줌
  - 피드백 주기가 빠를수록 소프트웨어의 진화는 빨라지고 전체 품질은 개선됨

<br>

## 과거의 코드 빌드 방법

- 옛날에는 소스 코드 사본을 얻어야 할 때도 있었음
- 소프트웨어를 5년간 관리해온 구루가 보여주는 마법의 주문을 보아야만 주체적으로 일할 수 있었음
- 개발자들이 각기 로컬에서 작업하기 때문에 외부 라이브러리의 버전, 소스 코드의 버전, 파일이나 폴더의 구조 등 문제의 소지가 굉장히 많았음
- 소프트웨어를 한 번 빌드하는 데만 4~5시간이 걸리는 경우도 있었음

<br>

### 빌드 서버의 등장

- 개발자 각자의 컴퓨터에서 빌드하는 대신 환경과 라이브러리를 제대로 갖춘 중앙 빌드 서버를 만드는 방식 등장
- 처음엔 주간 빌드로 시작
  - 적어도 일주일에 한 번은 공식 빌드를 진행
  - 팀의 규모가 커질수록 주간 빌드를 하다가 통합 지옥이 자주 연출되기도 했음
- 야간 빌드가 인기를 끌게 됨
  - 문제를 훨씬 일찍 발견할 수 있게 되어서 큰 문제가 쌓이는 일이 줄어듦
  - 사람들이 빌드 프로세스를 자동화해야겠다고 느끼게 해줌
  - 애자일이 인기를 끌게 되면서 피드백 주기가 더 짧아져야 했음
    - 하루에도 여러 차례 코드를 빌드할 믿을 만한 방법이 필요해졌음

<br>

### 지속적 통합의 등장

- 빌드 서버에서 작동할 수 있는 소프트웨어가 개발됨
- 이 소프트웨어는 소스 제어의 변화를 감지하고 최신 코드를 내려 받고 빌드를 실행하는 기능을 탑재했음
- 이후 처음 한 번만 체크인하면 단위 테스트, 정적 코드 분석기 실행이 동시에 이루어지는 수준까지 진화
- 수정한 코드 때문에 프로젝트 전체의 컴파일에 문제가 발생하면 몇 분 내로 알 수 있게 되었음
- 실패한 단위 테스트를 알아내고 문제가 된 변경 사항을 찾기 위해 회귀 테스트도 자동 실행할 수 있게 되었음

<br>

## 지속적 통합 작업 흐름 샘플

### 코드 체크인

- 작업 흐름의 시작
- 물론 빌드를 망가뜨리지 않도록 로컬 환경에서의 빌드 및 단위 테스트를 모두 실행해봤어야 함

<br>

### 새 빌드 시작

- 빌드 서버에 있는 CI 소프트웨어가 모니터링하던 소스 제어 브랜치의 변화를 감지
- CI 서버는 새로운 빌드를 시작

<br>

### 코드 체크아웃

- 새 빌드가 시작되면 최신 수정 사항부터 가져옴
- 브랜치에 일어난 모든 변화를 내려받고 작업 디렉토리에 삽입

<br>

### 코드 컴파일

- 빌드 스크립트가 실제로 코드를 컴파일하고 빌드하기 시작하는 시점
- 빌드 스크립트는 소스 코드 빌드 명령을 실행
- 외부 라이브러리를 비롯해 코드 컴파일에 필요한 모든 것을 링크
- 코드가 컴파일되지 않으면 멈추고 에러 보고

<br>

### 정적 분석기 실행

- 빌드 이후 정적 분석기가 실행되어 코드 품질 측정
- 사용되지 않는 변수, 불필요한 객체 생성, 순환 복잡도, 유지 보수성 인덱스, 상속의 깊이, 코드 라인 수 등 잠재적 문제들을 검사해줌
- 분석기에서 나온 결과는 빌드 완료 시 보고할 수 있도록 저장됨
  - 분석기에서 산출한 코드 품질 검수가 기준에 미치지 못하면 빌드가 실패하도록 설정하는 경우도 있음

<br>

### 단위 테스트 실행

- 컴파일된 코드를 대상으로 단위 테스트 실행 및 결과 기록
- 단위 테스트 실패 시 보통 빌드 자체가 실패

<br>

### 결과 보고

- 빌드의 성공 여부, 실행 소모 시간, 코드 품질 기준, 단위 테스트 등에 대한 정보가 담김
- 문서 또한 빌드에 의해 자동 생성
- 결과를 이메일로 팀원들에게 보내도록 설정할 수 있음
  - 실패했을 때만 보내게 할 수도 있음
- 대부분의 CI 소프트웨어 프로그램은 최신 빌드의 결과를 볼 수 있는 웹 인터페이스도 갖추고 있음

<br>

### 소프트웨어 패키징

- 빌드 소프트웨어는 배포하거나 설치할 수 있는 형태로 패키징됨
- 컴파일된 코드와 더불어 외부 리소스나 의존성을 어떤 구조로 묶어서 배포 또는 설치가 가능한 형태로 만드는 과정 포함
- 모든 파일을 포함하는 파일 구조를 만든 후 전체를 압축하기도 함
- 이 시점에서 소프트웨어의 버전을 표시하기 위해 소스 제어에 태그를 추가하기도 함

<br>

### 코드의 선택적 배포(지속적 배포)

- 마지막 단계는 선택 사항이지만 지속적 배포를 시행하는 팀이 점점 늘어나는 추세
- 지속적 배포란 테스트 목적으로 코드를 특정 환경에 직접 배포해보는 것
- 용감하다면 바로 생산하기도 함

<br>

## CI 서버와 소프트웨어

### Jenkins

- 원래는 Java 환경에서 CI를 할 수 있게 만들어진 Java 프로그램이었음
  - 하지만 사용하기 쉬운 데다 유명세까지 얻으면서 다른 대부분의 기술에서도 쓸 수 있게 되었음
- 자체적으로 웹 서버를 갖추고 있어서 설치하고 실행하기가 정말 쉽고 플러그인도 많음

<br>

### Hudson

- 사실 허드슨으로부터 젠킨스가 갈라져 나왔음
- 오라클이 관리하지만 업데이트가 느리고 잘 사용되지 않음

<br>

### Travis CI

- 호스팅 또는 서비스 형태로 제공됨
  - 다시 말해 설치가 아닌 가입을 해야 함
- 깃허브에 호스팅된 프로젝트에서 CI를 실행할 수 있도록 만든 소프트웨어
  - 깃허브에 호스팅된 프로젝트가 많아서 인기를 끌게 되었음
- 설계도 훌륭하고 사용하기도 쉬우며 빌드 서버를 유지 보수할 필요가 없음

<br>

### TFS (Team Foundation Server)

- 마이크로소프트 개발 도구를 사용하는 업체에서 사용
- 지나치게 단순화되었고 경쟁력도 떨어짐

<br>

### TeamCity

- JetBrains라는 영리 회사가 만듦
- 무료 버전이 있긴 하지만 라이센스 제품
  - 그러므로 조금 더 전문적인 지원을 받을 수 있는 제품을 찾는 사람에게 좋음
- 많은 .NET 팀이 팀시티를 CI 서버로 이용함

<br>
<br>

# 디버깅

- 코드 작성 능력과 코드 디버깅 능력은 서로 별개
- 디버깅에 접근하는 태도가 무엇보다 중요

<br>

## 디버깅이란 무엇인가?

- 디버깅은 디버거와 아무 관련이 없음
- **코드 베이스에서 문제의 근원을 찾아서 그 문제를 일으킬 만한 요인을 가려내고, 여러 가설을 시험해보는 과정을 통해 뿌리가 되는 진정한 원인을 찾고 그 원인을 제거한 후, 다시는 그 문제가 일어나지 않도록 하는 것이 디버깅**

<br>

## 디버깅 첫 번째 규칙 : 디버거를 쓰지 마라

- 디버거는 최후의 수단
- 디버거는 훌륭하고 강력한 도구이지만 디버거에 손도 대기 전에 해결할 수 있는 버그가 많음

<br>

## 에러를 재현하라

- 재현할 수 없는 문제는 디버깅하는 게 의미가 없음
- 버그가 간헐적으로 발생한다는 것은 재현에 필요한 환경이 무엇인지 모른다는 뜻
  - 세상에 간헐적으로 발생하는 문제는 없음

<br>

## 앉아서 생각하라

- 대부분의 소프트웨어 개발자가 문제를 빨리 해결하고 싶은 마음에 건너뛰는 단계
- 어디를 살펴보고 무엇을 찾을지부터 아는 게 중요
  - 무엇을 테스트해보고 싶은지 적어도 몇 가지 아이디어를 떠올려야 함

<br>

## 가설을 테스트하라

- 자신이 세운 가설을 테스트할 단위 테스트 작성
  - 단위 테스트를 하나씩 통과할 때마다 가능성 제거
- 잘못된 경로를 계속해서 다시 방문하게 하는 게 디버거의 단점
- 가설을 테스트하기 위해 단위 테스트를 쓰는 게 아주 어렵거나 불가능할 때는 디버거 사용
  - 다만 목적을 분명히 할 것

<br>

## 가정을 확인하라

- 사람은 코드가 어떤 방식으로 작동해야 한다고 가정하는 경향이 있음
- 단위 테스트를 통해 가정을 확인하는 과정이 필요함

<br>

## 분할 정복하라

- 코드를 반으로 자를 방법을 찾아라
- 코드, 시스템, 변수를 최대한 제거한 후에도 버그가 재현되는지 확인하라

<br>

## 고칠 때는 이유를 이해하라

- **그 문제가 왜 고쳐졌는지 이해하지 못하면 아직 문제를 다 고친 게 아님**
- 의도치 않게 다른 문제를 일으켰을 수도 있고 원래 문제도 해결되지 않았을 확률도 있음
- 문제는 저절로 사라지는 일은 없고, 다만 잠시 숨은 것일 뿐
- 원인이 정확히 무엇이었는지, 어떻게 고친 것인지 제대로 이해하라
- 회귀 테스트를 작성해서 그런 일이 다시 발생하지 않도록 하라
- 버그가 발생한 클래스의 다른 인스턴스를 살펴보라
  - 버그는 서로 붙어 다니는 경향이 있음
