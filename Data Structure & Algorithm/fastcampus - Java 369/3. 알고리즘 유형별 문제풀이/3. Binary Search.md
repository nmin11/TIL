## 개념

- **정렬이 보장되어 있는 배열**에서 기준을 가지고 배열을 이분하면서 탐색하는 방법
- 시간복잡도 : O(log N)

<br>

## 활용 방안

- 항상 전형적인 변수 세팅을 가지고 시작
  - L : 탐색할 가치가 있는 왼쪽 끝 index
  - R : 탐색할 가치가 있는 오른쪽 끝 index
  - Result : 탐색한 x의 위치 index
- 가운데 지점의 값을 확인하면서 L과 R을 계속 옮겨주고,<br>최종적으로 x와 일치하는 값, 혹은 x와 가장 가까우면서 작은 값을 찾음
- L > R 이 되어버리면 탐색할 가치가 있는 구간이 없다는 것
- 구간의 길이는 N → 1/2 → 1/4 → ... → 1 이 되므로 구간이 점점 좁아짐
  - 총 비교 횟수는 구간의 변화 횟수인 O(log N)
  - 예를들어 N이 10만이면 약 16번만 비교해도 되는 미친 효율

<br>

## 자주 하는 실수

- 3위 : L과 R 범위나 Result 초기값을 잘못 설정
- 2위 : L, R, M, Result 등의 변수 정의를 헷갈려서 부등호 등을 잘못 쓰는 경우
- 1위 : 이분 탐색을 할 줄 아는데, 정렬을 하지 않은 경우!

<br>

## 문제 풀이

### [BOJ 7795 - 먹을 것인가 먹힐 것인가](https://www.acmicpc.net/problem/7795)

- 난이도 : 2
- N <= 20,000
- M <= 20,000
- 정답의 최대치
  - N과 M이 20,000
  - N 배열의 모든 값은 2, M 배열의 모든 값은 1, 즉, 모든 원소들의 쌍이 만들어짐
  - N \* M = 4억
  - 4억은 int 타입으로 풀이 가능!
- 가장 쉬운 해법
  - N 배열의 모든 원소에 대해 M 배열을 순회하면서 비교
  - 최악의 경우 4억 번의 연산을 해야되고, 4억은 4초, 이 문제의 시간 제한은 1초이므로 불가능
- 이분 탐색 방법
  - M 배열을 우선 정렬 O(M log M)
  - 이후 이분 탐색을 하면 O(log M)
  - 그런데 N의 원소마다 이분 탐색을 하므로 O(N log M)
  - 총 시간복잡도 : O((N+M) log M)

```java
static int N, M;
static int[] A, B;

static void input() {
    N = scan.nextInt();
    M = scan.nextInt();
    A = new int[N + 1];
    B = new int[M + 1];
    for (int i = 1; i <= N; i++) {
        A[i] = scan.nextInt();
    }
    for (int i = 1; i <= M; i++) {
        B[i] = scan.nextInt();
    }
}

static int lower_bound(int[] A, int L, int R, int X) {
    // A[L...R] 에서 X 미만의 수 중 제일 오른쪽 인덱스를 return 하는 함수
    // 그런 게 없다면 L - 1 을 return 한다

    int res = L - 1;  // 만약 A[L...R] 중 X 이하의 수가 없다면 L - 1 을 return 한다.
    while (L <= R) {
        int mid = (L + R) / 2;
        if (A[mid] < X) {
            res = mid;
            L = mid + 1;
        } else {
            R = mid - 1;
        }
    }
    return res;
}

static void solve() {
    // B 배열에 대해 이분탐색을 할 예정이니까, 정렬을 해주자!
    Arrays.sort(B, 1, M + 1);

    int ans = 0;
    for (int i = 1; i <= N; i++) {
        // A[i] 를 선택했을 때, B 에서는 A[i]보다 작은 게 몇 개나 있는 지 count 하기
        ans += lower_bound(B, 1, M, A[i]);
    }
    System.out.println(ans);
}

public static void main(String[] args) {
    int TT;
    TT = scan.nextInt();
    for (int tt = 1; tt <= TT; tt++) {
        input();
        solve();
    }
}
```

### [BOJ 2470 - 두 용액](https://www.acmicpc.net/problem/2470)

- 난이도 : 3
- 2 <= N <= 100,000
- -10억 <= N[i] <= 10억
- 정답의 최대치
  - -20억 <= 두 수의 합 <= 20억
  - int로 충분!
- 가장 쉬운 해법
  - 배열을 이중 순회하면서 모든 경우의 수 고려
  - O(N²)
  - N은 10만까지 갈 수 있으므로 100억에 달하고, 문제를 풀어낼 수 없음
- O(N log N) 방법
  - 오른쪽 용액을 고를 때 왼쪽 용액 A[left]와 더해서 0에 가까우려면 -A[left]와 가까우면 됨
  - 즉, A[left]를 정했을 때 -A[left]랑 가장 가까운 것을 빨리 찾아야 함
  - 이를 A[left + 1] 부터 A[N] 사이에서 찾아야 함
  - 정렬을 함으로써 이분 탐색을 사용하고, 가장 가까운 원소를 빠르게 찾을 수 있게 됨
  - A[left + 1] ~ A[N] 에서 X = -A[left] 이상의 원소 중 가장 왼쪽
  - 만약 없으면 N + 1 반환
  - A[result - 1] 과 A[result] 중에 X랑 가장 가까운 원소가 있음
  - 대신 result - 1 과 result 중 left + 1 이상 N 이하인 원소
  - 시간복잡도 분석
    - 배열 정렬 : O(N log N)
    - 모든 원소마다 left 정하고 -A[left] 이분 탐색 : O(N log N)
    - 총 시간복잡도 : O(N log N)
