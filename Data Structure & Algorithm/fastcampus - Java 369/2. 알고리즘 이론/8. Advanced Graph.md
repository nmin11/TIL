## Dijkstra

- 두 노드를 잇는 가장 짧은 경로를 찾는 문제
- Weighted Graph에서 간선의 가중치의 합이 최소가 되도록 하는 것이 목적
  - **방향이 있는 가중치 그래프**를 탐색한다고 볼 수 있음
- 자기 노드와 연결되어 있는 노드를 우선 탐색하기 때문에 BFS와 유사
- 우선순위 큐를 구현하는 방법이 간단함

### 종류

- single-source : 특정 노드에서 출발해서 다른 모든 노드를 방문하는 최단 경로
- single-destination : 모든 노드들로부터 출발해서 특정 노드로 도착하는 최단 경로
- single-pair : 주어진 2개의 노드 사이의 최단 경로
- all-pair : 그래프 내 모든 노드 쌍 사이의 최단 경로

### 구현

```java
class Edge implements Comparable<Edge> {
  public int distance;
  public String vertex;

  public Edge(int distance, String vertex) {
    this.distance = distance;
    this.vertex = vertex;
  }

  public String toString() { return "vertex: " + this.vertex + ", distance: " + this.distance; }

  @Override
  public int compareTo(Edge edge) { return this.distance - edge.distance; }
}
```

```java
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;

public HashMap<String, Integer> dijkstra(HashMap<String, ArrayList<Edge>> graph, String start) {
  if (graph.get(start).size() == 0) {
    System.out.println("연결된 간선이 없습니다!");
    return null;
  }

  Edge node;
  ArrayList<Edge> nodeList;
  int currentDistance, weight, distance;
  String currentNode, adjacent;
  PriorityQueue<Edge> pq = new PriorityQueue<>();
  HashMap<String, Integer> distances = new HashMap<>();

  for (String key : graph.keySet()) {
    distances.put(key, Integer.MAX_VALUE);
  }

  distances.put(start, 0);
  pq.add(new Edge(distances.get(start), start));

  while (pq.size() > 0) {
    node = pq.poll();
    currentDistance = node.distance;
    currentNode = node.vertex;

    if (distances.get(currentNode) < currentDistance) continue;

    nodeList = graph.get(currentNode);
    for (Edge edge : nodeList) {
      adjacent = edge.vertex;
      weight = edge.distance;
      distance = currentDistance + weight;

      if (distance < distances.get(adjacent)) {
        distances.put(adjacent, distance);
        pq.add(new Edge(distance, adjacent));
      }
    }
  }

  return distance;
}
```

- 시간복잡도 : O(NlogN)
  - 각 노드와 간선은 최대 한번씩 검사하므로 O(E)
  - 만약 모든 노드에서 최단 거리를 갱신하게 되는 경우 모든 간선을 한번씩 검사하므로 O(E)
  - 각 노드의 거리 정보를 우선순위 큐에 유지하는 비용은 O(logE)
  - 합치면 O(E) + O(E) + O(logE) = O(E logE)

<br>

## Spanning Tree

- 신장 트리라고도 불림
- 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프
- 조건
  - 본래 그래프의 모든 노드 포함
  - 모든 노드는 서로 연결
  - 사이클이 존재하지 않는 트리의 속성 반영

### Minimum Spanning Tree (MST)

- 최소 신장 트리라고도 불림
- 가능한 Spanning Tree 중에서 간선의 가중치의 합이 최소인 것
- 대표적인 MST algorithm으로, Kruskal's algorithm과 Prim's algorithm이 있음

<br>

## Kruskal's algorithm

1. 모든 정점을 독립적인 집합으로 만듦
2. 모든 간선을 비용을 기준으로 정렬, 비용이 적은 간선부터 간선의 양 끝의 두 정점을 비교
3. 두 정점의 최상위 정점을 확인하고 서로 다를 경우 두 정점을 연결 (Cycle 방지)

⭐ 당장 눈 앞의 최소 비용을 선택하므로, Greedy를 기초로 하고 있는 셈

### Union-Find algorithm

- Disjoint Set을 표현할 때 사용
  - 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
  - 서로소 집합 자료구조라고도 불림
- 트리 구조를 활용함
- 연결된 노드를 찾거나 노드를 연결할 때 사용
- 중복되지 않는 부분 집합들이기 때문에 그래프에서 Cycle을 방지하기에 용이함!

1. 초기화 : n개의 원소가 개별 집합을 갖도록 초기화
2. Union : 두 개별 집합을 하나의 집합으로 합치고, 두 트리를 하나의 트리로 합침
3. Find : 여러 노드 중 2개의 노드를 선택해서, 두 노드가 같은 그래프에 있는지 판별하기 위해 각자의 루트 노드 확인

※ 주의할 점

- 순서를 잘못 고려하면 LinkedList와 같이 Tree의 깊이가 깊어지는 형태가 될 수 있고,<br>그렇게 되면 시간복잡도가 O(N)이 되어버림
- 이를 해결하기 위해 union-by-rank, path compression 기법 활용

#### union by rank

- 각 트리에 대해 높이를 기억해두고, union 시 높이가 큰 트리를 루트 노드로 하여,<br>작은 트리를 큰 트리에 붙이도록 하는 방식
- 시간복잡도 : O(logN)

#### path compression

- find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 기법
- 연결된 이후에는 루트 노드를 한번에 알 수 있게 됨
- 시간복잡도 : O(Mlog\*N)
  - 이는 거의 O(1)에 가까움

### Kruskal 구현

```java
class Edge implements Comparable<Edge> {
  public int weight;
  public String nodeV;
  public String nodeU;

  public Edge(int weight, String nodeV, String nodeU) {
    this.weight = weight;
    this.nodeV = nodeV;
    this.nodeU = nodeU;
  }

  @Override
  public int compareTo(Edge edge) { return this.weight - edge.weight; }
}
```

```java
import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Collection;

public class Kruskal {
  HashMap<String, String> parent = new HashMap<>();
  HashMap<String, Integer> rank = new HashMap<>();

  public String find(String node) {
    // path compression
    if (!this.parent.get(node).equals(node)) {
      this.parent.put(node, find(this.parent.get(node)));
    }

    return this.parent.get(node);
  }

  public void union(String nodeV, String nodeU) {
    String root1 = find(nodeV);
    String root2 = find(nodeU);

    // union by rank
    if (this.rank.get(root1) > this.rank.get(root2)) {
      this.parent.put(root2, root1);
    } else {
      this.parent.put(root1, root2);
      if (this.rank.get(root1).equals(this.rank.get(root2))) {
        this.rank.put(root2, this.rank.get(root2) + 1);
      }
    }
  }

  public void makeSet(String node) {
    this.parent.put(node, node);
    this.rank.put(node, 0);
  }

  public ArrayList<Edge> kruskal(ArrayList<String> vertices, ArrayList<Edge> edges) {
    ArrayList<Edge> mst = new ArrayList<>();

    // 1. initialize
    for (String vertex : vertices) makeSet(vertex);

    // 2. sort
    Collections.sort(edges);

    for (Edge edge : edges) {
      if (!find(edge.nodeV).equals(find(edge.nodeU))) {
        union(edge.nodeV, edge.nodeU);
        mst.add(edge);
      }
    }

    return mst;
  }
}
```

- 시간복잡도 : O(NlogN)
  - 간선을 가중치 기준으로 정렬하는 시간이 가장 큼
  1. 모든 정점을 독립적인 집합으로 : O(N)
  2. 모든 간선을 가중치 기준 정렬하고 가장 작은 간선부터 양 끝 정점 비교 : O(NlogN)
  3. 두 정점의 최상위 정점을 비교하면서 연결 : O(Mlog\*N)
