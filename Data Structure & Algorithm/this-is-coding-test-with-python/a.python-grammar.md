# 자료형

## 수 자료형

### 지수 표현 방식

- `e` 혹은 `E` 를 활용한 지수 표현 방식 사용 가능
- `e` 다음에 오는 수는 10의 지수부를 뜻함
- 예를 들어 `1e9` 는 10의 9제곱(10억)이 됨

```py
a = 1e9
print(a)

a = 75.25e1
print(a)

a = 3954e-3
print(a)
```

```sh
1000000000.0
752.5
3.954
```

### 실수형의 정확도 문제

- IEEE754 표준에서 실수형을 저장할 때 4Byte 혹은 8Byte라는 고정된 크기의 메모리 할당
- 이로 인해 현대 컴퓨터 시스템은 대체로 실수 정보 표현 정확도에 한계를 가짐
- 이럴 때 `round()` 함수를 이용하자
  - 첫 번째 인자에 실수형 데이터를
  - 두 번째 인자에 반올림하고자 하는 위치를
- 흔히 코딩 테스트에서는 소수점 5번째 자리에서 반올림한 결과가 같으면 정답으로 인정하곤 함
  - `round(n, 4)` 를 애용하자

```py
a = 0.3 + 0.6
print(round(a, 4))
```

```sh
0.9
```

### 나누기 연산자와 몫 연산자

- 파이썬에서 나누기 연산자(`/`)는 기본적으로 실수형 처리
- 나눈 결과에서 몫만 얻고자 할 때는 몫 연산자(`//`)를 사용하자

### 거듭 제곱 연산자

- `x ** n` = `xⁿ`

## 리스트 자료형

### 1차원 리스트 초기화

- 코딩 테스트에서는 크기가 N인 1차원 리스트를 초기화할 일이 많음

```py
n = 10
a = [0] * n
```

### 리스트 슬라이싱

- `:` 키워드를 활용

```py
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[1 : 4])
```

```sh
[2, 3, 4]
```

### 리스트 컴프리헨션

- 리스트 안에 조건문과 반복문을 넣는 방식으로 리스트 초기화를 할 수 있음
- **2차원 리스트**를 초기화할 때 반드시 활용해야 하는 방법

```py
array = [i for i in range(20) if i % 2 == 1]
print(array)

array = [i * i for i in range(1, 10)]
print(array)

n = 3
m = 4
array = [[0] * m for _ in range(n)]
print(array)
```

```sh
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
[1, 4, 9, 16, 25, 36, 49, 64, 81]
[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
```

### 리스트의 메서드들

`append()`

- 원소 삽입
- O(1)

`sort()`

- 오름차순 정렬
- 내림차순 정렬 = `sort(reverse = True)`
- O(NlogN)

`reverse()`

- 원소들의 순서 뒤집기
- O(N)

`insert()`

- 특정 인덱스에 원소 삽입
- 첫 번째 인자 = 삽입할 인덱스
- 두 번째 인자 = 삽입할 값
- O(N)

`count()`

- 원소 중 특정 값을 갖는 데이터 개수 세기
- 인자 = 특정 값
- O(N)

`remove()`

- 원소 중 특정 값을 갖는 원소 하나만 제거

### 리스트에서 특정 값의 원소를 모두 제거하려면

- 제공되는 기본 함수가 없으므로 직접 해야 한다

```py
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}
result = [i for i in a if i not in remove_set]
print(result)
```

```sh
[1, 2, 4]
```

## 튜플 자료형

- 리스트와 비슷하지만 약간의 차이가 있음
  - 한 번 선언된 값을 변경할 수 없음
  - 리스트는 `[]` 튜플은 `()`
- 리스트에 비해 공간 효율적
- 일반적으로 각 원소의 성질이 서로 다를 때 주로 사용
- 흔히 다익스트라 최단 경로 알고리즘에서 '비용'과 '노드 번호'라는 서로 다른 성질의 데이터를 튜플로 묶어서 관리

```py
a = (1, 2, 3, 4)
```

## 사전 자료형

```py
data = dict()
data['a'] = 'alpha'
data['g'] = 'gamma'
data['o'] = 'omega'

if 'a' in data:
  print(data['a'])

key_list = data.keys()
value_list = data.values()
print(key_list)
print(value_list)
```

```sh
alpha
dict_keys(['a', 'g', 'o'])
dict_values(['alpha', 'gamma', 'omega'])
```

## 집합 자료형

```py
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7}

print(a | b)
print(a & b)
print(a - b)

a.add(6)
print(a)

a.update(b)
print(a)

a.remove(3)
print(a)
```

```sh
{1, 2, 3, 4, 5, 6, 7}
{3, 4, 5}
{1, 2}
{1, 2, 3, 4, 5, 6}
{1, 2, 3, 4, 5, 6, 7}
{1, 2, 4, 5, 6, 7}
```

# 조건문

```py
socre = 85

if score >= 90:
  print("A")
elif score >= 80:
  print("B")
elif score >= 70:
  print("C")
else
  print("F")
```

## 논리 연산자

- `X and Y`
- `X or Y`
- `not X`
- `X in Y`
- `X not in Y`

## `pass`

- `pass` 키워드를 활용하면 조건문이 참이어도 아무 처리를 하지 않게 할 수 있음

# 반복문

## for문

- `range()` 키워드를 자주 사용
  - `range(시작값, 끝값+1)` 의 형태
  - 인자를 하나만 넣으면 시작 값은 자동으로 0이 됨
