## software entropy

- 정의: 코드가 지저분해지는 것
- 발생 이유
  - 개발자들이 서로의 코드를 이해하지 못해서
  - 서로 코딩 스타일이 달라서
  - 기술 스택과 제품 요구사항을 개선하다 보니
  - 버그 수정과 성능 최적화를 하다 보니
- 개선 방안
  - 버그 탐지 도구 사용
  - 코드 리뷰를 통한 지식 전파 및 코드 일관성 유지
  - 지속적인 리팩토링

## technical debt

- software entropy를 가중시키는 요인
- 정의: 기존 코드의 단점을 수정하면서 나중으로 미뤄둔 작업
- 기술 부채에도 원금과 이자가 존재
  - 원금: 수정해야 할 원래의 단점
  - 이자: 본질적인 단점을 수정하지 않고 코드를 개선할 때 발생하는 비용
    - 차선책을 택하면서 점차 복잡도가 올라가는 것을 의미
- 차선책이 계속 복제되고 자리를 잡게 되면 이자도 더욱 늘어남
  - 코드의 복잡도가 더 심해지고 결함이 생겨남
- 레거시 코드에는 수많은 기술 부채가 산재
- ⭐ 내가 동의하지 않는 기술적 의사결정, 마음에 들지 않는 코드는 기술 부채가 아님!
  - 기술 부채의 정의는 '이자를 지불해야 하는' 것이거나, 심각한 문제를 유발할 수 있는 위험 요소여야 함
  - 그러니 '기술 부채'라는 용어를 남용하지 말 것!

|       분류       |    신중하지 못한 선택     |              신중한 선택               |
| :--------------: | :-----------------------: | :------------------------------------: |
|   의도한 선택    |  "설계할 시간이 없어요."  | "일단 출시 후 결과를 보고 대처합시다." |
| 의도치 않은 선택 | "계층화가 도대체 뭔가요?" |     "뭘 실수했는지 이젠 알겠네요."     |

- 마틴 파울러는 2차원 매트릭스로 나눠 설명
  - 의도적으로 만들어졌는가, 신중한 선택이었는가에 따라
  - 신중 O / 의도 O
    - 보편적인 기술 부채 유형
    - 코드의 단점과 출시 속도 사이에서 고민하다 결정한 실용적인 트레이드오프
  - 신중 X / 의도 O
    - 주로 팀이 출시일 압박을 받는 상황에서 만들어짐
    - **_"일단 이렇게 합시다"_**
  - 신중 X / 의도 X
    - **_unknown unknowns_**
    - 말그대로 몰라서 발생한 것
    - 개선 방안
      - 사전 구현 계획을 작성해서 피드백 받기
      - 코드 리뷰 수행
      - 꾸준한 학습
  - 신중 O / 의도 X
    - 도메인에 대해 배우거나, 소프트웨어 아키텍트가 성장하는 과정에서 자연스럽게 발생
    - 문제 상황에 대해 뒤늦게 깨닫는 경우가 있기 때문
    - 팀은 이런 부채가 발생할 것을 예측할 수 없음
    - 누군가 제대로 일을 하지 않아서 생기는 것은 아님
    - 프로젝트 회고 절차를 활용해서 의도치 않은 부채를 찾아내고 해결 방안에 대해 논의할 것

⇒ 기술 부채는 프로젝트가 지저분해질 정도로 오래 살아남았다는 뜻이기도 하니, 성공의 표시일 수도 있다!

## refactor the legacy code

### Working Effectively with Legacy Code

마이클 C. 페더스의 저서에 나온 기존 코드 리팩토링 방법

1. 변경 지점 확인
2. 테스트 지점 확인
3. 의존성 나누기
4. 테스트 작성
5. 리팩토링

- 처음 4개 과정은 밭에 씨를 뿌리는 과정 / 5번째 과정은 주변을 정리하고 울타리를 치는 과정
- 변경 지점 확인
  - 코드를 읽고 이것저것 실험해보고 질문을 던져보며 변경해야 할 코드 찾아내기
  - 씨를 뿌려야 할 지점
- 테스트 지점 확인
  - 수정하고자 하는 코드의 진입점에 테스트가 직접 호출하고 값을 넣어보게 만들어야 함
  - 테스트 지점은 현재 코드가 어떻게 동작하는지 보여줌
- 의존성 나누기
  - 테스트 지점을 찾기 위해 의존성을 나눠야 할 수도 있음
  - 의존성은 라이브러리나 서비스 의존성이 아닌, 우리의 코드를 테스트하기 위해 필요한 객체나 메소드를 뜻함
  - 의존성을 나눈다는 건 테스트가 용이하도록 코드 구조를 바꾼다는 것!
  - 테스트 코드를 결합해서 원하는 입력값을 대입할 수 있도록 코드 수정 필요
  - 다만 코드의 동작이 바뀌어서는 안됨!
  - 크고 복잡한 메소드는 더 작은 크기의 메소드로 나눠서 각기 분리된 기능이 독립적으로 테스트되도록
  - interface를 활용해서 복잡한 객체보다는 단순한 구현체로 대체
  - 시간의 흐름 등 필요한 실행 환경을 시뮬레이션하도록 명시적 제어 지점 주입
  - 테스트를 쉽게 한다고 접근제어자를 변경하면 안됨! → 캡슐화에 문제가 생김
