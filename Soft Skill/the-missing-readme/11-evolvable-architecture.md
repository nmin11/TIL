## complexity

존 오스터하우트 『소프트웨어 설계 철학』

> 복잡도란 시스템을 이해하고 수정하는 것을 어렵게 만드는 시스템의 구조와 관련된 모든 것

- 복잡한 시스템 = 높은 의존성 + 높은 모호성 + 높은 관성

dependency (의존성)

- 의존성이 높으면 다른 API 및 동작에 의존하게 됨
- 강결합 및 변경의 영향도가 확대되면 코드 변경이 어려워짐
- 그러므로 API를 주의 깊게 설계하고 추상화를 활용해야 함

obscurity (모호성)

- 변경 부작용 예측이 힘들어짐
- 코드 이해에 오랜 시간이 걸리고 부주의로 인한 문제 발생 확률이 높아짐
- 모호성의 증상
  - 거의 모든 것을 담당하는 god object
  - 부작용을 유발하는 전역 상태
  - 코드 이해를 어렵게 하는 과도한 간접성
- 그러므로 표준 패턴을 적용한 API를 설계해야 함

inertia (관성)

- 소프트웨어를 계속 사용하려는 성향
- 간단히 테스트해보고 없앨 수 있으면 낮은 관성
- 비즈니스에 요긴한 여러 애플리케이션에 영향을 주고 있어서 없앨 수 없으면 높은 관성
- 관성이 높고 변경이 잦은 시스템은 반드시 간소화할 것

<br>

- 복잡도는 항상 제거할 수 있는 것이 아님
- 적어도 복잡하게 놔둘 부분은 선택할 수 있음
- 하위 호환성은 사용하기엔 쉽지만 구현이 어렵고, 추상화는 의존성을 줄이지만 모호성이 증가함

## design principles

- KISS(Keep It Simple, Stupid)
  - 최대한 간단하게 구현하자!
  - 복잡도는 나중에 추가할 수 있도록

### YAGNI

You ain't gonna need it

- 당장 필요하지 않은 것은 구현하지 말라
- MVP를 위해 필요치 않은 기능, 불필요하게 유연한 추상화, 너무 이른 최적화는 피하자

### principle of least astonishment

- 사용자를 놀라게 하지 말라
- 구현하는 기능은 사용자가 처음 예상한 방식대로 작동해야 함
- 학습 곡선이 높거나 이상한 동작은 사용자를 불안하게 만듦
- 개발자도 놀라게 하지 말라
  - 예상과 다른 동작을 하는 코드는 이해하기 어렵고 복잡도를 증가시킴
  - 따라서 구체적인 코드를 작성하고 암묵적 요소를 제거하고 표준 라이브러리 및 패턴을 사용하자

implicit knowledge

- 명확하게 표현되어 있지 않으면서 API에도 포함되어 있지 않은 요소들
- 버그를 유발하고 학습 곡선을 높임
- 보편적인 것들은 호출 순서 요구사항과 인수 상세 내용

호출 순서 요구사항

- 메소드 호출 순서가 가장 빈번하게 거두됨
- 호출 순서화에 대한 문서화도 좋지만 애초에 호출 순서에 의존하지 않게 만드는게 나음
- 메소드 안에서 서브 메소드를 호출하도록 만들자
- builder pattern을 사용해서 메소드 호출을 하나로 결합하자

hidden argument requirement

- 메소드 시그니처가 실제 필요한 것보다 더 넓은 범위의 입력값을 내포할 때 발생
- 예를 들어 1부터 10까지의 값만 처리하는데 `int` 타입으로 선언한 경우
- 구체적인 타입을 사용하자!
- JSON을 쓸 때는 JSON 스키마 활용을 고려하자

### encapsulation by domain

- 소프트웨어는 비즈니스 도메인을 기준으로 그룹화해서 도메인 지식을 캡슐화해야 함
- 도메인 캡슐화 → 높은 응집도 + 낮은 결합도
  - 변경사항의 영향 반경 축소
- 서로 관련 있는 메소드, 변수, 클래스 등을 가까운 모듈이나 패키지로 모으면 응집도가 높다고 함
- 도메인 경계를 정의하고 도메인 관련 지식을 캡슐화하는 것은 과학만큼이나 예술적
- 완전한 DDD는 가장 복잡한 상황에서 필요하지만 그래도 공부해두면 더 나은 설계에 도움이 됨

## revolvable API

### keep small API

- API를 작게 만들면 이해하고 개선하기 쉬움
- API에도 YAGNI 철학을 적용하자
- 필드가 많은 API 메소드는 반드시 적절한 기본값을 가져야 함
  - 필요한 필드에만 집중할 수 있도록
  - 이러면 큰 API도 작게 느껴짐

### service API

- 버전, 호환성 규약을 명시한 요청, 응답 스키마 정의
- 오픈 API: REST 서비스에서 활용
- IDL(Interface Definition Language): Protocol Buffer, Thrift 등이 활용
  - 테스트 도구는 IDL을 통해 stub 및 mock 데이터를 생성할 수 있음

### compatibility

- 상위 호환성과 하위 호환성 두 가지 버전으로 나눌 수 있음
  - 상위 호환성을 가지려면 이전 버전의 서비스가 새 버전 API 요청을 수신할 수 있어야 함
  - 하위 호환성을 가지려면 이전 버전으로 개발된 코드로도 새 버전의 API를 실행할 수 있어야 함
- 서버는 기존 버전의 클라이언트를 지원하는 동안에는 양쪽 모두를 지원해야 함
- deprecated 여부를 확실하게 확인하고 retire

### versioning

- 여러 버전의 호환성을 처리하기 위한 방법
- 클라이언트는 유연하게 버전을 선택할 수 있고, 고객이 어떤 버전의 클라이언트를 사용하는지 파악하기도 쉬움
- 주로 API G/W나 service mesh를 통해 관리
- 비용이 꽤나 수반됨
  - 기존의 주 버전들을 항상 유지보수해야 함
  - 버그 수정도 기존 버전들에 확대 적용해야 함
  - 어떤 버전이 어떤 기능을 지원하는지 추적해야 함
  - 버전 제어 도구가 없으면 직접 관리해야 함
- API 문서도 버전 제어 필요
- API 버저닝은 외부 클라이언트를 통제할 수 없는 상황에서 빛을 가장 크게 발함
