## why need a test

- 의도치 않게 코드의 동작이 바뀌는 것 방지
- 컴포넌트를 어떻게 사용하는지에 대한 문서 역할
- 실험 공간
- 소프트웨어가 원하는 대로 동작하는지 검증

separation of concern

- 개발자는 테스트를 작성하면서 프로그램의 인터페이스와 실체 구현에 대해 고민해볼 수 있음
- 개발자도 자신의 코드를 테스트 코드 안에서 처음 사용해보게 됨
- 테스트를 통해 미숙한 인터페이스를 발견해내고, 강결합을 줄일 수 있음

TDD

- 코드 작성 전에 테스트를 먼저 작성하는 방법
- 개발자가 코드의 동작, 인터페이스 설계, 다른 코드와의 통합 등을 먼저 고민해보게 함

## test types

unit test

- 메소드나 동작 하나를 검증
- 빠르고 작으며 집중적
- 대체로 개발자의 랩탑에서 실행되기 때문에 빨라야 함
- 실패했을 때 어디가 문제인지 쉽게 이해할 수 있음

integration test

- 여러 컴포넌트가 함께 동작하는지 검증
- 여러 객체의 인스턴스 생성 후 서로 의존하며 동작하는 테스트인 경우
- 단위 테스트에 비해 더 느리지만 더 정교한 셋업 필요
- 개별적으로는 식별할 수 없는 문제를 찾아낼 수 있음

system test

- 시스템 전체 검증 (end-to-end)
- 프로덕션 환경에서 실제 사용자의 전반적인 동작들을 시뮬레이션
- 지속적 종합 모니터링 프로덕션 테스트로 대체 보완되기도 함

performance test

- 시스템 성능 측정
- load test
  - 시스템에 다양한 수준의 부하를 걸고 성능 측정
- stress test
  - 장애가 발생하는 수준까지 시스템 부하를 올림
  - 시스템이 어느 정도의 부하를 견디는지, 부하 수준을 넘어서면 어떤 일이 벌어지는지
- 용량 계획과 SLO 설정에 도움이 됨

acceptance test

- 사용자 혹은 사용자의 대리인이 제공된 소프트웨어가 인수 조건을 만족하는지 검증
- 주로 엔터프라이즈 소프트웨어를 대상으로 함
- ISO는 비즈니스 요구사항을 명시적으로 검증하는 인수 테스트를 ISO 보안 표준 일부로서 요구함

## test tools

### mocking library

- 특히 객체지향 코드의 단위 테스트에 주로 사용됨
- 실제 시스템이 제공하는 인터페이스를 모방하는 stub 객체로 외부 의존성 대체
- 모의 객체는 하드코딩된 응답을 반환해서 테스트에 필요한 기능을 구현하도록 함
- 외부 의존성을 줄이고 모의 객체를 잘 활용하는 것이 중요
- 모의 객체를 남용하면 테스트가 불안정해지고 이해하기 어려워짐
  - 기본적인 모의 객체만 사용하고, 공용 모의 클래스는 만들지 말 것
  - 모의 객체에 과하게 의존하는 것 역시 코드가 강결합되어 있다는 뜻

### test framework

- 테스트 코드를 작성하고 실행하는 도구
- 역할
  - 테스트 셋업 및 해제
  - 테스트 실행 및 조율
  - 테스트 결과 보고서 생성
  - 추가 검증 메소드 등의 도구 제공
  - 코드 커버리지 도구와의 통합

### code quality tools

- 고품질 코드를 작성하는 데 도움이 되는 도구
- 코드 품질 규칙을 강제하는 도구를 linter 라고 부름
- static code analyzer
  - 일반적인 실수를 찾아줌
  - 파이썬, 자바스크립트처럼 컴파일러가 없는 동적 언어를 사용할 때 특히 중요
  - 거짓양성 보고의 가능성도 있으므로 신중하게 판단해야 함
- code style checker
  - 모든 소스 코드를 동일한 방식으로 작성할 수 있게 해줌
  - 한 줄당 최대 문자 수나 case 표기 방식, 들여쓰기 등
- code complexity tool
  - 순환 복잡도 및 분기 횟수 확인
  - 너무 복잡한 로직을 작성하지 않도록 해줌
- code coverage tool
  - 테스트가 몇 줄의 코드를 실행했는지 측정
  - 65% ~ 85% 정도의 커버리지를 유지하는 것이 좋음
  - 테스트 품질을 커버리지만으로 측정하는 것은 좋은 방법이 아님!

## deterministic test

- 결정적 코드: 입력이 같으면 출력도 항상 같은 코드
- 비결정적 코드: 입력이 같아도 출력이 다를 수 있음
- 비결정적 코드는 테스트의 가치를 떨어뜨림
- 따라서 여러 방식으로 코드의 비결정성을 제거해야 함

### seed value

- 난수생성기는 기본적으로 시스템 클럭을 사용하므로 테스트를 여러 번 실행하면 결과가 달라질 수 있음
- 그러므로 반드시 원하는 난수가 나오도록 시드값을 사용할 것

### remote system

- 원격 시스템 호출은 네트워크 연결이 필요한데 이는 대체로 안정적이지 않음
- 네트워크 타임아웃이 발생하면 비결정성 추가
- 단위 테스트에서는 이식성(portability) 유지를 위해 원격 시스템 호출을 하지 말 것
- 원격 시스템은 통합 테스트에서만 사용하도록 하자

### clock

- 특정 간격의 시간에 의존하는 코드는 비결정성을 유발할 수 있음
- `now` `sleep` 같은 정적 시스템 클럭 메소드를 사용한다면 코드가 시간에 의존적이라는 뜻
- 이런 경우 테스트 시점에 시간을 제어할 수 있도록 클럭을 주입하는 편이 좋음

### network socket & file handle

- 한 프로세스에서 여러 테스트를 실행할 때 리소스 누수가 즉시 정리되지 않을 수 있음
- 리소스 누수 또한 비결정성을 유발
- 리소스 사용 범위를 좁힐 수 있는 표준 리소스 관리 기법을 사용하자
- 여러 테스트가 공유하는 리소스는 셋업 및 해체 메소드를 이용해서 닫아주자

### 0 port

- 특정 네트워크 포트를 바인딩하는 것도 비결정성을 유발
- 테스트가 사용할 포트가 어떤 머신에서는 이미 사용 중일 수 있기 때문에
- 네트워크 소켓에 0번 포트를 바인딩하면 운영체제는 사용 가능한 포트를 자동으로 열어줌

### file & database path

- 정적으로 선언한 위치 대신 동적으로 생성된 위치를 사용하자
- 대부분의 언어는 임시 디렉토리를 안전하게 생성하는 유틸리티 제공
- 파일이나 데이터베이스 경로에 UUID를 덧붙이는 것도 좋은 방법

### test state

- 메모리나 디스크, 데이터베이스에 기록하는 테스트는 불안정
- 통합 테스트의 경우 여러 개발자가 동일한 datastore에서 테스트하도록 할 것
- 테스트 성공 여부와 상관 없이 상태는 반드시 리셋할 것
- 셋업 및 해제 메소드를 통해 테스트할때마다 테스트 상태를 리셋
