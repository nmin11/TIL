## 4 steps of software delivery

Build ⇒ Release ⇒ Deploy ⇒ Rollout

- 사실 딜리버리를 위해 정해진 업계 표준은 없지만 본 책에서는 이 4단계를 기본 구조로 잡고 설명
- package
  - 소프트웨어는 반드시 패키지로 **build** 되어야 함
  - 패키지는 반드시 불변이며 버전이 지정되어야 함
  - 패키지는 생성 후 반드시 **release** 되어야 함
- 릴리스 과정에서 릴리스 노트 및 변경 로그가 업데이트되어야 함
- 릴리스 후 패키지를 중앙식 리포지토리로 발행
- 발행된 릴리스는 테스트 환경이나 프로덕션 환경으로 **deploy** 되어야 함
- 배포된 소프트웨어는 install 되었을 뿐 상용화된 상태가 아님
- 상용화를 위해 **rollout**
- 롤아웃 후 사용자 피드백 수집, 버그 발견, 새로운 제품 요구사항 반영
  - 이를 바탕으로 다시 delivery 단계들 시작
- 각 딜리버리 단계들을 위한 일련의 권장 기법이 존재

## source control branching strategy

- release package: 버전 제어 시스템의 코드로부터 빌드
- trunk: 변경 이력을 가진 주 버전의 코드 베이스
- branch: 코드 수정을 위해 트렁크로부터 가지를 쳐서 나온 것
  - 개발자들이 브랜치에서 병렬적으로 작업하고 준비가 되면 트렁크로 변경사항 merge
- 다양한 브랜칭 전략마다 브랜치 유지 기간이나 릴리스 버전 등에 대한 나름의 정의가 있음

trunk-based

- 모든 개발자가 트렁크로부터 브랜치를 생성
- 브랜치는 작은 기능, 버그 수정, 업데이트 등을 위해 사용됨
- 개발자가 브랜치를 공유하지 않으며, 시간 단위가 아닌 일 단위의 신속한 merge가 많은 환경에 적합
- 자주 merge하는 방식을 CI(Continuous Integration)라고도 함
- 각 개발자들이 최신 버전의 코드로부터 벗어나 있는 시간이 줄어드니 위험도 줄일 수 있음
- 반면에 트렁크에 버그가 존재하면 모든 개발자의 개발 속도가 느려짐
  - 그래서 merge 이전에 자동화된 테스트 기능 필요
- 보통 트렁크는 항상 릴리스 가능한 상태를 유지하고, 릴리스도 자주 일어남

feature branch-based

- 기능 브랜치가 상당히 오래 유지되면서 여러 개발자가 함께 작업
- 각 기능 브랜치는 제품의 특정 기능과 관련됨
- 기능 브랜치가 outdated 되지 않도록 rebase를 수행해야 함
  - 기능 브랜치의 안정성도 rebase 수행 시점에 관리해야 함
- 릴리스 준비가 되면 기능 브랜치를 릴리스 브랜치로 가져옴
- 트렁크의 코드가 불안정해서 트렁크를 안정화시키면서 기능도 개발해야 할 때 사용하는 방법

⇒ service-oriented system 이라면 일반적으로 trunk-based 개발 전략을 채택!

**Gitflow**

- 2010년 빈센트 드리센이 소개한 가장 보편적인 기능 브랜치 전략!
- `develop` `hotfix` `release` 브랜치 사용
- develop: 기능 브랜치를 merge하고 rebase하는 주 브랜치
- release
  - 릴리스 준비가 되었을 때 develop 브랜치로부터 가지 치기
  - 릴리스 안정화 도중 개발 업무는 기능 브랜치에서 진행
  - 릴리스 안정화 이후 트렁크로 merge
- hotfix
  - 심각한 버그로 인해 트렁크가 불안정해졌을 때 통상적인 릴리스 절차 없이 즉시 수정
  - 버그 수정 후 hotfix 브랜치를 트렁크와 develop 브랜치 양쪽에 merge

## build

- 의존성 해석 및 linking, 린터 실행, 컴파일, 테스트, 소프트웨어 패키징 등 여러 단계로 구성
- 대부분의 빌드 단계는 개발 과정에서도 사용
- 여러 플랫폼 및 환경을 위해 여러 개의 패키지를 생성할 수도 있음
  - 대부분 OS, CPU 아키텍처, 언어 런타임에 따라 다양한 패키지 생성
- 패키지의 내용물과 구조
  - 바이너리, 소스 코드, 의존성, 설정, 릴리스 노트, 문서, 미디어, 라이선스, 체크섬, 가상 머신 이미지 등
- 애플리케이션 패키지
  - 보통 zip, tar, dmg, exe 등의 파일로 생성
- 컨테이너 및 머신 패키지
  - 소프트웨어를 실행하는 환경 자체를 빌드할 수 있음

### package version

- 패키지에는 버전을 명시해야 하고 고유한 식별자를 할당해야 함
- 어떤 버저닝 전략을 채택할지 애매하다면 semantic versioning!

### resource packaging

- 소프트웨어는 설정, 스키마, 이미지, 언어 팩 등을 모두 포함
- 각각의 리소스는 서로 다른 릴리스, 빌드 타임, 테스트 및 검증 방식이 필요
- 각 리소스를 별도로 패키징하면 전체 패키지를 재빌드하지 않고도 필요한 부분만 수정할 수 있음
  - 독립적인 rollout 및 rollback!
- meta-package
  - 고객에게 제공되는 완전한 애플리케이션으로서의 최종 패키지
  - 패키지들의 패키지
  - 각 패키지는 별도로 업그레이드가 가능
