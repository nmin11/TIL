2021 / 09 / 07

## Token-based Authentication을 사용하는 이유

Session 기반 인증은 서버 혹은 DB에 유저 정보를 담는 인증 방식이었다.  
서버에서는 유저가 민감하거나 제한된 정보를 요청할 때마다 갖고 있는 세션 값과 일치하는 세션 아이디를 갖고 있는지 확인한다.  
매 요청마다 이러한 작업을 진행하는 것이 불편하기 때문에 **토큰 기반 인증** 방식이 등장했다.

</br>

## 클라이언트에서 인증 정보를 보관

'토큰' 하면 동전을 떠올리게 될 것이다.  
현실에서는 주로 돈과 교환되는 시설 이용권에서 비롯된 용어라고 보면 된다.

</br>

클라이언트에서 인증 정보를 보관하기 위해 토큰 기반 인증 방식이 고안되었다.  
하지만 클라이언트는 XSS, CSRF 공격에 대비하기 위해서 민감한 정보를 담으면 안되는데, 어떻게 이러한 방식이 유효할 수 있었을까?  
그것은 바로, 토큰이 유저 정보를 암호화한 상태로 담기 때문이다.

</br>

## JWT (JSON Web Token) 종류

1. Access Token
2. Refresh Token

Access Token은 보호된 정보들에 접근할 수 있는 권한 부여 용도로 사용된다.  
클라이언트가 처음 인증을 받을 때 JWT의 두 가지 토큰을 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 Access Token이다.

</br>

그리고 Access Token은 탈취 위험을 보호하기 위해서 짧은 유효기간을 가지게 하고, 유효기간이 만료되면 Refresh Token을 사용하여 새로운 Access Token을 발급한다.  
이러한 작업을 위해 재로그인할 필요는 없다.

</br>

하지만 Refresh Token마저 탈취될 위험이 없는 것이 아니다.  
그렇기 때문에 유저의 편의보다 정보를 지키는 것을 더 중요시하는 웹 사이트들은 Refresh Token을 사용하지 않는다.  
세상에 완벽한 보안은 없기 때문에 Cookie, Session, JWT, OAuth 등 다양한 방법들의 장단점을 참고하여, 필요에 맞게 사용하는 것이 중요하다.

</br>

## JWT 구조

</br>

![JWT 구조](https://user-images.githubusercontent.com/75058239/132324896-0c26de7c-bec1-43d6-ade6-3a53958d0429.png)

</br>

JWT는 위와 같이 `.` 으로 나누어진 3부분이 존재한다.

</br>

### 1. Header

Header는 이것이 어떤 종류의 토큰인지, 어떤 Algorithm으로 sign(암호화) 할지 적혀 있다.  
JWT(JSON Web Token)을 사용한다면 JSON 형태로 표기될 것이다.  
JSON 객체를 base64 방식으로 인코딩하면 JWT의 첫 부분이 완성된다.

</br>

### 2. Payload

Payload에는 정보가 담겨 있다.  
어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 유저 이름 등 필요한 데이터를 담아서 암호화시킬 수 있다.  
암호화가 되지만 민감한 정보는 되도록 담지 않는 것이 좋다.  
Header와 마찬가지로, JSON 객체를 base64로 인코딩하면 JWT의 두번째 블록이 완성된다.

</br>

### 3. Signature

base64로 인코딩하여 앞의 두 부분이 완성되었다면, 원하는 비밀 키(Salt)를 사용하여 암호화한다.  
base64로 인코딩한 값은 손쉽게 디코딩되지만, 서버에서 사용하고 있는 비밀키를 보유하지 않았다면 해독하기가 까다로워질 것이다.  
예를 들어서 만약 HMAC SHA256 Algorithm을 사용한다면 Signature는 다음과 같은 방식으로 생성된다.

```java
HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret);
```

</br>

## JWT 사용 예시

JWT는 **권한 부여**에 굉장히 유용하다.  
만약 A라는 앱이 Gmail과 연동되어 이메일을 읽어와야 한다고 했을 때, JWT를 통해 다음과 같이 권한 부여를 해줄 수 있다.

1. Gmail 인증 서버에 로그인 정보를 제공
2. 성공적으로 인증될 경우 JWT 발급
3. A 앱은 JWT를 사용해서 해당 유저의 Gmail을 읽거나 사용할 수 있게 됨

</br>

## 토큰 기반 인증 절차

1. 클라이언트가 서버에 아이디/비밀번호를 담아서 로그인 요청 전송
2. 서버는 아이디/비밀번호가 일치하는지 확인하고 클라이언트에게 보낼 암호화된 토큰 생성
   - Access/Refresh Token 모두 생성
   - 토큰에 담길 Payload는 유저를 식별할 정보, 권한이 부여된 카테고리 등이 될 수 있음
   - 두 종류의 토큰이 같은 정보를 담을 필요는 없음
3. 토큰을 클라이언트에게 보내주면 클라이언트는 토큰을 저장
   - 저장 위치는 local storage, cookie, react의 state 등 다양하게 저장될 수 있음
4. 이후 요청 시, 클라이언트는 HTTP 헤더(Authorization 헤더)에 토큰을 담아서 보냄
5. 서버는 토큰을 해독하여 인증 작업을 거치고나서 요청을 처리하고, 응답을 전송

</br>

![토큰 기반 인증 절차](https://user-images.githubusercontent.com/75058239/132324876-8c5ff229-d66a-4702-9060-76b153763970.jpg)

</br>

## 토큰 기반 인증의 장점

1. Statelessness & Scalability (무상태성 & 확장성)
   - 서버는 클라이언트의 정보를 저장할 필요가 없음 (토큰 해독이 되는지만 판단)
   - 클라이언트는 새로운 요청 때마다 토큰을 헤더에 포함시키면 됨
     - 서버가 여러 개라면 하나의 토큰으로 여러 서버에서 인증 가능
2. 안전성
   - 암호화한 토큰을 사용하고, 암호화 키를 노출할 필요가 없기 때문에 안전함
3. 어디서나 생성 가능
   - 서버가 꼭 토큰을 만들 필요는 없음
   - 토큰 생성용 서버를 만들거나, 다른 회사에 토큰 작업을 맡기는 등 다양한 활용 가능
4. 권한 부여에 용이
   - 토큰의 Payload를 통해서 어떤 정보에 권한 부여를 할지 정할 수 있음

</br>

현업에서 토큰을 많이 사용한다.  
세션에 대한 개념도 많이 쓰이니 세션도 반드시 알아두어야 한다.
