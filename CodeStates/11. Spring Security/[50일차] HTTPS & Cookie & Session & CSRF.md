2021 / 09 / 06

# HTTPS

HyperText Transfer Protocol Secure Socket layer 의 약자이며, HTTP over SSL(TLS), HTTP over Secure라고 부르기도 한다.  
HTTPS는 HTTP 요청을 SSL 혹은 TLS라는 Algorithm을 활용해서 HTTP 통신을 하는 과정에서 내용을 암호화하여 데이터를 전송하는 방법이다.  
HTTPS를 이용하면 데이터 제공자의 신원을 보장받을 수 있으며, 이렇게 신원을 확인하고 보장받는 것이 중요한 이유는 다음과 같다.

- 클라이언트는 데이터 제공자의 데이터를 어떻게든 사용하게 되어 있다.
- 그렇기에 요청 및 응답을 중간에서 가로채는 **중간자 공격** 에 취약해진다.
- 데이터는 중간에 다른 도메인을 거쳐서 전달되기 때문에 **어떤 도메인에서 제공되었는지** 에 대한 추가 데이터를 응답 객체에 싣는다면, 클라이언트는 자신이 제공한 도메인과 전달받은 내용의 도메인을 비교하여 '중간자 공격'이 있었는지 판별할 수 있게 된다.
- 하지만 '중간자 공격'은 이러한 추가 데이터 또한 변조할 수 있으므로, 데이터를 암호화시키는 작업이 필요하다.

</br>

## 암호화

HTTPS 프로토콜의 특징 중 하나는 암호화된 데이터를 주고받기 때문에, 중간에 인터넷 요청이 탈취되어도 그 내용을 알아볼 수 없게 한다는 점이다.  
내용이 암호화되어 전송되기 때문에 정확한 key로 복호화하기 전까지는 어떤 내용인지 알 수 없다.

</br>

### Hashing

암호화하는 방법의 일종이다.  
Hashing은 특정 문자열에 '임의의 연선'을 적용하여 다른 문자열로 변환하는 작업이며, Algorithm을 최소화하기 위해 다음과 같은 사항들이 요구된다.

1. 모든 값에 대해 해시 값을 계산하는 시간이 오래 걸리지 않아야 함
2. 모든 값은 고유한 해시 값을 가짐
3. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 함

대표적인 해시 Algorithm으로는 SHA1이 있다.

</br>

### Salt

암호화해야 하는 값에 '별도의 값'을 추가하여 결과를 변형

1. 암호화만 할 경우, 해시된 결과는 늘 동일 → 해시된 값과 원래 값을 레인보우 테이블로 만들어서 decoding하는 경우가 생길 수 있음
2. 원본값에 임의로 약속된 '별도의 문자열'을 추가해서 해시를 진행하면 기존 해시 값과 전혀 다른 해시 값이 반환되어, Algorithm이 노출되어도 원본 값을 보호할 수 있음

Salt에는 몇 가지 유의사항이 있다.

1. Salt는 유저와 패스워드 별로 유일한 값을 가져야 함
2. 사용자 계정 생성 및 비밀번호 변경 때 마다 새로운 임의의 Salt를 사용해서 해싱해야 함
3. Salt는 절대 재사용하지 말아야 함
4. Salt는 DB의 유저 테이블에 같이 저장되어야 함

</br>

## 인증서

HTTPS의 또 다른 특징 중 하나는 브라우저가 응답과 함께 전달된 인증서 정보를 확인할 수 있다는 점이다.  
브라우저는 인증서에서 해당 인증서를 발급한 CA 정보를 확인하고, 인증된 CA가 발급한 인증서가 아니라면 화면에 경고창을 띄워 서버와 연결이 안전하지 않다는 내용을 보여준다.

</br>

![HTTPS 인증서](https://user-images.githubusercontent.com/75058239/132177014-93e364c7-9c2d-48a5-855b-badc92495b25.png)

</br>

이렇듯 브라우저는 인증서의 도메인과 데이터 제공자의 도메인을 비교할 수 있기 때문에 '중간자 공격'을 감지해서 보안 위협으로부터 사용자 및 사용자의 데이터를 보호할 수 있게 된다.

</br>
</br>

# Cookie

쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법 중 하나이다.  
이를 이용해서 서버는 원한다면 쿠키를 이용해서 클라이언트의 데이터를 가져올 수 있다.  
그러므로 쿠키를 이용한다는 것은 단순히 **서버에서 클라이언트로 쿠키를 전송하는 것** 뿐만이 아니라, **클라이언트에서 서버로 쿠키를 전송하는 것** 도 포함된다.

</br>

## 서버가 클라이언트에 데이터 저장

쿠키는 클라이언트에 저장될 수 있지만, 데이터를 저장한 이후 **아무 때나 데이터를 가져올 수는 없다.**  
데이터를 가져오기 위한 조건이 있으며, 이를 **쿠키 옵션** 이라고도 표현한다.

</br>

### 1. Domain

쿠키 옵션에서의 도메인에는 **서브 도메인 및 세부 경로를 포함하지 않는다.**  
만약 쿠키 옵션에 도메인 정보가 존재한다면 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키 전송이 가능하다.

</br>

### 2. Path

세부 경로를 쿠키 옵션으로 지정해줄 수 있다.  
설정된 Path를 전부 만족하는 경우, 요청 Path가 추가로 더 존재하더라도 쿠키 옵션에서 허용된다.

</br>

### 3. MaxAge or Expires

쿠키의 유효 기간을 정하는 옵션이다.  
MaxAge는 쿠키가 앞으로 몇 초 동안 유효한지 설정해주는 옵션이다.  
Expires는 Date를 지정해줄 수 있다.  
지정된 시간을 초과하면 쿠키는 자동으로 파괴된다.  
두 옵션이 모두 없는 경우에는 브라우저의 탭을 닫아야만 쿠키를 제거할 수 있다.

</br>

### 4. Secure

쿠키를 전송해야 할 때 사용하는 프로토콜에 따라 쿠키 전송 여부를 결정한다.  
해당 옵션이 true로 설정된 경우, HTTPS 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있다.

</br>

### 5. HttpOnly

JavaScript에서 브라우저의 쿠키에 접근할 수 있는지 여부를 결정한다.  
만약 해당 옵션이 true인 경우, JavaScript에서 쿠키 접근이 불가능하다.  
명시하지 않는 경우 기본값은 false이다.  
하지만 이 옵션이 false인 경우, XSS 공격에 취약해진다.

</br>

### 6. SameSite

Cross-Origin 요청을 받은 경우, 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부를 결정한다.  
사용 가능한 옵션은 다음과 같다.

- Lax : Cross-Origin 요청인 경우 GET 메소드에 대해서만 쿠키 전송
- Strict : Cross-Origin이 아닌 same-site인 경우에만 쿠키 전송
- None : 항상 쿠키 전송, 다만 Secure 옵션이 필요함

</br>

위에서 정리한 옵션들을 지정해주면, 서버에서 클라이언트로 쿠키를 처음 전송할 때 헤더에서 `Set-Cookie` 라는 프로퍼티에 쿠키를 담아서 전송한다.  
그 이후에는 헤더에 `Cookie` 라는 프로퍼티에 쿠키가 담아진다.

</br>

## 쿠키를 이용한 상태 유지

이러한 쿠키의 특성을 이용해서 서버는 클라이언트에 인증 정보를 담은 쿠키를 전송하고, 클라이언트는 전달 받은 쿠키를 요청과 함께 전송하여, Stateless한 인터넷 연결을 Stateful하게 유지할 수 있게 된다.  
**하지만 쿠키는 기본적으로 오래 지속되며, JavaScript를 이용해서 쿠키에 접근할 가능성도 있기에, 쿠키에 민감한 정보를 담는 것은 위험하다.**

</br>
</br>

# Session

쿠키는 데이터를 클라이언트에 저장한다면, Session은 데이터를 서버에 저장한다.  
어떻게든 세션을 저장해두어야 하기 때문에 메모리를 사용하며, 서버 성능 이슈를 발생시킬 수 있다.

</br>

## 로그인

로그인 시, 사용자가 정확한 아이디와 비밀번호를 입력했다면 서버는 인증(Authentication)에 성공했다고 판단할 것이다.  
그리고 다음 번에 인증을 필요로 하는 작업을 할 때에는 동일한 인증 작업을 굳이 다시 할 필요가 없을 것이다.  
다시 말해, **'인증에 성공했음'을 서버가 알고 있다면 매번 로그인할 필요가 없게 해야 한다는 것** 이다.  
이러한 작업을 위해 필요한 것은 다음과 같다.

- 서버는 사용자가 인증에 성공했음을 알고 있어야 한다.
- 클라이언트는 인증 성공을 증명할 수단을 갖고 있어야 한다.

여기에서 사용자가 인증에 성공한 상태를 **Session** 이라고 부르며, 주로 in-memory 또는 세션 스토어를 활용해서 저장해둔다.  
세션을 만들면 이를 구분하기 위해 **세션 아이디**도 만들어진다.  
보통 클라이언트에 세션 성공을 증명하기 위해 세션 아이디를 전달한다.  
쿠키를 통해 유효한 세션 아이디가 서버로 전달되고, 세션 스토어에 해당 세션이 존재한다면 서버는 해당 요청에 대해 접근 가능하다고 판단한다.

</br>

## 로그아웃

로그아웃은 다음 두 가지 작업을 통해 이루어진다.

- 서버의 세션 정보를 삭제한다.
- 클라이언트의 쿠키를 갱신한다.

서버가 클라이언트의 쿠키를 임의로 삭제할 수 없으므로, set-cookie를 통해 세션 아이디의 key 값을 무효한 값으로 갱신해주는 방식을 활용한다.

</br>
</br>

# CSRF (Cross Site Request Forgery)

CSRF는 다음의 특징을 갖고 있다.

- 다른 사이트(cross-site)에서 유저가 보내는 요청(request)을 조작(forgery)
- 해커가 직접 데이터에 접근할 수 없음

CSRF 공격에는 다음 조건들이 필요하다.

- 쿠키를 사용한 로그인
- 예측할 수 있는 요청이나 parameter를 가지고 있어야 함

CSRF를 막는 방법에는 다음과 같은 방법들이 있다.

- CSRF 토큰 사용하기
  - 서버 측에서 CSRF 공격을 막기 위한 문자열을 유저의 브라우저와 웹 앱에만 제공
- Same-site cookie 사용하기
