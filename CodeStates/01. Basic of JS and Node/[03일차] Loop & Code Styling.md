2021 / 06 / 17

# 반복문

for문

```javascript
let sum = 1;

for (let n = 2; n <= 4; n = n + 1) {
  sum = sum + n;
}

console.log(sum); //10
```

while문

```javascript
let sum = 1;
let n = 2;

while (n <= 4) {
  sum = sum + n;
  n = n + 1;
}

console.log(sum); //10
```

### ※ for문은 얼마나 반복할 것인지 확실히 알 때 사용

### ※ while문은 정확히 알 수는 없을 때 사용

</br>

## 반복문 문제풀이

오늘은 코드스테이츠 학습과정에서 처음으로 문제풀이에 무척 애를 먹었다. 이 경험을 결코 간과할 수 없기에 이렇게 기록을 남긴다.

### **isOdd**

#### 문제 : 수를 입력받아 홀수인지 여부를 반환

#### 확인사항

- 인자값은 정수
- while문을 사용해야 함
- for문은 사용 금지
- 나눗셈(/), 나머지(%) 연산자 사용 금지
- 0은 짝수로 간주

/* 이 문제는 사실 구글에 검색해서 거의 답과 비슷한 양식을 찾아내어 옮겨쓰다 싶이 문제를 풀었다. 깊이 반성하는 바이며 앞으로는 검색을 해도 너무 정답과 같은 풀이가 나온다면 과감히 넘어갈 수 있도록 해야겠다. */

1. num에 음수가 들어오면 계산하기 편하도록 양수로 바꿔준다.

```javascript
if (nuum < 0) {
  num = -num;
}
```

2. 인자값 num은 정수가 들어오게 되어있다. 1번의 조건문에 따라 양의 정수만 처리할 수 있게 되었으니, 0보다 작아질 수 없는 while 반복문을 만들어서 num에 -2씩 해주면서 0이나 1이 되도록 만들어준다. 0이 되면 짝수이므로 false 리턴, 1이 되면 홀수이므로 true를 리턴해준다.
</br>
(원래 풀이를 첨부해 두었지만 혹시라도 저와 같은 문제를 풀던 분이 해답을 보기보다는 어떤 식으로 풀어나가는 지를 알아가셨으면 좋겠다는 마음에 풀어가는 방식만 줄글로 써놓게 되었다.)

</br>
</br>

### **computePower**

#### 문제 : 밑(base)과 지수(exponent)를 입력받아 밑의 거듭제곱을 반환

#### 확인사항

- for문을 사용해야 함
- Meth.pow, 거듭제곱 연산자 사용 금지

/* 이 문제는 풀었지만 Reference와 내 풀이가 사뭇 달라서 나와는 또 다른 풀이 방법을 기록하기 위해서 이렇게 옮겨적게 되었다. */

```javascript
//내 풀이
function computePower(base, exponent) {
  if (exponent === 0) {
    return 1;
  }

  for (i = 1; i < exponent - 1; i++) {
    base = base * base;
  }
  return base;
}
```

내 풀이 방식은 exponent가 0이 들어왔을 때에 대한 대책은 다소 엉성하게 만들어둔 느낌이 있으며, 조건문 안에 i = 1; i < exponent -1; 부분이 뭔가 매끄럽게 느껴지지 않는다. 왠지 i는 0이었으면 좋겠고 exponent - 1 대신 그냥 exponent였으면 좋겠다는 느낌이 드는 코드다.

반면에 Reference의 풀이는 i = 0일 때 어떤 값이 들어와도 그냥 첫줄에 변수가 1인 result 값을 선언해서, result에다가 들어온 인자값을 곱해주면서 시작하기 때문에 결국 인자값 그대로가 되고 그 이후로는 자연스럽게 제곱 연산을 하듯이 흘러가는 것이다. exponent에 0이 들어왔을 때의 대처도 깔끔하다. 그냥 반복문의 조건이 성립되지 않기 때문에(i=0에서 시작, 0이 들어오면 0이 0보다 작을 수 없어서 조건 성립 X) 미리 준비해뒀던 1이 자연스럽게 반환값이 되는 것이다.

</br>
</br>

### **isPrime**

#### 문제 : 1 이상의 자연수를 입력받아 소수인지 여부를 반환

#### 확인사항

- for문을 사용해야 함
- Meth.pow, 거듭제곱 연산자 사용 금지

/* 처음 보자마자 쉽게 답이 나오지 않겠다는 생각이 들어서 지레 겁을 먹었다. 구글링을 적극적으로 하게 된 문제였으며 사실 지금도 썩 완전히 이해되지는 않았다. 구글링해서 찾아낸 코드와 Reference의 코드 둘 다 작동원리를 머릿 속에 잘 담아두어야겠다. */

</br>

구글링을 통해 찾아낸 코드에서는 2부터 num까지 num을 계속해서 반복문 속 i로 나누면서 나머지를 구하며, 나머지가 0이 되면 나눠지는 약수가 있다는 것이니 소수가 아니라고 false를 반환하는 코드였다.

</br>

그리고 Reference의 코드에서는 제곱근을 구해놓고 3에서부터 제곱근까지의 홀수들만 계산하는 방식이다. 3에서부터 2씩 더해가며 조건이 맞는지 여부를 확인하는데, 이는 짝수의 숫자들은 2로 나눠지기 때문에 홀수들만 소수 여부를 판단하기 위해 이렇게 푼 것이다. 쉽게 감이 오지 않는 풀이이지만 다음에 있을 HA를 위해서라도 제곱근을 사용한 풀이방식을 꼭 기억해두자.

</br>
</br>

### **listPrimes**

#### 문제 : 1 이상의 자연수를 입력받아 2부터 해당 수까지의 소수 반환

#### 확인사항

- 인자값은 number 타입의 정수 (num >= 2)
- '2-3-5-7'의 형식으로 반환해야 함
- 이중 반복문(double for loop)을 사용해야 함

/* 소수에 대한 계산과 더불어서 이중 반복문으로 출력까지 해야 한다. 역시나 전혀 감이 오지 않아서 구글링을 통해 해결을 봤다. 풀이방식을 꼭 명심해두도록 하자. */

</br>

구글링을 통해 찾아낸 코드에서는 인자값은 2 이상만 들어올 수 있으므로 '2'를 미리 문자열로 저장한다. 3부터 주어진 num까지의 반복문을 작성하고 그 안에 반복문을 하나 더 생성해서 i보다 1 작은 값으로 계속해서 나누면서 나머지 값이 0이 나오는지 확인한다. 나머지 값이 0이면 안쪽의 반복문을 통과하고 0이 아니면 문자열을 더해준다.

</br>

그리고 Reference의 풀이는 이전 문제에서 Math.sqrt()를 이용해서 제곱근으로 소수를 구했던 방식과 유사하다. 제곱근을 구하는 이중 반복문을 이용해서 소수인지 여부에 따라 문자열에 더해준다

</br>

이번 문제는 사실 풀이를 봐도 헷갈린다. 기억해뒀다가 한번 더 풀어보는 시간을 꼭 갖도록 하자.

</br>

**+ 코드스테이츠에서 제공해준 조금 더 직관적인 풀이가 있어서 추가하게 되었다.**

```javascript
function isPrime(num) {
  let isNumPrime = true;
  // 1부터 num까지 num(자기 자신)으로 나누어 떨어지는 경우 (나머지가 0인 경우)
  // num은 소수입니다.
  for (let i = 2; i < num; i += 1) {
    if (num % i === 0) {
      isNumPrime = false;
    }
  }
  // 하지만, 나누는 도중 나누어 떨어지는 수가 발견이 되면, num은 소수가 아닙니다.
  return isNumPrime;
  // 그 결과값을 리턴합니다.
}

function listPrimes(num) {
  let result = "2";

  for (let i = 3; i <= num; i += 1) {
    // 2부터 num까지 반복하여
    if (isPrime(i)) {
      // 소수(isPrime)라면 아래 조건문을 작동합니다.
      result = result + "-" + i; // 이어붙입니다.
    }
  }

  return result;
}
```

이전 문제에서 인자값이 소수인지를 판별하는 함수를 그대로 for문 안에서 조건문으로 활용해서 함수이면 빈 문자열에 차례대로 Concatenation해나가는 방식이다. 이것을 문제의 조건인 2중 for문으로 바꾸기 위해서 위쪽에 정리해둔 '구글링을 통해 찾아낸 코드'와 'Reference'의 방식으로 묶어주면 되는 것이다.

**+ Reference의 코드에서 let sqrt=parseInt(제곱근)로 선언했는데, parseInt는 왜 썼는가?**
</br>
A. 명시적으로 표기하기 위해 사용되었다. 제곱근을 쓰면 소숫점이 붙은 숫자들이 나오는 경우도 있다. 하지만 애초에 인자값은 정수라고 표기되어 있어서 굳이 소숫점이 붙을 숫자까지를 반복 조건으로 명시할 필요가 없고, int 타입으로 바꿔서 비교해도 충분하다. for문의 반복 조건을 정수까지로 잡아주는 것이 더 직관적이기 때문에 parseInt를 사용했다.

</br>
</br>

### **makeMarginalString**

#### 문제 : 문자열을 입력받아 해당 문자열을 한 글자씩 다시 작성한다. 이 때, 한 글자를 추가할 때마다 부분적으로 완성된 문자열을 전부 이어붙인 문자열을 반환해야 한다.

#### 확인사항

- 이중 반복문(double for loop)을 사용해야 함
- str.slice, str.substr, str.substring 사용 금지
- 빈 문자열을 입력받은 경우 빈 문자열 반환
- 예시 : 'cat' -> 'ccacat'

/* 역시 스스로 풀지 못했다. 스스로가 소수를 구하는 문제 뿐만이 아니라 이중 반복문 문제 유형에 매우 취약하다는 점을 깨달을 수 있었다. */

1. 문자열을 덧붙여서 결과값으로 반환할 빈 문자열을 선언해준다.

```javascript
let result = "";
```

2. 문자열의 길이만큼 반복되는 반복문을 만들어준다.

```javascript
for (i = 0; i < str.length; i++) {}
```

3. j의 0번째 문자부터 입력하고 그 다음 문자 또한 0번째부터 다시 입력해야 하기 때문에 j <= i 조건의 반복문을 만들어준다.

```javascript
for (i = 0; i < str.length; i++) {
  for (j = 0; j <= i; j++) {
    result = result + str[j];
  }
}
return result;

//ccacat
```

</br>

**※ function makeMarginalString('cat')의 작동 과정**
| i | j | 대입된 문자열 | 안쪽 반복문의 반복 조건 | 바깥쪽 반복문의 반복 조건 | 변화되는 반복문 조건의 변수 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 'c' | true | · | j++ |
| 0 | 1 | 'c' | false | true | i++ |
| 1 | 0 | 'cc' | true | · | j++ |
| 1 | 1 | 'cca' | true | · | j++ |
| 1 | 2 | 'cca' | false | true | i++ |
| 2 | 0 | 'ccac' | true | · | j++ |
| 2 | 1 | 'ccaca' | true | · | j++ |
| 2 | 2 | 'ccacat' | true | · | j++ |
| 2 | 3 | 'ccacat' | false | false | · |

</br>
</br>

# Code Styling

- 문자열 표시는 작은 따옴표를 권장. HTML에서 사용하는 큰 따옴표와 구분하기 위해서 작은 따옴표가 권장된다.
- 줄 바꿈이 필요한 문자열을 정의할 때는 `(backtick) 사용 권장

```javascript
let multilineText = `this is line one
this is line two
this is line three`;
```

- 함수 표현식의 끝에는 세미콜론을 사용. 사용하지 않아도 세미콜론 자동 삽입 기능 ASI가 있어서 에러가 나는 경우는 거의 없다. 하지만 알고 사용하지 않는 것과 그렇지 않은 경우에는 디버깅 능력 향상에 큰 차이가 생기게 된다.

```javascript
let greet = function () {
  alert("hello!");
};
```

- 동치 연산(==, !=)은 엄밀하지 않기 때문에 동치 연산(===, !==)을 사용하라.
- 3항 연산자는 코드가 간결하고 구독성이 좋은 경우만 사용하라.
