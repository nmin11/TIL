2021 / 08 / 13

## Front-End 개발에서의 상태 관리

React는 상태 관리를 위한 라이브러리는 아니다.  
그러나 상태 관리의 주요 원칙을 이해한다면 컴포넌트 간 서로 느슨하게 결합된, 구조적으로 아름다운 코드를 작성할 수 있다.  
상태는 "변하는 데이터", 즉, "동적으로 표현되는 데이터"이다.  
이러한 상태를 다룰 때 Side Effect는 주요 고려 대상이다.

</br>

### 전역 상태

Side Effect를 줄이기 위해서 상태를 로컬 상태와 전역 상태로 나눠서 접근해보면 좋다.  
로컬 상태는 특정 컴포넌트 안에서만 관리되는 상태를 뜻하며, 전역 상태는 프로덕트 전체 혹은 여러가지 컴포넌트가 동시에 관리하는 상태를 뜻한다.  
전역 상태는 다른 컴포넌트와 상태를 공유하고 영향을 끼치는 상태이다.  
JavaScript를 사용할 때 전역 변수를 남용하는 것은 좋지 않지만, 경우에 따라 전역 상태가 필요하다.  
서로 다른 컴포넌트가 동일한 상태를 다룬다면, 출처는 오직 한 곳이어야 한다.  
여기서 '하나의 출처'는 다른 말로 '전역 공간'이라고 볼 수 있다.  
이는 데이터 무결성을 위해, 동일한 데이터는 항상 같은 곳에서 데이터를 가져온다는 Single source of truth 원칙과도 일맥상통한다.  
전역으로 상태를 관리해야 하는 대표적인 예시로는 다크모드 기능, 국제화 기능, 히스토리 기능, Undo/Redo 등이 있다.

</br>

### 상태 관리를 위한 각종 툴

- React Context
- Redux
- MobX

현업에서도 많이 쓰이는 툴들이다.  
이러한 툴들의 역할은 다음과 같다.

- 전역 상태 저장소 제공
- Props drilling 이슈 해결 (부모의 props가 필요 없는 자식인 경우 굳이 부모의 props를 받지 않음)

상태 관리 툴은 반드시 필요한 것은 아니다.  
중요한 것은 "상태가 어디에 위치해야 하는지"를 아는 것이다.

</br>

## Redux

Redux는 JavaScript 애플리케이션에서 예측 가능한 상태 관리 컨테이너이다.  
state는 컴포넌트 안에서 필요한 상태를 담아두는 공간이다.  
컴포넌트들 간에 데이터를 주고 받을 때에는 동일한 부모 컴포넌트를 통해서 데이터를 넘겨줘야만 한다.  
구조가 단순하면 괜찮겠지만 컴포넌트들 간의 관계가 복잡해지면 부모 자식 간의 state 전달이 까다로워질 것이다.  
이러한 불편함을 해소하기 위해서 Redux가 등장했다.

</br>

### 3가지 원칙

1. Single source of truth
2. State is read-only
3. Changes are made with pure functions

이 3가지 원칙은 Store, Action, Reducer와 연결된다.

</br>

### Store

상태가 관리되는 오직 하나의 공간을 뜻한다.  
컴포넌트들은 state가 필요할 때 Store에 접근하면 된다.

</br>

### Action

Simple JavaScript Object이다.  
이 객체 안에 type을 비롯한 다양한 데이터들이 담긴다.  
Action 객체는 Store에게 애플리케이션의 데이터를 운반해준다.

</br>

### Reducer

현재 상태와 Action을 활용해서 다음 상태를 만들어 낸다.  
Action 객체는 Dipatch에게 전달되고, Dipatch는 Reducer를 호출해서 새로운 state를 생성한다.

</br>

### 작동 과정

UI에서 특정 행동을 수행하면, Dispatch에 전달 객체로 Action 객체를 담아서 Reducer로 전달한다.  
Reducer는 Action 객체의 타입에 따라서 그에 맞는 동작을 한다.  
이에 대한 결과로 새로운 state가 반환된다.

</br>

### 장점

1. 상태를 예측 가능하게 해준다.
2. 유지보수에 용이하다.
3. 디버깅에 유리하다.
4. 테스트에 용이하다.

</br>

### 비동기 액션

Redux에서 비동기 작업을 처리할 때는 [redux-thunk](https://github.com/reduxjs/redux-thunk/) 라는 미들웨어를 많이 사용한다.  
비동기 액션 생산자는 상태에 따라 동기 액션 생산자를 호출해준다.  
여기서 말하는 상태는 비동기 요청 시작 / 완료 / 실패 등을 포함할 수 있다.  
비동기 액션 생산자는 Reducer로 연결되지 않고 직접 dispatcher를 통해 Store로 새로운 상태를 보내준다.  
함수를 dispatch할 경우에는 해당 함수에서 dispatch와 getState를 파라미터로 받아와야 한다.
