2021 / 07 / 26

## 비동기 쉽게 이해하기

커피숍에서 커피를 주문하려고 줄을 서는 모습을 상상해보자.  
만약 먼저 주문한 사람이 커피를 받을 때까지 뒷사람들은 주문조차 할 수 없다고 가정한다면, 이를 우리는 **blocking**이라고 부른다.  
하나의 작업이 끝날 때까지 이어지는 작업을 막는 것이다.  
먼저 온 사람이 주문한 커피가 나오고 나서야 바로 뒷사람의 주문이 시작된다.  
이렇게 시작 시점과 완료 시점이 같은 상황을 **동기적(synchronous)** 이라고 한다.

</br>

반면, 우리가 잘 아는 효율적인 커피숍들의 운영은 아래와 같이 주문 과정을 처리한다.

- 커피 주문이 blocking되지 않고, 언제든지 주문을 받을 수 있다.
- 주문 완료 시점과 주문 시작 시점이 같을 필요가 없으며, 커피가 완성되는 즉시 커피를 제공한다.

</br>

Node.js를 만든 개발자도 Node.js를 non-blocking하고 **비동기적(asynchronous)** 으로 작동하는 런타임으로 개발했다.  
JavaScript의 비동기적 실행이라는 개념은 웹 개발에서 특히 유용하다.  
특히 아래의 작업은 비동기적으로 작동되어야 효율적이다.

- 백그라운드 실행, 로딩 창 등의 작업
- 인터넷에서 서버로 요청을 보내고, 응답을 기다리는 작업
- 큰 용량의 파일을 로딩하는 작업

</br>

## 고차함수와 Callback

**고차함수는 다른 함수를 인자(argument)로 전달받을 수 있다.**

- 고차함수의 인자로 전달되는 함수를 콜백 함수라고 한다.  
  콜백 함수는 어떤 작업이 완료되고 호출하는 경우가 많아서, 업무 중 걸려온 전화에 답신하는 전화를 나타내는 콜백이라는 이름이 붙여졌다.

**고차함수는 다른 함수를 리턴할 수 있다.**

- '함수를 리턴하는 함수'는 Haskell Curry의 이름을 따서 커리 함수라고 한다.  
  커리 함수라는 용어를 사용하는 경우에는 고차함수라는 용어를 '함수를 인자로 받는 함수'에만 한정해서 사용하기도 한다.

**'함수를 리턴하는 함수'와 '함수를 인자로 받는 함수' 모두 고차 함수이다.**

</br>

**즉, 고차함수는 콜백 함수와 커리 함수의 상위 개념이다.**

</br>

콜백 함수를 전달받은 caller 함수는 함수 내부에서 콜백 함수를 호출(invoke)할 수 있다.  
caller는 조건에 따라 콜백 함수의 실행 여부를 결정할 수 있다.  
아예 호출하지 않을 수도 있고, 여러 번 실행할 수도 있다.  
앞으로는 특정 작업의 완료 후에 호출하는 경우를 자주 접할 수 있을 것이다.
