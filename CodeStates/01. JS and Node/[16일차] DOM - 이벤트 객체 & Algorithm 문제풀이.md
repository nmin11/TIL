2021 / 07 / 06

# DOM의 이벤트 객체

## DOM을 통한 이벤트 호출 방법

### 직접 호출

```javascript
let testInput = document.querySelector("#test-input");

testButton.onkeyup = validFunction;

function validFunction() {
  console.log("키를 눌렀다 떼었습니다.");
}
```

</br>

### 이벤트 리스너를 통한 호출

```javascript
let testInput = document.querySelector("#test-input");

testInput.addEventListener("keyup", function () {
  console.log("키를 눌렀다 떼었습니다.");
});

//or

testInput.addEventListener("keyup", () => {
  console.log("키를 눌렀다 떼었습니다.");
});

//or

testInput.addEventListener("keyup", sampleFunc);

function sampleFunc() {
  console.log("키를 눌렀다 떼었습니다.");
}
```

</br>

## DOM의 이벤트들

### keyup

- 키를 놓을 때 이벤트 발생
- 이벤트 핸들러 속성 : onkeyup

</br>

### keydown

- 키를 눌렀을 때 이벤트 발생
- 이벤트 핸들러 속성 : onkeydown

</br>

### change

- 값이 변경된 후 포커스도 벗어났을 때 이벤트 발생
- 이벤트 핸들러 속성 : onchange

</br>

### focus

- 포커스가 해당 엘리먼트에 갔을 때 이벤트 발생
- 이벤트 핸들러 속성 : onfocus

</br>

### blur

- 포커스가 해당 엘리먼트에서 벗어났을 때 이벤트 발생
- 이벤트 핸들러 속성 : onblur

</br>

### submit

- form 태그의 action이 발생하기 직전에 이벤트 발생
- 이벤트 핸들러 속성 : onsubmit

</br>

### mouseover

- 해당 엘리먼트에 마우스가 올라왔을 때 이벤트 발생
- 이벤트 핸들러 속성 : onmouseover

</br>

### mouseout

- 해당 엘리먼트에서 마우스가 나갔을 때 이벤트 발생
- 이벤트 핸들러 속성 : onmouseout

</br>

### onload

- 브라우저가 페이지 load를 끝냈을 때 이벤트 발생

</br>

### event.preventDefault

- 이벤트를 취소할 경우, 이벤트의 전파를 막지 않고 이벤트를 취소

```javascript
function checkName(evt) {
  var charCode = evt.charCode;

  if (charCode != 0) {
    if (charCode < 97 || charCode > 122) {
      evt.preventDefault();
      alert(
        "소문자만 입력할 수 있습니다." + "\n" + "charCode: " + charCode + "\n"
      );
    }
  }
}
```

</br>

## DOM 추가 정리 (append / prepend)

- append는 이미 있는 자식 요소들의 뒤쪽에 추가
- prepend는 이미 있는 자식 요소들의 앞쪽에 추가
- 부모.append(자식)
- 자식.appendTo(부모)

</br>

### ★ 면접을 위해 - DOM이란?

=> HTML 문서를 객체의 형식으로 가공하기 위해 만든 멘탈 모델 / HTML의 트리 구조와 JavaScript 객체의 트리구조가 멘탈 모델이 같게 함

</br>

### childNodes

자식들 중 엘리먼트와 엘리먼트가 아닌 텍스트 및 빈 공간들까지 같이 반환해준다.  
children 메소드를 사용하면 자식들 중 엘리먼트만 반환된다.

</br>

### document.documentElement.scrollTop

현재 스크롤의 위치를 알 수 있다.

```javascript
document.addEventListener("scroll", handleScroll);
```

위와 같이 이벤트 핸들러와 사용할 수도 있다.  
잘 만든 웹 사이트들을 구경해보면 스크롤을 내릴 때마다 화려한 화면 전환 효과를 볼 수 있는데, 바로 이 이벤트를 활용한 것이다.

</br>

### addEventListener의 특징 한 가지

이벤트가 누적된다.  
button.onclick = func; 같은 식으로 클릭 함수를 지정할 경우에는 한 가지 이벤트만 할당된다.  
removeEventListener를 통해 겹친 이벤트 중 특정 이벤트를 지울 수도 있다.

</br>
</br>

# Algorithm 문제 풀이

이번 주 월요일부터 아침에 1시간에 2문제씩 Algorithm 문제를 푸는 시간이 주어졌다.  
문제를 풀어나가는 것에 흥미가 붙기도 해서, 시간이 나면 틈틈이 문제들을 더 풀어나가다보니 화요일 오후에 20문제를 다 풀 수 있게 되었다.  
하지만 솔직하게 털어놓자면, 그 중 3문제는 구글링을 통해 해답을 보고 스포일러를 당한 상태에서 풀었다.  
문제가 잘 안풀려서 참고할 만한 공식 같은 것이 있을지 찾아보려고 했는데 덜컥 답을 찾아버린 것이다.  
이렇듯 온전히 내 힘으로 풀지 못한 문제들도 있고, 추가적으로 알게 된 표현식 같은 것들도 있으니 문제들을 다시 기억 속에 되새기는 작업이 필요하다.  
이번에도 문제의 해답을 직접적으로 제시하지는 않을 것이다.

</br>

## 정규 표현식을 통해 공백 다루기

### 알파벳 문자열에 공백이 있을 경우, 공백 바로 뒤의 문자 하나는 대문자로 바꾸기

이것을 정규표현식으로 아주 간단하게 표현할 수 있는 방법이 있어서 기억해두고 싶은 마음에 이렇게 기록을 남긴다.

```javascript
str.replace(/(^|\s)\S/g, (firstStr) => firstStr.toUpperCase());
```

</br>

### 공백이 두 칸이면 한 칸 짜리 공백으로 바꾸기

```javascript
str.replace(/  /g, " ");
```

</br>

## readVertically

### 문제 : 문자열을 요소로 갖는 배열을 입력받아 문자열을 세로로 읽었을 때의 문자열 반환

### 확인사항

- 각 문자열의 길이는 다양함
- 각 문자의 위치를 행, 열로 나타냈을 경우, 비어있는 행, 열은 무시함

내가 아직도 이중 반복문에 취약하다는 사실을 여지없이 보여주는 문제였다.  
그리고 돌이켜 생각해보면 시간이 넉넉했는데도 깊이 고민해보지 않고 구글링을 통해 해결했던 것 같다.  
문제가 잘 안풀려도 조금 더 심사숙고하는 버릇을 더 키워야 한다.  
</br>
아무튼 이 문제의 풀이를 해설하자면 이렇다.  
우선 배열에 속한 문자열 중 가장 길이가 긴 것을 for문을 통해 찾아내어 maxLength라는 변수에 담아둔다.  
이 후 편의상 빈 문자열을 담은 변수를 선언해서 이후에 결과값들을 더해주는 방식으로 진행했다.  
그리고 0부터 maxLength까지 도는 반복문 안에 배열의 길이만큼 도는 반복문을 만들어준다.  
배열의 길이만큼 도는 반복문 안에서 if문을 통해 배열의 j번째 문자열의 i번째 문자가 undefined인 경우에는 continue를 해주고 그 밖에는 결과값을 담을 변수에 배열의 j번째 문자열의 i번째 문자를 넣어준다.  
이렇게 만들어진 결과값을 반환하면 된다.

</br>

## 바빌로니아 법의 점화식 (Recurrence Formula)

### 문제 : 수를 입력받아 제곱근 값을 소수점 두 자리까지만 반환

### 확인사항

- 소수점 셋째 자리에서 반올림해야 함
- Math.sqrt 사용 금지
- 바빌로니아 법의 점화식을 이용해서 풀 수도 있음

[위키피디아](https://ko.wikipedia.org/wiki/%EB%B0%94%EB%B9%8C%EB%A1%9C%EB%8B%88%EC%95%84_%EB%B2%95)에 따르면, 바빌로니아 법의 점화식은 다음과 같다.

</br>

(이미지 첨부 바빌로니아 법)

</br>

사실 완전히 이해할 순 없었지만 어찌 되었건 주어진 숫자를 끊임없이 잘게 쪼갠다는 것을 알 수 있었다.  
위키피디아의 예시와 같이 그렇게 계속 쪼개다보면 문제에서 요구하는 소수점 2자리는 일정해진다는 것을 어느 정도 유추해볼 수 있다.  
그렇다면 소수점 2자리가 일정해질 때까지 반복문을 돌린 다음 나온 숫자를 반환해주면 되는 것이다.  
일단 위키피디아에 나온 계산식을 자바스크립트로 옮기면 다음과 같다.

```javascript
x = (x + num / x) / 2;
```

x의 0번째 값은 1인 것이 계산하기에 편하다.  
따라서 코드의 시작부분에 x = 1이라는 선언을 해두면 좋다.  
이렇게 준비를 마쳤다면 반복문을 돌려야 하는데 이 과정이 만만치 않다.  
바빌로니아 법의 점화식은 무한히 돌 수 있기 때문이다.  
그리고 소숫점 3자리에서 반올림을 할 때에도 미세하게 0.5 단위에서 값이 변할 수도 있다.  
내가 참고한 풀이에서는 x의 제곱이 num과 같지 않는 한 반복하는 while문에서 다시 if문을 통해 x의 제곱을 2자리로 반올림한 숫자가 기존의 숫자와 일치하면 break를 걸어주는 방식을 사용했다.  
나머지 경우에는 계속 x를 위의 계산식으로 잘게 쪼개는 것이다.  
while문이 끝난 이후에는 x의 값을 2자리로 반올림해서 반환하는 것이다.

</br>

### 소감

사실 지금 봐도 이 제곱근 문제는 이해가 쉽게 되지 않는다.  
나중에 꼭 다시 한번 이 문제를 풀어봐야겠다.  
</br>
이번 Algorithm 기초 20 문제를 풀면서 느낀 총평은 일단 꽤 풀어나가는 재미가 있었다.  
주말에 프로그래머스와 LeetCode로 골머리를 앓았던 경험들이 꽤나 유용한 경험이었다는 사실에 기분이 좋았다.  
코드스테이츠 디스코드 공지에서 난이도가 점점 어려워질 것이라고 했는데 과연 그 말도 맞았다.  
몇몇 막혔던 문제들을 풀면서도 '아 이거 생각보다 간단할 것 같은데?' 하는 생각이 들었지만 정작 답을 시원시원하게 내놓지는 못했다.  
더불어서 아직도 이중 반복문이나 if문의 위치를 제대로 못 잡아서 애를 먹었던 경우도 있었다.  
이는 아직도 갈 길이 멀다는 것이다.  
시간이 나면 꼭 문제 풀이 사이트를 적극 이용해서 한 문제 씩이라도 꼭 풀어보자.  
결국 내 실력 향상이고, 결국 나중의 코딩 테스트에서 엄청난 도움이 되어줄 것이다.
