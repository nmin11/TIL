2021 / 09 / 13

<img width="790" alt="OSI 7계층과 TCP 및 IP 4계층" src="https://user-images.githubusercontent.com/75058239/133056645-e70c1a74-3c19-470a-b6da-ff4c5fa64e2d.png">

</br>

# 인터넷 프로토콜

## IP와 IP Packet

IP(Internet Protocol)는 인터넷 통신의 기본이다.  
복잡한 인터넷 망 속에는 수많은 노드들이 있는데, 어떻게 클라이언트와 서버가 통신할 수 있는 것일까?  
요청에서 응답까지 데이터가 무사히 전달되려면 규칙이 필요할 것이다.  
그래서 IP 주소를 컴퓨터에 부여하고 이를 이용해서 통신하는 것이다.  
IP는 지정한 IP 주소에 **Packet**이라는 통신 단위로 데이터를 전달한다.  
Packet은 pack과 bucket이 합쳐진 단어로, 소포에 비유할 수 있다.  
Packet은 데이터를 무사히 전송하기 위해서 출발지 IP, 목적지 IP 등의 정보를 포함해서 데이터를 전송한다.  
Packet을 이용해서 복잡한 인터넷 망 사이에서도 정확한 목적지로 데이터 전송이 가능해진다.  
서버에서 응답을 보낼 때도 마찬가지로, Packet을 이용해서 클라이언트에 응답을 전달한다.

</br>

하지만 IP Protocol은 한계점들을 갖고 있다.

- 비연결성
  - Packet을 받을 대상이 없거나 대상이 서비스 불능 상태여도 Packet 전송
- 비신뢰성
  - 중간에 있는 서버에 장애가 생겨서 Packet이 사라질 수 있음
  - 전달 데이터의 용량이 클 경우 Packet 단위로 나눠서 전달하게 되는데,  
    이렇게 되면 클라이언트가 의도하지 않은 순서로 서버에 Packet이 도착할 수 있게 됨

</br>

## TCP와 UDP

### TCP 개념

Transmission Control Protocol : 전송 제어 프로토콜

</br>

맨 위 이미지에서 본 것처럼, 네트워크 프로토콜 계층은 OSI 7계층과 TCP/IP 4계층으로 나눌 수 있다.  
그리고 IP Protocol보다 더 높은 계층에 TCP Protocol이 존재하기 때문에 앞서 살펴본 IP Protocol의 한계를 보완할 수 있다.

</br>

![프로토콜 계층 작동방식](https://user-images.githubusercontent.com/75058239/133056677-de26f369-6d33-4181-87af-239fcc400df2.png)

TCP/IP 4계층의 작동 방식을 간단하게 살펴보자면, 우선 **어플리케이션 계층**에서 HTTP 메시지를 생성하고, 이를 Socket 라이브러리를 통해서 전달한다.  
여기서 Socket은, "네트워크 환경에 연결할 수 있게 만들어진 연결부"이다.  
그 다음 단계로, **전송 계층**에서 데이터를 TCP 세그먼트로 감싸준다.  
또 그 다음에는 **인터넷 계층**에서 TCP 데이터를 IP Packet으로 감싸준다.  
이렇게 생성된 TCP/IP Packet은 LAN 카드와 같은 **네트워크 인터페이스 계층**을 거쳐서, 이더넷 프레임워크에 포함되어 서버로 전송된다.

</br>

이번에는 TCP/IP Packet을 살펴보자.  
우선 TCP 세그먼트는 IP Packet의 출발지 IP와 목적지 IP를 보완해주는 출발지 PORT와 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다.

</br>

### TCP 특징

- 연결 지향 - TCP 3 way handshake (가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜

</br>

#### TCP 3 way handshake

![TCP 3 way](https://user-images.githubusercontent.com/75058239/133057392-dc4782d2-b82b-497d-bda1-a3b6459ed915.png)

TCP는 장치들 사이에 논리적인 접속을 성립하기 위해서 3 way handshake를 사용하는 연결지향형 프로토콜이다.  
연결 방식을 살펴보자면 우선 클라이언트는 서버에 접속을 요청하는 SYN(Syncronize) Packet을 보낸다.  
서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK(Acknowledgement)와 SYN이 설정된 Packet을 발송하고, 클라이언트가 다시 ACK로 응답하기를 기다린다.  
클라이언트가 서버에 ACK를 전송하면 이후로는 연결이 성립되며 데이터를 전송할 수 있게 된다.  
만약 서버가 꺼져 있다면 SYN 요청 전송 이후 응답이 없을 것이기 때문에 데이터를 보내지 않는다.  
현재에는 최적화가 이루어져서 3번에서 클라이언트가 ACK를 전송할 때 데이터를 함께 보내기도 한다.

</br>

#### 순서 보장

만약 서버에 Packet이 순서대로 도착하지 않았다면 서버는 TCP 세그먼트에 있는 정보를 토대로 다시 Packet 전송을 요청할 수 있다.  
이를 통해서 IP Packet의 한계 중 하나였던 '순서를 보장하지 않았던 문제'를 해결할 수 있다.

</br>

### UDP 특징

User Datagram Protocol : 사용자 데이터그램 프로토콜

</br>

- 하얀 도화지에 비유됨
- 비 연결지향
- 데이터 전달 보증 없음
- 순서 보장 없음
- 단순하고 빠름
- 신뢰성보다 연속성이 중요한 서비스(e.g. 실시간 스트리밍)에 자주 사용됨

UDP는 IP Protocol에 PORT, checksum 필드 정보만 추가된 단순한 프로토콜이다.  
TCP에 비해 비교적 빠른 속도를 보장한다.  
HTTP3는 UDP를 사용하며, 이미 여러가지 기능이 구현되어 있는 TCP에 비해서 커스터마이징이 가능하다는 장점이 있다.

</br>

※ checksum : 중복 검사의 한 형태로, 오류 정정을 통해 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법

</br>

## HTTP

### HTTP 버전

- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3

현재는 주로 HTTP/1.1을 주로 사용하지만 HTTP/2, HTTP/3의 사용도 점점 증가하고 있다.

</br>

### HTTP 특징

- 클라이언트 서버 구조
- Stateless, Connectionless
- HTTP 메세지
- 단순하며 확장 가능

</br>

#### 클라이언트 서버 구조

- Request / Response 구조
- 클라이언트는 서버에 요청을 보내고 응답을 대기하며, 서버는 요청에 대한 결과를 만들어서 응답

</br>

#### Stateless (무상태 프로토콜)

- 서버가 클라이언트의 상태를 보존하지 않음
  - 장점 : 서버 확장성이 높아짐 (스케일 아웃)
  - 단점 : 클라이언트가 추가적으로 데이터를 전송

모든 것을 무상태로 해결할 수는 없다.  
대표적으로 로그인 유지와 같은 부분은 브라우저 쿠키, 서버 세션, 토큰 등을 이용해서 상태를 유지해야만 한다.  
그러나 최대한 Stateless하게 설계하는 것이 중요하다.

</br>

#### Connectionless (비연결성)

TCP/IP의 경우 기본적으로 연결을 유지한다.  
이 때 연결을 유지하는 서버의 자원이 계속 소모된다.  
반면에 HTTP는 실제 요청을 주고 받을 때만 연결을 유지하고, 응답을 주고 나면 TCP/IP 연결은 끊는다.  
이를 통해 최소한의 자원으로 서버를 유지할 수 있도록 한다.

- HTTP는 기본이 연결을 유지하지 않는 모델
- 트래픽이 많지 않고 빠른 응답을 제공할 수 있는 경우에 효율적

하지만 비연결성에도 한계점이 있다.

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
- 현재에는 HTTP 지속 연결(Persistent Connections)로 문제를 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

</br>

![HTTP 초기](https://user-images.githubusercontent.com/75058239/133057768-e2f0be93-9506-4d66-930b-7162146fa74a.png)

</br>

HTTP 초기에는 각각의 자원을 다운로드하기 위해 연결과 종료를 반복해야 했다.

</br>

![HTTP 지속연결](https://user-images.githubusercontent.com/75058239/133057786-8260cccc-4cd7-4ee8-a5cb-2ce7788dfcb8.png)

</br>

HTTP 지속 연결에서는 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고, 모든 자원에 대한 응답이 돌아온 후에 연결을 종료한다.

</br>
</br>

# HTTP 헤더

![표현 헤드와 표현 데이터](https://user-images.githubusercontent.com/75058239/133057825-70f23759-3967-41fb-be79-db2ac4024597.png)

</br>

HTTP 메시지는 헤더와 바디로 구분할 수 있다.  
바디에서는 데이터 메시지 본문(Message body)을 통해서 표현(Representation) 데이터를 전달한다.  
여기에서 데이터를 실어 나르는 부분을 Payload라 한다.  
표현은 요청이나 응답에서 전달할 실제 데이터를 뜻하며, 표현 헤더는 데이터를 해석할 수 있는 정보를 제공한다.

</br>

![HTTP 헤더](https://user-images.githubusercontent.com/75058239/133057431-a47b68ad-571a-4ba4-9320-06039b17c1e7.png)

</br>

HTTP 헤더는 HTTP 전송에 필요한 모든 부가 정보를 담기 위해 사용한다.  
예를 들면 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보 등이 담긴다.  
표준 헤더가 무척 많으며, 필요 시 임의의 헤더를 추가할 수도 있다.

</br>

## 표현 헤더

표현 데이터의 형식, 압축 방식, 자연 언어, 길이 등을 설명해주는 헤더이다.
표현 헤더는 요청, 응답 둘 다 사용한다.

- **Content-Type** : 표현 데이터의 형식
- **Content-Encoding** : 표현 데이터의 압축 방식
- **Content-Language** : 표현 데이터의 자연 언어
- **Content-Length** : 표현 데이터의 길이

</br>

### Content-Type

표현 데이터의 형식을 설명해주며, 미디어 타입, 문자 인코딩이 이에 해당한다.

- Text/html; charset=utf-8
- application/json
- Image/png

</br>

### Content-Encoding

- 표현 데이터를 압축하기 위해 사용
- 데이터를 전달하는 곳에서 압축 후에 인코딩 헤더를 추가하는 방식
- 데이터를 읽는 쪽에서 인코딩 헤더의 정보를 통해 압축 해제
- e.g.
  - gzip
  - deflate
  - identity

</br>

### Content-Language

- ko
- en
- en-US

</br>

### Content-Length

- byte 단위로 표현
- Transfer-Encoding(전송 코딩)을 사용할 경우 Content-Length를 사용하면 안됨

Transfer-Encoding은 전송 시 어떤 인코딩 방법을 사용할 것인지 명시한다.  
그러나 현재는 Content-Encoding을 더 선호한다.  
Transfer-Encoding을 사용하는 경우 chunked의 방식으로 사용한다.  
chunked 방식의 인코딩은 많은 양의 데이터를 분할하여 보내기 때문에 전체 데이터 크기를 알 수 없어서 표현 데이터의 길이를 명시하는 Content-Length 헤더를 함께 사용할 수 없다.

</br>

## HTTP 주요 헤더

### Form - 유저 에이전트의 이메일 정보

- 일반적으로 잘 사용하지 않음
- 검색 엔진에서 주로 사용
- 요청에서 사용

</br>

### Referer - 이전 웹 페이지 주소

- 현재 요청된 페이지의 이전 웹페이지 주소
- 유입 경로를 수집할 수 있음
- 요청에서 사용
- referrer의 오탈자이지만 스펙으로 굳어짐

</br>

### User Agent - 유저 에이전트 애플리케이션 정보

- 클라이언트의 애플리케이션 정보 (브라우저 등)
- 통계 정보
- 어떤 종류의 브라우저에서 장애가 발생하는지 파악할 수 있도록 해줌
- 요청에서 사용
- e.g.
  - user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
    537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36

</br>

### Server - 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

- 응답에서 사용
- e.g.
  - Server: Apache/2.2.22 (Debian)
  - Server: nginx

</br>

### Date - 메시지가 발생한 날짜와 시간

- 응답에서 사용
- e.g.
  - Date: Tue, 15 Nov 1994 08:12:31 GMT

</br>

### Host - 요청한 호스트 정보 (Domain)

- 요청에서 사용
- 필수 헤더
- 하나의 서버가 여러 도메인을 처리해야 할 때 용이
- 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 용이

</br>

<img width="829" alt="HTTP HOST 헤더" src="https://user-images.githubusercontent.com/75058239/133057510-9092a20c-0e74-44a9-9c74-5a335157bbff.png">

</br>

### Location - 페이지 리다이렉션

- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 리다이렉트하게 됨
- 201(Created) : Location 값은 요청에 의해 생성된 리소스 URI
- 3xx(Redirection) : Location 값은 요청을 자동으로 리다이렉션하기 위한 대상 리소스를 가리킴

</br>

### Allow - 허용 가능한 HTTP 메소드

- 405(Method Not Allowed)에서 응답에 포함
- e.g.
  - Allow: GET, HEAD, PUT

</br>

### Retry-After - 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

- 503(Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음
- e.g.
  - Retry-After: Fri, 31 Dec 2020 23:59:59 GMT (날짜 표기)
  - Retry-After: 120 (초 단위 표기)

</br>

### Authorization - 인증 토큰을 서버로 보낼 때 사용하는 헤더

- "토큰의 종류 " + "실제 토큰 문자"를 전송
- e.g.
  - Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l

</br>

### Origin - 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄

- 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러 발생
- 응답 헤더의 Access-Control-Allow-Origin과 연관됨

</br>

### Access-Control-Allow-Origin - 요청을 보내는 주소와 받는 주소가 다르면 CORS 에러 발생

- 서버에서 이 헤더에 프론트 주소를 적어주어야 에러가 발생하지 않음
- 프로토콜, 서브도메인, 도메인, 포트 중 하나만 달라도 CORS 에러 발생
- e.g.
  - Access-Control-Allow-Origin: www.codestates.com
- 만약 주소를 일일이 지정하기 싫다면 \* 기호를 통해 모든 주소에 CORS 요청을 허용하지만 그만큼 보안이 취약해짐
  - Access-Control-Allow-Origin: \*
- 유사한 헤더 : Access-Control-Request-Method, Access-Control-Request-Headers, Access-Control-Allow-Methods, Access-Control-Allow-Headers 등

</br>

## Content Negotiation

요청 시에만 사용하는, 클라이언트가 선호하는 표현 요청이다.

- **Accept** : 클라이언트가 선호하는 미디어 타입
- **Accept-Charset** : 클라이언트가 선호하는 문자 인코딩
- **Accept-Encoding** : 클라이언트가 선호하는 압축 인코딩
- **Accept-Language** : 클라이언트가 선호하는 자연 언어

만약 선호하는 타입이 서버에 존재하지 않을 경우, 0부터 1까지 중에서 Quality Values(q)를 부여해서 우선순위를 지정할 수 있다.

</br>

e.g.  
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

</br>

## 캐시 관련 헤더

만약 클라이언트가 이미지에 대한 요청을 보내고, 서버가 해당 이미지에 대한 응답을 준다고 했을 때, HTTP 헤더가 0.1M, 바디가 1M로 총 1.1M라고 가정해보자.  
클라이언트는 모든 요청마다 1.1M의 응답을 받게 된다.  
심지어 이미지 파일은 동일한데도 말이다.  
이를 해결하기 위해 브라우저는 캐시를 통해 이미지를 미리 저장해놓을 수 있다.

</br>

컴퓨터 공학에서 Cache는 데이터나 값을 미리 복사해 놓는 임시 저장소를 일컫는 말이다.  
캐시는 캐시의 접근 시간에 비해서 원래 데이터에 다시 접근하는 시간이 오래 걸리는 경우나, 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다.

</br>

```
Cache-Control: max-age=60
```

위와 같이 설정해주면 브라우저 캐시에 해당 응답 결과를 저장하며 60초의 유효 시간을 갖는다.  
그리고 캐시는 다음과 같은 이점을 갖는다.

- 캐시 유지 시간 동안 네트워크를 사용하지 않아도 됨
- 브라우저 로딩 속도가 매우 빠름

캐시 유지 시간이 초과했을 경우에는, 응답 결과를 브라우저가 랜더링할 때 기존 캐시를 지우고 새 캐시로 업데이트한다.  
이 때 캐시 유효 시간은 다시 초기화된다.

</br>

### 검증 헤더와 조건부 요청

만약 캐시 유효 시간이 지났지만 요청하는 데이터에는 변경이 없을 때, 이를 검증하고 캐시를 다시 사용하는 방법이 없을까?

</br>

#### Last-Modified / If-Modified-Since

검증 헤더 Last-Modified를 사용하면 캐시의 수정 시간을 알 수 있다.  
Last-Modified는 데이터가 마지막으로 수정된 시간 정보를 헤더에 포함해준다.  
이로 인해 응답 결과를 캐시에 저장할 때 데이터 최종 수정일도 저장하게 된다.  
If-Modified-Since 헤더 또한 Last-Modified와 비슷하다.

</br>

두 검증 헤더는 서버의 해당 자료의 최종 수정일과 비교해서 데이터가 수정되지 않았을 경우, 응답 메시지에 이를 담아서 알려준다.  
이 때 HTTP Body는 응답 데이터에 없으며, 상태 코드는 304 Not Modified가 된다.  
응답 데이터는 헤더만 포함되기 때문에 응답 속도가 빨라진다.  
클라이언트에서는 해당 응답을 받은 뒤 캐시를 갱신해주고 다시 일정 시간 동안 유효하게 된다.

</br>

하지만 두 검증 헤더는 다음과 같은 단점들을 가진다.

- 1초 미만 단위로 캐시 조정 불가능
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 결과가 같은 경우
- 서버에서 별도의 캐시 로직을 관리할 수 없음

</br>

#### ETag / If-None-Match

- ETag (Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  - ETag: "v1.1",ETag: "61df5ee64dd7261cd4dc7e72c7d957a1"
- 데이터가 변경되면 이 태그 이름을 바꿔서 변경함 (Hash 재생성)
- 단순하게 ETag만 보내서 같으면 유지하고, 다르면 다시 받는 방식

작동방식은 이렇다.  
우선 클라이언트가 요청을 보내면 서버에서는 헤더에 ETag를 작성해서 응답한다.  
클라이언트는 캐시에 해당 ETag 값을 저장한다.  
그 다음 요청부터, 만약 캐시 시간이 초과되어서 다시 요청할 필요가 있다면 ETag 값을 검증하는 If-None-Match를 요청 헤더에 작성해서 보낸다.  
이 다음 로직은 Last-Modified / If-Modified-Since의 처리 방식과도 유사하다.

1. 데이터가 수정되었는지 ETag를 통해서 검증
2. 수정되지 않았다면 바디를 제외하고 HTTP 헤더만 전송
3. 브라우저 캐시에서 응답 결과를 재사용, 헤더 메타데이터 또한 갱신
4. 브라우저는 캐시에서 조회한 데이터를 렌더링

서버에서 데이터가 변경되지 않았을 경우 ETag는 동일하고, If-None-Match는 거짓이 된다.  
이 경우 304 Not Modified를 응답하며 이 때 HTTP Body는 없다.  
정리하자면 다음과 같다.

- 단순하게 ETag만 보내서 같으면 유지하고, 다르면 데이터를 다시 받는 방식
- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 이 값을 서버에 제공 (클라이언트는 캐시 매커니즘을 모름)
  1. 서버는 베타 오픈 기간 3일 동안 파일이 변경되어도 ETag를 동일하게 유지
  2. 애플리케이션 배포 주기에 맞추어 ETag 갱신

</br>

#### Cache-Control

- Cache-Control: max-age
  - 캐시 유효시간이며 초 단위
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만 항상 Origin 서버에 검증하고 사용
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨  
    (메모리에서만 사용하고 최대한 빨리 삭제)

</br>

#### Expires

- Expires: Mon, 01 Jan 1990 00:00:00 GMT
- 캐시 만료일을 정확한 날짜로 지정
- 지금은 더 유연한 Cache-Control: max-age 권장
- Cache-Control: max-age와 함께 사용할 경우 Expires는 무시됨

</br>

#### 정리

- 검증 헤더 (Validator)
  - ETag: "v1.0",ETag: "845eed07c5887cf"
  - Last-Modified: Wed, 26 Dec 2020 12:01:29 GMT
- 조건부 요청 헤더
  - If-Match, If-None-Match: **ETag** 값 사용
  - If-Modified-Since, If-Unmodified-Since: **Last-Modified** 값 사용

</br>

### Proxy Cache

프록시 서버는 클라이언트가 다른 네트워크 서비스에 간접적으로 접근할 수 있게 하는 컴퓨터 시스템이나 응용 프로그램을 뜻한다.  
클라이언트와 서버 사이에서 대리로 통신을 수행하는 것을 가리켜 **Proxy**라고 하며, 그 중계 기능을 하는 서버를 **Proxy Server**라고 한다.  
프록시 서버는 클라이언트 혹은 서버가 다른 네트워크에 간접적으로 접근해서 보안, 캐싱을 통해 트래픽을 분산시킬 수 있게 해준다.

</br>

예시로, 한국에서 미국에 있는 Origin 서버에서 데이터를 받아온다고 했을 때, 프록시 캐시 서버를 도입하면 여러 사람이 찾은 자료일수록 이미 캐시에 등록되어 있기 때문에 빠른 속도로 데이터를 받아올 수 있게 된다.  
이 때 클라이언트에서 사용하고 저장하는 캐시를 private cache라고 하며, 프록시 캐시 서버의 캐시를 public cache라고 한다.

</br>

#### 관련 헤더

- Cache-Control: public
  - 응답이 public cache에 저장되어도 됨
- Cache-Control: private
  - 응답이 해당 사용자만을 위한 것으로, private cache에 저장되어야 함 (기본값)
- Cache-Control: s-maxage
  - Proxy Cache에만 적용되는 max-age
- Age: 60 (HTTP 헤더)
  - Origin 서버에서 응답 후 Proxy Cache 내 머문 시간(초)

클라이언트가 캐시를 적용하지 않았음에도 브라우저가 캐시를 적용하고 있을 때, 이를 무효화할 수 있는 방법도 있다.

- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 Origin 서버에 검증하고 사용
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨
- Cache-Control: must-revalidate
  - 캐시 만료 후 최초 조회 시 Origin 서버로부터 검증받아야 함
  - Origin 서버 접근 실패 시 반드시 에러 발생 (504 Gateway Timeout)
  - 캐시 유효 시간이라면 캐시를 사용함
- Pragma: no-cache
  - HTTP 1.0 하위 호환 방식

확실하게 캐시 무효화 응답을 하고 싶다면 아래의 요소들을 포함해야 한다.

```
Cache-Control: no-cache,no-store,must-revalidate
Pragma: no-cache
```

no-cache와 must-revalidate 둘 모두 Origin 서버에 검증을 해야하지만 응답 방식에 차이가 있다.  
no-cache의 경우에는 캐시 서버 요청 시, 프록시 캐시 서버에 도착하면 Origin 서버에 요청을 한다.  
이후 Origin 서버에서 검증 후 304 응답을 받아온다.  
하지만 캐시 서버와 Origin 서버 간 네트워크 연결이 단절되어 접근이 불가능하다면 에러가 아니라 오래된 데이터라도 보여주자는 개념으로 200 OK 응답을 보내준다.  
하지만 must-revalidate라면 Origin 서버에 접근이 불가능할 때, 504 Gateway Timeout 에러를 보낸다.  
만약 금전과 관련된 로직이 포함되어 있다면 must-revalidate를 써야 한다.

</br>
</br>

# CDN (Content Delivery Network)

CDN은 컨텐츠를 좀 더 빠르고 효율적으로 제공하기 위해 등장했다.  
CDN 방식을 구현하기 위해서는, 세계 곳곳에 분포하는 데이터 센터에 컨텐츠를 저장해야 한다.  
이후 컨텐츠 요청을 받으면 지리적으로 가장 가까운 데이터 센터에서 컨텐츠를 제공해주는 방식이다.  
그리고 원본 서버는 S3와 같이 CDN에 속하지 않은 외부의 서버이다.

</br>

## 특징

- 원본을 복사하여 저장할 여러 개의 캐시 서버로 구성
- 컨텐츠를 요청받은 경우 데이터를 전달하기에 가장 유리한 캐시 서버에서 관련 컨텐츠 제공

만약 가장 가까운 데이터 센터가 전달해줄 컨텐츠를 가지고 있지 않다면, 다른 데이터 센터가 해당 컨텐츠를 갖고 있는지 확인해야 한다.  
이 때에도 가장 가까운 곳을 우선적으로 선택하며, 만약 모든 데이터 센터가 컨텐츠를 갖고 있지 않다면, 원본 서버에서 컨텐츠를 제공해야 한다.  
이런 작업이 일어났을 경우, 컨텐츠를 그 때부터 데이터 센터에 저장해두게 된다.  
저장하는 작업도 마찬가지로 요청한 곳과 가장 가까운 데이터 센터에 컨텐츠를 저장하는 방식으로 이루어진다.

</br>

## Static Contents

내용이 거의 변하지 않는 컨텐츠를 의미한다.

- HTML, 파일, 동영상 등
- 개인화되지 않은 대중적인 컨텐츠 (CDN의 캐시 서버에 저장하기 적합)

</br>

## Dynamic Contents

접속할 때마다 내용이 바뀌거나 사용자마다 다른 내용을 보여주는 컨텐츠를 뜻한다.

- 위치, IP 주소, 사용 시간 관련 컨텐츠
- 카드 번호, 전화 번호 등 개인화된 정보 관련 컨텐츠

**=> 컨텐츠가 바뀔 때마다 캐시 서버에 바뀐 컨텐츠가 전파되어야 함 (공통적인 부분만 서버에 저장)**  
=> 동적 컨텐츠 자체는 CDN 네트워크가 지원하기 어렵다.

</br>

## 장점

- DDos 공격에 어느 정도의 대응이 가능
- 로딩 속도 감소
- 트래픽 분산

</br>

### DDoS(Distributed Denial of Service attack, 분산 서비스 거부 공격) 대응

DDoS 공격은 서버의 수용량보다 훨씬 많은 요청을 보내서 서버를 사용 불가능하게 만드는 공격이다.  
하지만 CDN을 사용하면 센터 중 하나가 서비스 불능 상태가 되어도 다른 데이터 센터에서 컨텐츠를 제공해줄 수 있다.  
게다가 데이터 센터들은 거대한 컴퓨팅 능력을 가지고 있기 때문에 DDoS 공격으로 서비스 장애가 발생하기 어렵다.

</br>

## Scattered 방식

최대한 빠른 응답속도를 목표로 하는 CDN의 방식 중 하나이다.  
따라서 세계 곳곳에 비교적 낮은 성능의 데이터 센터를 구성하고 연결해 두어야 한다.  
이러한 방식은 관리해야 하는 데이터 센터의 수가 많기 때문에 데이터 센터 유지 비용 또한 높다.  
따라서 클라우드 제공자는 관리 비용을 사용자에게 전가한다.  
사용 요금 또한 매우 높다.  
잘 사용되지 않지만, 수요가 적은 지역에 데이터 센터를 세워야 할 때는 유리한 방식이다.

1. 세계 곳곳에 최대한 많은 캐시 서버 제공
2. 낮은 수용량의 데이터 센터 및 캐시 서버
3. 매우 높은 관리 비용 및 사용자 요금
4. 연결 수요가 적은 지역 대상으로 적절한 방식

</br>

## Consolidated 방식

데이터 센터를 통합해서 운영하는 CDN 방식이다.  
Scattered 방식에서 사용했던 낮은 성능 대신 고성능의 데이터 센터들을 운용해야 한다.  
응답시간은 늘어나지만 데이터 센터의 관리 및 유지 비용을 절감할 수 있다.  
유지 관리 비용이 줄어든다는 것은 또한 사용자들에게 전가되는 비용도 줄어든다는 의미이다.  
따라서 데이터 센터를 통합하면 할수록 사용자들의 부담이 줄어든다.  
이 방식은 연결 수요가 폭발적인 지역에 데이터 센터를 설립해야 한다면 적절하다.

1. 다수의 고성능 서버로 통합 운용
2. 응답 시간 증가 / 유지 비용 절감
3. 연결 수요가 많은 지역 대상으로 적절한 방식

</br>

## CDN 운영 방식의 변화

초기에는 응답 속도에 초점을 두어서, Scattered 방식에, 정적 컨텐츠를 주로 다뤘다.  
이로 인해 응답 속도는 매우 높았지만 사용자에게 전가되는 비용이 매우 높았다.  
하지만 시간이 흘러서 점차 동적 컨텐츠 또한 지원하게 되고, 데이터 센터 또한 통합되기 시작했다.  
이에 따라 관리하는 데이터 센터의 수가 줄어들기 때문에 사용자에게 전가되는 비용도 줄어들고 있다.  
또한, DDoS 공격 등 사이버 공격에 대응하며, 어떤 상황에서도 컨텐츠를 제공할 수 있도록 보안과 안정성에 집중하고 있다.

</br>
</br>

# DNS (Domain Name System)

도메인 주소를 IP 주소로 변환해주는 규칙과 레코드들의 모음이다.  
간단하게 설명하자면, 사람이 기억하기 쉬운 'www.naver.com'과 같은 도메인을 컴퓨터가 이해할 수 있는 '125.209.222.142'로 변환하여 요청이 원하는 곳에 도달할 수 있도록 도와주는 시스템이다.  
도메인 주소는 오른쪽부터 왼쪽으로 최상위 도메인과 여러 개의 도메인으로 구성되어 있다.

</br>

우선, 탑 레벨 도메인은 .com, .kr, .net 등 도메인의 가장 오른쪽에 위치한 도메인이다.  
kr, us와 같은 국가 코드를 사용하는 도메인은 co, ac와 같은 2단계 도메인과 함께 사용되기도 한다.

</br>

서브 도메인은 일반적으로 'www', 'm'과 같이, 제일 왼쪽에 위치한 도메인들이다.  
호스트 이름으로 불리기도 하는 서브 도메인은 웹 사이트의 특정 부분을 나눠서 보여줘야 하는 경우에 사용된다.  
'm(모바일)', 'www(기본)', 'store(스토어)' 등, 도메인에 따라 사이트의 구성이 달라지는 것을 보면 쉽게 이해할 수 있다.

</br>

## Domain Name Server(Zone)

도메인을 관리하는 도메인 서버(존)이다.  
대표적으로 모든 도메인을 관리하는 Root 네임 서버, TLD를 관리하는 네임 서버, 권한 있는 네임 서버로 구성된다.  
그리고 도메인 네임 서버는 하나의 서버로 구성되지 않는다.  
안정성을 위해 최소 2개 이상의 서버가 하나의 도메인 네임을 담당한다.  
여러 개의 서버를 구축해야 과부하 및 서비스 거부 공격에 대해 효율적으로 대응할 수 있다.  
루트 도메인 네임 서버는 각 최상위 도메인 네임 서버들의 주소를 알고 있으며 최상위 도메인 네임 서버는 권한 있는 네임 서버의 주소를 알고 있다.  
권한 있는 'example.com' 등의 도메인 IP 주소 및 도메인 정보를 관리하는 권한을 가진 서버이다.

</br>

## DNS Lookup

URL에 deploy.states.com 주소를 입력하면 'DNS Lookup'이라 불리는 다음 과정이 발생한다.

1. 브라우저는 리졸버에게 IP 주소를 요청한다.  
   리졸버는 요청 받은 도메인의 IP 주소를 찾기 위해 여러 네임 서버에 반복적인 질의를 하는 이름 서버이다.  
   리졸버는 우선 기존에 찾아 본 도메인 정보가 내용으로 담긴 캐시 파일을 살펴본다.  
   해당되는 도메인 정보가 있다면 즉시 IP 주소를 리턴한다.  
   만약 찾을 수 없는 경우 2번을 진행한다.
2. DNS 리졸버는 IP 주소를 얻기 위해 네임 서버들에게 재귀적인 쿼리를 진행한다.  
   루트, 탑 레벨, 권한 있는 도메인 서버에 차례대로 쿼리를 진행해서 IP 주소를 알아낸다.  
   이 때 리졸버는 쿼리 횟수를 줄이기 위해 기록되지 않은 도메인 네임 서버들의 주소를 저장하기도 한다.
3. 마지막으로 리졸버는 전달받은 deploy.states.com의 IP 주소를 기록하고 브라우저에 전달한다.

</br>

## Zone File

DNS는 응답을 보내기 위해 한 개 이상의 Zone File을 갖고 있다.  
Zone File은 도메인과 주소가 매핑된 일종의 테이블이다.  
Zone File은 네임과 클래스, TTL, 레코드 타입, 레코드 데이터로 구성된 레코드들로 구성되어 있다.  
네임 서버들은 이러한 Zone File들을 바탕으로 요청에 해당하는 레코드를 리턴한다.  
리졸버는 이 레코드를 살펴보고 리턴해야 할 IP 혹은 다음에 쿼리를 진행할 서버의 주소를 확인한다.

|    이름     | 레코드 클래스 |                    TTL                    |    레코드 타입     |  레코드 데이터  |
| :---------: | :-----------: | :---------------------------------------: | :----------------: | :-------------: |
| 도메인 이름 | 네트워크 타입 | 클라이언트가 데이터를 저장할 수 있는 시간 | 반환될 데이터 형식 | 반환되는 데이터 |

이름은 'example.com'과 같은 도메인 네임 혹은 서브 도메인의 이름 등을 저장한다.  
레코드 클래스는 네트워크 타입을 지정한다.  
일반적으로 IN(Internet)으로 지정된다.  
TTL(Time To Live)은 리졸버가 레코드를 몇 초 동안 저장할 지 명시한다.  
해당 시간이 지나면 리졸버가 해당 레코더를 삭제한다.  
레코드 타입은 레코드 데이터 내용의 형식이다.

</br>

### 레코드 타입

- A : 데이터가 IPv4 주소임을 명시
  - IPv4는 127.0.0.1과 같은 주소
- AAAA : 데이터가 IPv6 주소임을 명시
  - IPv6는 2001:0db8:85a3:08d3:1319:8a2e:0370:7334와 같은 새로운 형식이며, IPv4의 주소가 부족해서 도입되었다.
- CNAME : 데이터가 도메인 주소임을 명시
- NS : 데이터가 권한 있는 DNS의 주소임을 명시
- SOA : 데이터가 도메인 네임 서버들 중 주 서버 정보들에 대한 데이터이다.  
  주 네임 서버와 통신할 수 있는 포트 번호, TTL, 도메인 주소 등이 적혀 있다.
