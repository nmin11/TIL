2021 / 06 /23

# CLI 기본 명령어

CLI(Command-Line Interface)는 명령어를 입력해 컴퓨터를 조작하는 방식이다. CLI와 같은 방식이지만 대부분의 PC에서는 GUI(Graphical User Interface)를 적용하고 있다. GUI는 사용자가 화면을 통해 컴퓨터와 소통하는 방식을 말한다. 우리는 GUI가 익숙하기 때문에 CLI로 컴퓨터와 소통하는 일이 낯설 수 밖에 없다. 그러나 CLI의 강력한 명령어를 사용해보면 CLI의 무한한 능력에 매료될 것이다.  
컴퓨터를 조작하기 위해서는 다양한 입력(Input)이 필요하다. 입력을 담당하는 키보드나 마우스를 입력 소스(Input Source)라고 한다. 키보드나 마우스 외에도 카메라나 마이크 등 컴퓨터에 새로운 명령을 전달하는 모든 소스가 입력 소스이다.  
반대로, 입력 소스에 의해 또는 작성된 프로그램에 의해 모니터에 화면을 나타내거나, 소리를 스피커로 전달하여 사용자가 인식할 수 있도록 하는 일을 출력(Output)이라고 한다. 시각적 출력을 담당하는 모니터나 청각적 출력을 담당하는 스피커를 출력 소스(Output Source)라고 한다. 입력과 출력을 간단하게 I/O(Input/Output)라고 표기하기도 한다.  
리눅스의 터미널은 키보드의 입력과 모니터의 출력으로 모든 작업을 할 수 있다. 리눅스 터미널은 GUI가 개발되기 이전부터 컴퓨터를 조작하기 위해 사용되었기 때문에 GUI가 할 수 있는 모든 작업은 CLI로 할 수 있다. GUI가 PC 시장을 지배하게 되었지만 CLI는 여전히 여러가지 측면에서 유리하다. 대표적으로 AWS의 클라우드 컴퓨팅처럼 대량의 서버 컴퓨터를 설치해야 하는 서비스의 경우, 수많은 컴퓨터에 GUI를 적용하기 위해 서버 컴퓨터마다 I/O 소스를 부착하는 일은 불가능에 가깝다. 예전부터 CLI를 이용해서 서버 컴퓨터와 소통했으며, 이는 매우 효율적이다. 그리고 대부분의 서버 컴퓨터는 무료로 이용할 수 있는 Linux 운영체제가 설치되어 있다. Linux 환경에서 CLI를 이용하는 방법은 개발자가 되기를 원하는 사람이라면 반드시 학습해야 한다.

</br>

## Prompt

키보드의 입력을 확인하고 편집할 수 있는 한 줄의 공간을 프롬프트라고 한다. 프롬프트에 입력한 명령을 실행하기 위해 Enter 키를 누르면 된다.

</br>

## pwd : 현재 위치 확인

pwd는 print working directory의 약자이다. CLI에서 폴더를 열거나 닫으면서 이동하면 현재 위치가 헷갈릴 수 있다. 이 때 명령어 pwd를 입력하면 현재 작업중인 폴더의 위치를 출력한다.

</br>

## mkdir : 새로운 폴더 생성

mkdir은 make directions의 약자로, 폴더를 만들라는 명령을 컴퓨터에 전달한다. 명령어 mkdir은 생성할 폴더의 이름을 함께 입력해야 한다. CLI에서는 명령어와 폴더의 이름을 Space 키로 구분한다.  
만약, 폴더 또는 파일의 이름에 공백이나 특수문자가 있다면 '\'를 통해 구분해야 한다.

</br>

## ls : 특정 폴더에 포함된 파일이나 폴더 확인

ls는 list의 약자로 특정 폴더에 포함된 파일이나 하위 폴더의 리스트를 출력한다. 명령어 ls에는 자주 사용하는 옵션 l과 s가 있다 CLI에서 특정 명령어의 옵션을 사용하는 경우에는 -를 이용해 옵션을 입력했다고 컴퓨터에 전달한다.

- ls -l
- ls -a
- ls -al 또는 ls -la

옵션 a는 all이라는 의미이다. 숨어있는 폴더나 파일을 포함한 모든 항목을 터미널에 출력한다.  
옵션 l은 폴더나 파일의 포맷을 전부 표현하라는 의미이다. 하나의 파일 또는 하나의 폴더는 한 줄에 출력된다. 여기서 맨 앞 글자가 d인 경우는 폴더를, -인 경우는 파일을 나타낸다. 폴더는 명령어 cd를 통해 진입할 수 있지만 파일은 진입할 수 없다.

</br>

## open . : 폴더를 GUI의 탐색기로 실행

현재 위치를 GUI로 실행할 수 있다.

</br>

## cd : 폴더에 진입

cd는 change directory의 약자로 프롬프트로 상호작용하는 폴더를 다른 폴더로 변경한다는 의미이다.

</br>

## touch : 파일 생성

File은 서류철이라는 뜻이다. 전자기기에서 문서의 형태로 작성된 모든 것을 파일이라고 한다. 그 중 가장 쉽게 접할 수 있는 파일은 text 파일이다. touch OOOO.txt 명령어로 간단하게 빈 텍스트 파일을 만들 수 있다.

</br>

## cat : 파일의 내용을 터미널에 출력

'cat hi.txt'와 같이 cat 명령어 뒤에 출력할 파일명을 적는다. 만약 '%'와 같이 다른 문자가 붙어있다면 한 줄의 끝에 Enter를 누르지 않은 것 뿐이고 크게 신경 쓸 필요는 없다.

</br>

## rm : 폴더나 파일 삭제

rm을 통해 폴더나 파일을 삭제할 경우 변경사항을 확인하기 위해서 명령어 ls를 자주 입력하면 도움이 된다. 명령어 rm은 단일 파일을 삭제할 수 있다. 만약 폴더를 삭제하려면 옵션을 이용해야 한다. 사용할 수 있는 옵션은 r과 f이다. rm -rf 명령어를 통해 폴더를 삭제할 수 있다. 여기서 옵션 r은 'recursive'를 뜻하고 옵션 f는 'force'를 뜻한다. 옵션 r은 폴더를 지울 때 사용하고, 옵션 f는 질문을 받지 않고 지울 때 사용한다.

</br>

## mv : 폴더나 파일의 이름 변경 / 폴더나 파일의 위치 옮기기

mv는 move의 약자로 폴더나 파일을 이동할 때 사용한다. 명령어 mv 뒤에는 순서대로 [폴더나 파일 이름] [도착 폴더 이름]을 입력한다. 명령어 mv를 이용하면 폴더나 파일의 이름을 변경할 수도 있다. 명령어 mv 뒤에 [변경 대상인 폴더나 파일의 이름] [변경할 폴더나 파일의 이름]을 입력한다.

</br>

## cp : 폴더나 파일 복사

cp는 copy의 약자로 폴더나 파일을 복사할 때 사용한다. cp [원본 파일 이름] [복사할 파일 이름]을 프롬프트에 입력한다. 폴더를 복사할 때는 삭제할 때의 rm -rf와 마찬가지로 cp -rf 옵션을 이용해서 복사하면 된다.

</br>

## 사용자와 관리자

컴퓨터의 운영체제에는 사용자와 관리자가 있다. 사용자는 우리가 일상적으로 PC를 켜서 바탕화면에 진입하기 위해 로그인하는 계정이다. 그리고 관리자는 사용자가 접근할 수 없는 영역에 접근할 수 있는 높은 권한을 가지고 있다. 분명 PC의 주인은 사용자일텐데 왜 관리자가 별도로 필요한 것일까? Windows의 초기 버전에는 관리자 권한이 없었다. 사용자 없이 항상 관리자 권한으로 프로그램을 설치, 변경, 삭제할 수 있었다.  
PC가 항상 관리자 권한으로 실행되다보니 개발에 대한 지식이 없는 일반 사용자가 정보를 탈취당하는 일이 발생했다. 항상 관리자 권한으로 실행되는 PC에서는 악성코드가 삽입된 프로그램이 어떤 안전장치도 없이 설치된다. 사용자는 어떤 프로그램에 악성코드가 심어져 있는지 파악할 수 없다.  
이에 Windows는 사용자 계정 컨트롤(UAC, User Account Control)을 도입했다. UAC는 관리자와 사용자를 구분한다. UAC는 사용자가 모르는 사이에 시스템 설정을 변경하는 악성코드가 실행될 때 접근 권한을 막아 사용자를 보호한다.  
Linux에도 UAC가 있다. 새로운 프로그램을 설치하거나 변경 또는 삭제할 때 관리자 권한이 반드시 필요하기 때문에 특정 명령어를 입력해서 잠시 관리자 권한을 빌려올 수 있다. 개발자는 이 과정을 이해하고 있어야 한다.

</br>

## 절대 경로와 상대 경로

절대 경로는 기준점으로부터의 절대적인 위치를 나타내는데, 이 기준점을 루트 폴더(/)라고 한다.  
상대 경로는 특정 폴더 또는 파일의 위치를 현재 위치를 기준점으로 나타낸다. 현재 위치한 폴더는 (.)으로 표현하고 상위 폴더는 (..)으로 표현한다. ls를 통해 확인된 현재 폴더의 파일들은 상대 경로로써 ./을 붙여 표현할 수 있다. ./는 "현재 폴더 아래의"라는 뜻이다. 반대로 ../는 "현재 폴더 상위의"라는 뜻이 된다.

</br>

## 관리자(root) 권한

절대 경로의 기준점인 루트 폴더(/)는 Linux의 관리자 영역이다. 일반 사용자 권한으로는 어떤 폴더나 파일도 생성, 변경, 삭제할 수 없다. Linux 관리자의 가장 큰 특징은 어떤 일이 있더라도 일반 사용자에게 루트 권한을 완전히 넘기지 않는다는 점이다. 사용자가 관리자 권한을 필요로 하는 경우는 새 프로그램을 설치하거나 프로그램을 변경 또는 삭제하는 경우이기 때문에 해당 경우에만 관리자 권한을 전달한다. 사용자 권한은 username 폴더에서만 자유롭게 사용할 수 있다. 그리고 사용자 폴더의 경로는 ~/로 축약된다. 그러나 사용자가 새로운 프로그램을 설치하거나 변경 또는 삭제할 때에는 관리자 권한이 필요하다. 이럴 때는 사용자가 관리자 권한일 때 사용자 권한을 이용할 수 있는 명령어 sudo를 사용한다.

</br>

## sudo : 관리자 권한 획득

명령어 ls -l을 통해 특정 폴더나 파일이 사용자 또는 관리자의 소유로 생성되었는지 확인할 수 있다. 폴더를 만들 때 sudo mkdir 명령어를 사용하면 관리자 권한으로 폴더를 만들 수 있다. sudo는 이와 같이 기본적인 CLI 명령어 앞에 작성하여 관리자 권한을 일시적으로 획득한다. sudo mkdir 명령어를 통해 폴더를 만들고 ls -l 명령어를 통해 확인해보면 username이 아닌 root가 적혀 있는 것을 확인할 수 있다.

</br>

## 텍스트 에디터 nano

CLI 환경에서 유명한 에디터는 vim, emacs 등이 있다. vim 에디터와 emacs 에디터는 매우 강력하고 다양한 기능을 제공하지만 에디터 사용을 위해서 학습을 따로 해야 할 정도로 진입장벽이 있다. 이러한 에디터들은 나중에 알아보도록 하고, CLI 초보를 위해 대부분의 Linux 환경에 탑재되어 있는 nano 에디터를 활용해보자.

</br>

### 왜 굳이 터미널에서 에디터를 사용하는가?

AWS와 같은 원격 서버 환경에서 원격으로 텍스트 파일을 편집해야 하는 경우가 있다. 따라서 터미널에서 자유자재로 다룰 수 있는 에디터가 하나쯤은 있어야 한다.

</br>

### nano 실행

nano 명령어를 통해 파일을 열거나 새 파일을 만들 수 있다.

```
nano hello.js
```

</br>

### 파일 열기

하단에 나열된 단축키 화면에 표시된 것처럼 ^R을 눌러서 열 수 있다. 기본적으로 파일 이름을 입력하도록 안내되어 있지만 ^T를 누른 후 화살표 키를 이용해 파일 및 디렉토리를 탐색한 후 불러올 수도 있다. 하지만 역시 가장 쉬운 방법은 터미널에서 애초에 파일을 지정해서 여는 것이다.

</br>

### 파일 편집 후 종료

파일에 변경사항이 존재하면 종료 시에 저장할지를 물어본다. 파일 내용을 편집하고 ^X를 누르면 프롬프트가 등장하는 것을 확인할 수 있다.

</br>

### 파일 저장

nano를 종료하지 않고 파일을 저장할 수도 있다. 단축키 모음에 Save는 보이지 않지만 ^O WriteOut으로 save할 수 있다.

</br>
</br>

# 패키지와 패키지 매니저

Linux 운영체제의 패키지와 패키지 매니저는 포장된 상품과 온라인 쇼핑몰 같은 역할을 한다. Linux의 패키지는 여러 파일을 모아 하나의 파일로 저장하고 있는 압축 파일이다. 패키지 안에 들어 있는 파일의 구성은 기본적으로 다음과 같다.

- 프로그램 파일
- 프로그램 설치 파일
- 프로그램 설치 설명서
- 프로그램에 대한 정보를 담은 파일

패키지 안에는 하나의 프로그램이 정상적으로 설치되고 동작하기 위한 모든 파일이 압축되어 있다.  
패키지 매니저를 사용하지 않고 프로그램을 독립적으로 설치하는 데에는 한 가지 큰 단점이 있다. 여러 프로그램을 개별로 설치하기 위해서는 각각의 프로그램이 저장된 위치를 모두 알아야 한다. 프로그램들이 여러 군데에 퍼져 있으면 모든 프로그램을 업데이트하는 일이 불가능에 가까워진다. 이런 점을 보완하기 위한 도구가 바로 패키지 매니저이다.  
패키지 매니저는 패키지의 설치, 변경, 삭제 등 관리를 편리하게 해주는 도구이다. 패키지 매니저를 스마트폰으로 비유하면 앱 스토어와 비슷하다. Linux는 앱 스토어와 같이 패키지 매니저를 이용해 필요한 패키지를 설치할 수 있다. 패키지 매니저는 모든 패키지의 저장소 위치를 저장하고 있다. 따라서 패키지 매니저는 설치된 모든 프로그램의 업데이트를 확인하거나 필요없는 프로그램을 제거하는 데에도 사용할 수 있다.  
맥북 환경에서는 Homebrew 패키지 매니저를 주로 사용한다. Homebrew를 설치하기 이전에 Xcode Command Line Tools를 먼저 설치해야 한다.

</br>
</br>

# Node.js

웹 브라우저는 JavaScript의 대표적인 런타임이다. 그러나 node.js라는 또다른 JavaScript 런타임으로 JavaScript를 웹 브라우저가 아닌 곳에서 실행할 수 있게 되었다. node.js와 JavaScript를 통해 웹 페이지 뿐 아니라 서버와 같은 다른 프로그램을 만들 수 있다. HTML < script > 태그 내에 JavaScript 코드를 작성하면 웹 브라우저에서 동작하듯이, CLI 환경에서 node <ㅠ file_name > 명령어를 프롬프트에 입력하면 코드가 node.js라는 런타임에서 실행된다.  
node.js에서 JavaScript를 실행시키기 위해서는 당연히 node.js를 설치해야 한다. 패키지 매니저처럼 node.js의 버전을 관리할 수 있도록 nvm(Node Version Manager)으로 node.js를 설치한다. nvm을 사용하면 node.js의 다양한 버전을 쉽게 설치하고 사용할 수 있다. 참고로 Windows 환경에서는 nvm을 사용할 수 없다.

</br>

## nvm 간단 사용법

개발을 하다 보면 node.js의 다양한 버전에 대응해야 할 경우가 있다. 예를 들어 과거 버전에서 짠 코드가 최신 버전에서는 에러가 생기는 경우가 있다. 이 경우 과거에 작성한 코드가 정상적인지 확인하기 위해 과거 버전이 필요하다. 만약 설치한 node를 업그레이드 하는 경우 nvm instal --lts를 이용해서 최신 버전으로 업그레이할 수 있다. 그러나 이전 버전을 사용하려면 가장 빠른 방법은 node.js를 삭제 후 다시 설치하는 방법이다. 이렇게 할 경우 실제 작업 환경에서 생산성이 떨어진다. 이를 도와주는 것이 **NVM** 이다.

```
nvm ls

nvm install 12.18.3
```

ls 명령어를 통해 현재 설치된 node version들을 확인할 수 있고 install 명령어 뒤에 버전을 명시해서 원하는 node version을 설치할 수 있다. 다른 버전으로 변경을 원할 때는 아래의 명령어를 사용하면 된다.

```
nvm use 12.18.3
```

정리하자면 nvm은 다양한 node version을 설치하고 관리할 수 있는 프로그램이다.

</br>

## npm과 package.json

개발할 때 모든 것을 다 만들어쓰면 시간이 많이 걸리고 우리 코드를 신뢰하기도 어렵다. 그래서 우리는 검증된 코드(모듈)를 사용한다. 이렇게 남이 만들어 놓은 모듈을 node.js에서는 npm 모듈이라는 이름으로 부르며, 이에 대한 정보를 담아둔 곳이 바로 package.json이다. 즉, 이 프로젝트(패키지) 전반에 관한 정보가 들어있다고 볼 수 있다.  
node.js 환경에서 외부 라이브러리를 다운로드 받기 위해 다양한 방법이 존재하지만 그 중 대표적인 것이 바로 npm이다. Node Package Manager는 일종의 앱 스토어이다. 필요한 모듈을 다운로드할 수 있는 모듈 스토어이다. Linux의 패키지 매니저가 apt, macOS의 패키지 매니저가 brew이듯, node.js 생태계의 패키지 매니저는 npm이다. 앞으로 필요한 모듈 대부분을 npm에서 다운로드해서 사용할 수 있다.  
package.json에는 해당 프로그램을 실행시키기 위해 필요한 모듈들이 무엇인지, 프로그램을 실행시키는 방법, 프로그램을 테스트하는 방법 등이 명시되어 있다. 헷갈리면 안되는 점은 이 프로그램을 실행시키기 위해 필요한 실제 모듈은 따로 node_modules라는 폴더에 저장된다는 것이다. package.json에는 어떤 모듈인지만 적혀 있다.  
package.json이 주는 또 하나의 이점은 프로젝트 코드를 전달할 때, 포함하고 있는 모든 모듈을 다 전달하지 않아도 된다는 점이다. "코드는 여기 있고, 필요한 모듈은 package.json에 적어놨으니 직접 다운로드받아서 쓰면 돼"라고 하면 됩니다.  
</br>
package.json의 내용들을 하나하나 살펴보도록 하자.  
먼저 devDependencies이다.

```json
{
  "devDependecies": {
    "@mochajs/json-file-reporter": "^1.2.1",
    "chai": "^4.2.0",
    "mocha": "^8.2.0",
    "sinin": "^9.0.3"
  }
}
```

devDependencies에는 이 프로젝트를 개발하는 환경에서 필요한 모듈들이 무엇인지가 적혀 있다. 예를 들면 코드 모양을 잡아주는 lint나 테스팅 모듈처럼, 실제 프로젝트 동작에 직접적으로 영향을 주지 않는 모듈들을 명시한다.

```
$ npm install mocha --save-dev
```

npm install을 이용하면 npm에 있는 모듈을 설치할 수 있다. 이 때 --save-dev 옵션을 추가하면 자동으로 devDependencies에 추가된다.

```json
{
  "dependencies": {
    "react": "^16.7.0",
    "react-dom": "^16,7.0"
  }
}
```

dependencies는 devDependencies와는 다르게, 이 프로젝트가 돌아가기 위해 반드시 필요한 모듈들이 무엇인지가 적혀 있다.

```
$ npm install react
or
$ npm install --save react
```

--save 옵션과 함께 설치하면 자동으로 dependencies에 추가되며, --save 옵션은 생략해도 좋다.  
npm install은 package.json에 있는 dependency를 바탕으로 설치를 진행한다.  
만약 dependency가 제대로 작성되어 있지 않다면 코드에서는 해당 모듈을 쓰고 있지만 npm install로는 설치되지 않는다. 따라서 팀워크를 위해 꼭 작성해주는 것이 좋다.

```json
{
  "scripts": {
    "start": "node index.js",
    "test": "mocha modern-js-koans/*.js --sort",
    "lint": "eslint",
    "report": "mocha modern-js-koans/*.js --sort --reporter @mochajs/json-file-reporter",
    "submit": "codestates-submission"
  }
}
```

```
$ npm run test
```

scripts는 CLI에서 사용 가능한 명령을 기술한다. 이를 npm script라고 부른다. CLI에서 실행할 때는 npm run <ㅠ 스크립트 이름 > 으로 실행한다.  
유용한 script 예제들은 다음과 같다

|        작업 내용         | 실행 스크립트  |
| :----------------------: | :------------: |
|     node.js 앱 실행      | npm run start  |
|       테스트 실행        |  npm run test  |
|        코드 검사         |  npm run lint  |
| 과제 제출 (코드스테이츠) | npm run submit |

※ npm 패키지, npm 모듈, npm dependency는 전부 동일한 대상을 가리킨다. 관점에 따라 다른 용어를 쓸 뿐이다. "독립적인 하나의 완성된 조각"이라는 의미로 **패키지** 라는 용어를 사용하며, 다른 프로그램에서 패키지를 가져다 쓰면 **모듈** 이라고 부른다. 이 패키지를 모듈로 사용하면 프로그램을 실행할 때 이 모듈에 의존할 수 밖에 없어서 **dependency** 라고 부른다. 용어는 다르지만 동일한 대상을 가리킨다.

</br>
</br>

# CLI 명령어 더 알아보기

## Linux 권한

터미널을 열어 ls -l 명령어를 입력하면 아래와 같은 메시지를 터미널에서 볼 수 있다.

```
drwxr-xr-x
```

- 맨 앞의 문자 'd'는 폴더를 의미하고 맨 앞에'-'가 있으면 파일을 의미한다.
- 'r'은 read의 약자로 읽기 권한을 의미한다. 파일 및 폴더 안에 있는 데이터, 속성, 서브 폴더 등에 접근 가능하다는 뜻이다.
- 'w'는 write의 약자로 쓰기 권한을 의미한다. 파일 및 폴더의 속성과 데이터를 변경할 수 있다.
- 'x'는 execute의 약자로 실행 권한을 의미한다. 해당 파일을 실행하여 사용할 수 있다.
- '-'는 권한 없음을 의미한다.

예시로 rwx는 해당 파일에 읽기, 쓰기, 실행 권한이 있음을 의미한다. r-x는 읽기, 실행 권한이 있고 쓰기 권한은 없음을 의미한다. r--는 오직 읽기 권한만 존재함을 의미한다.  
그리고 맨 앞의 문자를 제외한 나머지는 총 9글자로 되어 있음을 알 수 있다. 첫번째 부분은 파일 및 폴더를 소유하고 있는 유저가 가지는 접근 권한에 대해 설명한다. 두번째 부분은 그룹을, 3번째 부분은 다른 유저를 특정하고 있다.

[리눅스 퍼미션 Reference 문서](https://tutonics.com/2012/12/linux-file-permissions-chmod-umask.html)

</br>

## 파일 읽기

cat 명령어를 이용하면 터미널에서 파일 안에 담긴 내용을 확인할 수 있지만 항상 전체 내용을 출력하기 때문에 생기는 단점들이 있다. 가령 파일이 담고 있는 내용이 너무 길 경우 터미널 상에서 잘려서 나오는 경우가 생긴다. 그리고 항상 전체가 출력되기 때문에 원하는 정보를 찾기 위해서 때로 시간이 오래 걸린다. 전체를 열람하지 않고 파일 내용의 부분만 열람할 수 있게 만들어주는 명령어들이 있다.

</br>

### head

head 명령어는 텍스트로 된 파일의 앞부분을 지정한 만큼 출력하는 명령어이다. 반대의 경우에는 tail 명령어를 사용할 수 있다. binary로 된 파일의 내용도 명령어는 실행되지만 알아볼 수 없는 문자로 출력되므로 binary 파일에서는 사용하지 않는 것이 좋다.  
</br>
기본 사용법은 다음과 같다.

```
$ head [-n lines | -c bytes] [file ...]
```

가장 손쉽게 사용하는 방법은 다음과 같다.

```
$ head 파일명
```

아무 옵션 없이 파일명을 바로 적으면 앞에서부터 10행까지의 내용을 보여준다.

</br>

### tail

tail 명령어는 파일의 마지막 행을 기준으로 지정한 행까지의 파일내용 일부를 출력하는 명령어이다. 기본값은 마지막 10줄이다. head와 같이 -n 옵션으로 출력할 라인 수를 지정할 수 있다. 만약 파일의 특정 행부터 마지막 행까지 출력하고 싶은 경우에는 + 옵션으로 추가한다.

```
$ tail -n 20 test.txt
$ tail +20 test.txt
```

오류나 파일 로그를 실시간으로 모니터링할 경우 -f 옵션을 사용한다.

```
$ tail -f /var/log/messages.log
```

</br>

### more

파일을 읽어가면서 화면 단위로 끊어서 출력하는 명령어이다. 하지만 이 명령어는 위에서 아래 방향으로만 출력되기 때문에 지나간 내용을 다시 볼 수 없다는 단점이 있다. 왼쪽 하단에 화면에 출력된 내용이 전체의 몇 %인지를 표시하며 Enter키를 입력하면 한 줄씩 출력되고 Space bar를 입력하면 한 화면씩 출력된다. -n 옵션을 사용하면 n에 입력한 값만큼 끊어서 출력해준다.

</br>

### less

more와 반대되는 의미로 이름이 지어졌다. more와 다르게 less는 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 대용량의 파일을 열어 볼 때 빠르게 사용할 수 있다. more와 같이 Enter를 입력하면 한줄씩 출력되고 Space bar를 입력하면 한 화면씩 출력된다. 방향키로 페이지 이동이 가능하다. vi 텍스트 에디터와 유사하여 vi의 단축키가 대부분 동일하게 적용되지만 파일 수정은 불가능하다.

</br>

## 헬프 옵션

커맨드라인 명령어들은 일반적으로 도움말을 가지고 있다. 도움말을 출력하는 방법은 크게 3가지이다.

- 아무런 인자 없이 명령어를 실행한다.
- -h 옵션을 붙여서 실행한다.
- --help 옵션을 붙여서 실행한다.(가끔 -help인 경우도 있다.)
