## Elastic Beanstalk

### Deployment Modes

**All at once**

- 모든 것을 한 번에
- 가장 빠름
- downtime을 피할 수 없음
- quick iterations 환경에 적합
- 추가 비용 X

**Rolling**

- 한 번에 조금의 instances에서만 업데이트 → 이를 bucket이라고 부름
  - bucket 사이즈 지정 가능
- bucket에 대한 배포가 정상적이면 다음 bucket으로 배포 작업을 이어감
- 업데이트를 하고 있는 와중에는 애플리케이션이 동시에 2가지 버전에서 실행됨
- 추가 비용 X
- bucket size를 작게 할수록 배포 시간이 오래 걸림

**Rolling with additional batches**

- rolling과 비슷하지만 새 instances를 활용해서 늘 전체 용량을 사용
- bucket size 설정 가능
- 애플리케이션이 동시에 2가지 버전에서 실행
- 비용이 조금 발생
- additional batch는 배포 종료 후 삭제
- 배포에 시간이 오래 걸림
- prod 환경에 적합

**Immutable**

- zero downtime
- 높은 비용, 2배의 용량
- 새 인스턴스와 ASG spin up → 해당 인스턴스에 버전 업데이트 배포
- 새 인스턴스는 임시 ASG로부터 나옴
- 버전 배포 후 모두 정상이면 전체 ASG 교체
- 가장 오래 걸리는 배포
- 배포 실패 시 빠르게 롤백 (그냥 새 ASG를 종료)
- prod 환경에 적합

**Traffic Splitting**

- **Canary Testing**
- 같은 용량의 임시 ASG에 새 애플리케이션 버전 배포
- 소량의 트래픽이 설정 가능 시간 동안 임시 ASG로 이동
- deployment health is monitored
- 배포 실패 혹은 metric에 문제가 있을 경우 main ASG가 있기 때문에 빠르게 자동적으로 롤백
- zero downtime
- 문제가 없을 경우 새 인스턴스는 임시 ASG에서 기존의 main ASG로 이동
- 이동 후 이전 애플리케이션 버전 종료
- Blue / Green 배포를 위한 발전

<br>

## CloudFormation

### Intrisic Functions

- `Ref` : 매개변수 참조
- `Fn::GetAtt` : resource의 attribute 조회 `!GetAtt EC2Instance.AvailabilityZone`
- `Fn::FindInMap` : 특정 key에 해당하는 value 반환 `!FindInMap [ MapName, TopLevelKey, SecondLevelKey ]`
- `Fn::ImportValue` : exported된 값들을 가져올 때 사용
- `Fn::Join` : 구분자를 활용해서 값들을 결합 `!Join [ ":", [ a, b, c ] ]`
- `Fn::Sub` : 문자열에서 값 변경
- Condition Functions
  - `Fn::If`
  - `Fn::Not`
  - `Fn::Equals`

<br>

## S3

### Encryption for Objects

※ SSE - Server Side Encryption

**SSE-S3**

- S3에서 관리하는 키를 암호화에 사용
- `"x-amz-server-side-encryption": "AES256"`

**SSE-KMS**

- KMS에서 관리하는 키를 암호화에 사용
- `"x-amz-server-side-encryption": "aws:kms"`

**SSE-C**

- 외부에서 사용자가 직접 관리하는 키를 암호화에 사용
- S3는 사용자의 키를 저장하지 않음
- **반드시 HTTPS를 사용할 것**
- 항상 폐기되는 키라서 모든 HTTP 요청마다 HTTP 헤더를 통해 제공되어야 함

**Client Side Encryption**

- 클라이언트가 데이터를 S3에 전송하기 전 암호화
- 클라이언트가 데이터를 S3로부터 받아올 때 복호화
- 키, 암호화 주기 전체를 클라이언트가 관리
- _Amazon S3 Encryption Client_ 같은 client library를 사용할 수도 있음

<br>

## DynamoDB

### Basics

- 각 item의 최대 사이즈: 400KB

### WCU & RCU

- 1 WCU = 최대 1KB item, 초당 1개의 쓰기
- 1 RCU = 최대 4KB item, 초당 1개의 Strongly Consistent Read
- 1 RCU = 최대 4KB item, 초당 2개의 Eventually Consistent Read

### Expressions

**ProjectionExpression**

- table에서 특정 몇 가지의 attributes만 조회하도록

**KeyConditionExpression**

- Partition Key에 대해 `=` 조건 조회
- Sort Key에 대해 `=` `<` `<=` `>` `>=` `Between` `Begins` 조건 조회

**FilterExpression**

- 쿼리한 이후 결과물에 대한 filtering
- non-key attributes를 위해 사용됨

### DynamoDB Accelerator (DAX)

- 기존 DynamoDB API와 큰 차이가 없으므로 애플리케이션 로직의 변경을 요하지 않음
- **Hot Key** 문제를 해결하기 위함
- 애플리케이션은 DAX 클러스터와 직접 상호작용하고, DAX 클러스터는 table로부터 직접 데이터를 가져옴
- DAX 클러스터에 일부 데이터가 cached 된다는 의미!
  - TTL 기본값 5분
- 프로비저닝이 필요하며, 최대 10개의 nodes를 가질 수 있음
- node가 최소 3개 이상인 multi-AZ 설정 권장
- KMS, VPC, IAM, CloudTrail 등과 함께 암호화

<br>

## SQS

### Limit message size

256KB

<br>

## ECR

### Commands

**Login**

```sh
aws ecr get-login-password --region [region]
```

```sh
docker login --username AWS --password-stdin [aws_account_id].dkr.ecr.[region].amazonaws.com
```

**Push**

```sh
docker push [aws_account_id].dkr.ecr.[region].amazonaws.com/demo:latest
```

**Pull**

```sh
docker pull [aws_account_id].dkr.ecr.[region].amazonaws.com/demo:latest
```
